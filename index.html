<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CFé£æ ¼å¤šå±‚ç«æŠ€åœ°å›¾ç”Ÿæˆå™¨</title>
    <!-- Three.jsåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // å°è¯•åŠ è½½OrbitControls
        const orbitScript = document.createElement('script');
        orbitScript.src = 'https://threejs.org/examples/js/controls/OrbitControls.js';
        orbitScript.onerror = function() {
            console.warn('OrbitControlsåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨åŸºç¡€æ§åˆ¶');
        };
        document.head.appendChild(orbitScript);
    </script>
    <style>
        :root {
            /* æ·±è‰²ä¸»é¢˜å˜é‡ */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #222;
            --border-color: #333;
            --text-primary: #f0f0f0;
            --text-secondary: #ccc;
            --text-muted: #999;
            --text-darker: #888;
            --accent-color: #4CAF50;
            --accent-hover: #45a049;
            --button-secondary: #2196F3;
            --button-secondary-hover: #1976D2;
            --shadow-light: rgba(0, 0, 0, 0.8);
            --shadow-heavy: rgba(0, 0, 0, 0.8);
            --canvas-bg: #000;
        }

        [data-theme="light"] {
            /* æµ…è‰²ä¸»é¢˜å˜é‡ */
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8f8f8;
            --border-color: #ddd;
            --text-primary: #333;
            --text-secondary: #555;
            --text-muted: #666;
            --text-darker: #888;
            --accent-color: #4CAF50;
            --accent-hover: #45a049;
            --button-secondary: #2196F3;
            --button-secondary-hover: #1976D2;
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-heavy: rgba(0, 0, 0, 0.15);
            --canvas-bg: #fff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: background-color 0.3s ease;
        }

        .container {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 20px 60px var(--shadow-heavy);
            max-width: 1600px;
            width: 100%;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .header-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            position: relative;
        }

        h1 {
            color: var(--text-primary);
            font-size: 2em;
            text-shadow: 2px 2px 4px var(--shadow-light);
            transition: color 0.3s ease;
            margin: 0;
        }

        .theme-toggle {
            position: absolute;
            right: 0;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 25px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        .theme-toggle:hover {
            border-color: var(--accent-color);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--shadow-light);
        }

        .theme-icon {
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .theme-toggle:hover .theme-icon {
            transform: rotate(180deg);
        }

        .subtitle {
            text-align: center;
            color: var(--text-darker);
            margin-bottom: 25px;
            font-size: 1em;
            transition: color 0.3s ease;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: bold;
            color: var(--text-muted);
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.3s ease;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--border-color);
            outline: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            transition: background 0.3s ease;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover {
            border-color: var(--accent-color);
        }

        .value-display {
            color: var(--accent-color);
            font-weight: bold;
            margin-left: 5px;
            transition: color 0.3s ease;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        /* ç»Ÿä¸€å››æŒ‰é’®å¸ƒå±€ï¼šæ¡Œé¢ç«¯å•è¡Œå››åˆ—ï¼Œå±…ä¸­ */
        .button-group.unified-actions {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin-top: 30px;
            margin-bottom: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .button-group.unified-actions .btn {
            flex: 0 0 auto;
            min-width: 110px;
            height: 44px;
        }
        
        /* ä¸»è¦æ“ä½œæŒ‰é’®ç»„ */
        .button-group.primary-actions {
            margin-bottom: 10px;
            display: flex !important;
            justify-content: center;
            align-items: center;
            gap: 20px;
            grid-template-columns: none; /* è¦†ç›–gridå¸ƒå±€ */
        }
        
        .primary-actions button {
            background: var(--accent-color);
            font-weight: bold;
            font-size: 15px;
            min-width: 120px;
            padding: 12px 24px;
        }
        
        .primary-actions button:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        /* è¾…åŠ©åŠŸèƒ½æŒ‰é’®ç»„ */
        .secondary-actions {
            margin-top: 0;
        }

        /* ç»Ÿä¸€æŒ‰é’®ç»„ä»¶æ ·å¼ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid transparent;
            background: #2a2a2a;
            color: #eaeaea;
            font-size: 14px;
            font-weight: 600;
            line-height: 1;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            min-width: 110px;
            height: 44px;
            text-transform: none;
            letter-spacing: normal;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn:focus-visible {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        .btn--lg {
            padding: 12px 20px;
            font-size: 14px;
            min-width: 110px;
            height: 44px;
        }

        .btn--primary {
            background: var(--accent-color);
            color: #101010;
            font-weight: bold;
        }

        .btn--primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn--secondary {
            background: #3a3a3a;
            color: #f0f0f0;
            font-weight: bold;
        }

        .btn--secondary:hover {
            background: #4a4a4a;
            transform: translateY(-1px);
        }

        .btn--outline {
            background: transparent;
            color: var(--accent-color);
            border-color: var(--accent-color);
            font-weight: bold;
        }

        .btn--outline:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: var(--accent-hover);
            color: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn--ghost {
            background: rgba(255, 255, 255, 0.04);
            color: #eaeaea;
            font-weight: bold;
        }

        .btn--ghost:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
        }
        
        .secondary-actions button {
            background: var(--button-secondary);
            font-size: 14px;
        }
        
        .secondary-actions button:hover {
            background: var(--button-secondary-hover);
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            /* ç§»åŠ¨ç«¯ï¼šç»Ÿä¸€å››æŒ‰é’®é‡‡ç”¨ä¸¤åˆ—å¸ƒå±€ */
            .button-group.unified-actions {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                justify-content: center;
                gap: 10px;
                margin-top: 25px;
                margin-bottom: 15px;
                padding-top: 15px;
            }

            .button-group.unified-actions .btn {
                min-width: 100%;
                height: 44px;
            }
            
            /* ç§»åŠ¨ç«¯æ•´ä½“å¸ƒå±€ä¼˜åŒ– */
            .container {
                padding: 10px;
                min-height: 100vh;
            }
            
            .header-container {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
            
            .header-container h1 {
                font-size: 20px;
                line-height: 1.3;
            }
            
            .subtitle {
                font-size: 12px;
                margin-bottom: 15px;
            }
            
            /* æ§åˆ¶é¢æ¿ç§»åŠ¨ç«¯ä¼˜åŒ– */
            .controls-panel {
                margin-bottom: 15px;
            }
            
            .control-group {
                margin-bottom: 15px;
            }
            
            .control-group label {
                font-size: 13px;
                margin-bottom: 5px;
                display: block;
            }
            
            .control-group input[type="range"] {
                width: 100%;
                height: 35px;
            }
            
            .control-group select {
                width: 100%;
                padding: 8px;
                font-size: 14px;
            }
            
            /* æŒ‰é’®ç§»åŠ¨ç«¯ä¼˜åŒ– */
            button {
                padding: 12px 16px;
                font-size: 13px;
                min-height: 44px; /* iOSå»ºè®®çš„æœ€å°è§¦æ‘¸ç›®æ ‡ */
            }
            
            /* ç§»åŠ¨ç«¯æŒ‰é’®ç»„ä¼˜åŒ– */
            .button-group.primary-actions {
                margin-bottom: 8px;
                gap: 15px;
                flex-direction: column;
            }
            
            .primary-actions button {
                font-size: 14px;
                font-weight: bold;
                padding: 14px 16px;
                min-width: 180px;
                width: 100%;
                max-width: 250px;
            }
            
            .secondary-actions button {
                font-size: 13px;
                padding: 12px 16px;
            }
            
            .theme-toggle {
                padding: 8px 12px;
                font-size: 12px;
                min-height: 40px;
            }
            
            /* Canvasç§»åŠ¨ç«¯ä¼˜åŒ– */
            #canvas {
                max-width: 100%;
                height: auto;
                margin: 10px auto;
            }
            
            /* æ¥¼å±‚é€‰æ‹©å™¨ç§»åŠ¨ç«¯ä¼˜åŒ– */
            .floor-selector {
                margin: 10px 0;
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .floor-selector button {
                flex: 1;
                min-width: 60px;
                padding: 8px 12px;
                font-size: 12px;
            }
            
            /* ç§å­é¢æ¿ç§»åŠ¨ç«¯ä¼˜åŒ– */
            .seeds-panel {
                margin-top: 15px;
                right: 10px;
                width: calc(100vw - 20px);
                max-width: 280px;
            }
            
            .seeds-panel-close {
                font-size: 16px;
                padding: 6px 10px;
            }
            
            .seeds-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
            }
            
            .seed-item {
                padding: 8px;
                font-size: 11px;
            }
            
            /* å›¾ä¾‹ç§»åŠ¨ç«¯ä¼˜åŒ– */
            .legend {
                margin-top: 15px;
            }
            
            .legend-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 8px;
            }
            
            .legend-item {
                font-size: 11px;
                padding: 6px;
            }
            
            .legend-color {
                width: 12px;
                height: 12px;
            }
            
            /* 3Dé¢„è§ˆç§»åŠ¨ç«¯ä¼˜åŒ– */
            .preview-3d-header {
                padding: 12px 10px;
                flex-direction: column;
                gap: 10px;
            }
            
            .preview-3d-title {
                font-size: 16px;
                text-align: center;
            }
            
            .preview-3d-controls {
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }
            
            .preset-view-btn {
                padding: 8px 12px;
                font-size: 11px;
                min-width: 60px;
            }
            
            .preview-3d-close {
                padding: 8px 16px;
                font-size: 12px;
                order: -1; /* æ”¾åˆ°æœ€å‰é¢ */
                width: 100%;
                margin-bottom: 5px;
            }
            
            .preview-3d-canvas {
                height: calc(100vh - 120px);
            }
            
            .preview-3d-instructions {
                top: 120px;
                left: 10px;
                right: 10px;
                max-width: none;
                width: auto;
                font-size: 11px;
                padding: 8px;
            }
            
            .preview-3d-instructions h4 {
                font-size: 12px;
                margin-bottom: 8px;
            }
            
            .preview-3d-instructions h5 {
                font-size: 10px;
                margin: 8px 0 4px 0;
            }
            
            .preview-3d-instructions li {
                font-size: 10px;
                margin-bottom: 2px;
            }
        }
        
        @media (max-width: 480px) {
            /* å°å±æ‰‹æœºè¿›ä¸€æ­¥ä¼˜åŒ– */
            .container {
                padding: 8px;
            }
            
            .header-container h1 {
                font-size: 18px;
            }
            
            .control-group {
                margin-bottom: 12px;
            }
            
            /* å°å±ä¸»è¦æŒ‰é’®ä¼˜åŒ– */
            .primary-actions button {
                font-size: 13px;
                padding: 12px 14px;
                min-width: 160px;
            }
            
            .seeds-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                gap: 6px;
            }
            
            .legend-grid {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            
            .floor-selector button {
                min-width: 50px;
                padding: 6px 8px;
                font-size: 11px;
            }
            
            /* å°å±æ‰‹æœº3Dé¢„è§ˆè¿›ä¸€æ­¥ä¼˜åŒ– */
            .preview-3d-header {
                padding: 10px 8px;
            }
            
            .preview-3d-title {
                font-size: 14px;
            }
            
            .preset-view-btn {
                padding: 6px 8px;
                font-size: 10px;
                min-width: 50px;
            }
            
            .preview-3d-close {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .preview-3d-canvas {
                height: calc(100vh - 110px);
            }
            
            .preview-3d-instructions {
                top: 110px;
                left: 8px;
                right: 8px;
                padding: 6px;
                font-size: 10px;
            }
            
            .preview-3d-instructions h4 {
                font-size: 11px;
                margin-bottom: 6px;
            }
        }

        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex: 1;
        }

        button:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .export-btn {
            background: var(--button-secondary);
        }

        .export-btn:hover {
            background: var(--button-secondary-hover);
        }

        .floor-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            transition: all 0.3s ease;
        }
        
        .overlay-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            margin-left: 20px;
        }
        
        .overlay-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .overlay-btn.active {
            background: linear-gradient(135deg, #764ba2, #667eea);
            border-color: #8a5ec7;
        }

        .floor-btn {
            padding: 10px 20px;
            background: var(--border-color);
            color: var(--text-muted);
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            min-width: 80px;
        }

        .floor-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .floor-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-hover);
        }

        #canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            background: var(--canvas-bg);
            transition: all 0.3s ease;
        }

        .map-header {
            background: linear-gradient(to right, #2c5f2d, #1a3d1a);
            color: white;
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            transition: background 0.3s ease;
        }

        [data-theme="light"] .map-header {
            background: linear-gradient(to right, #4CAF50, #388E3C);
            color: white;
        }

        .map-name {
            font-weight: bold;
            font-size: 16px;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            transition: all 0.3s ease;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            font-size: 0.85em;
            transition: color 0.3s ease;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            transition: border 0.3s ease;
        }
        
        /* ç§å­é¢æ¿æ ·å¼ */
        .seeds-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            width: 300px;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-primary);
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .seeds-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            position: relative;
        }
        
        .seeds-panel h3 {
            margin: 0;
            color: var(--accent-color);
            font-size: 18px;
            transition: color 0.3s ease;
            flex: 1;
            text-align: center;
        }
        
        .seeds-panel-close {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
            line-height: 1;
            min-height: auto;
        }
        
        .seeds-panel-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }
        
        .seeds-panel-close:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .seed-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .seed-controls button {
            flex: 1;
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .seed-controls button:hover {
            background: #45a049;
        }
        
        .seeds-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .seed-item {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .seed-item:hover {
            background: #4a4a4a;
            border-color: #4CAF50;
        }
        
        .seed-item.selected {
            background: #4CAF50;
            border-color: #45a049;
        }
        
        .seed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
                .seed-name {
            font-weight: bold;
            color: var(--accent-color);
            transition: color 0.3s ease;
        }

        .seed-date {
            font-size: 11px;
            color: var(--text-darker);
            transition: color 0.3s ease;
        }

        .seed-params {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.3;
            transition: color 0.3s ease;
        }
        
        .seed-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
                .seed-actions button {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .seed-actions button:hover {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .seed-actions button.delete {
            background: #d32f2f;
        }
        
        .seed-actions button.delete:hover {
            background: #b71c1c;
        }

        /* 3Dé¢„è§ˆç›¸å…³æ ·å¼ */
        .preview-3d-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(5px);
            transition: background 0.3s ease;
        }

        [data-theme="light"] .preview-3d-container {
            background: rgba(255, 255, 255, 0.95);
        }

        .preview-3d-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .preview-3d-header {
            background: rgba(26, 26, 26, 0.9);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        [data-theme="light"] .preview-3d-header {
            background: rgba(248, 248, 248, 0.95);
            border-bottom: 1px solid var(--border-color);
        }

        .preview-3d-title {
            color: var(--text-primary);
            font-size: 1.2em;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        .preview-3d-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .preview-3d-close {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
        }

        .preview-3d-close:hover {
            background: #b71c1c;
        }

        .preview-3d-canvas {
            flex: 1;
            width: 100%;
            height: calc(100vh - 60px);
            background: var(--canvas-bg);
            transition: background 0.3s ease;
        }

        .preview-3d-instructions {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-secondary);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.3;
            width: 280px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px var(--shadow-light);
            transition: all 0.3s ease;
        }

        [data-theme="light"] .preview-3d-instructions {
            background: rgba(255, 255, 255, 0.9);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .preview-3d-instructions h4 {
            color: var(--accent-color);
            margin-bottom: 12px;
            font-size: 14px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            transition: all 0.3s ease;
        }

        .preview-3d-instructions h5 {
            color: var(--button-secondary);
            margin: 10px 0 6px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.3s ease;
        }

        .preview-3d-instructions ul {
            list-style: none;
            padding: 0;
            margin: 0 0 10px 0;
        }

        .preview-3d-instructions li {
            margin-bottom: 3px;
            padding: 2px 0;
            font-size: 11px;
        }

        .control-section {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
            transition: border-bottom 0.3s ease;
        }

        .control-section:last-of-type {
            border-bottom: none;
            margin-bottom: 8px;
        }

        .status-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            transition: background 0.3s ease;
        }

        [data-theme="light"] .status-section {
            background: rgba(0, 0, 0, 0.05);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 10px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .preset-view-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 5px;
            transition: all 0.2s ease;
        }

        .preset-view-btn:hover {
            background: var(--border-color);
            color: var(--text-primary);
            transform: translateY(-1px);
        }

        .preset-view-btn:active,
        .preset-view-btn.active {
            background: var(--button-secondary);
            color: white;
            border-color: var(--button-secondary);
        }

        /* UCCå¯¼å‡ºä½¿ç”¨è¯´æ˜å¼¹çª—æ ·å¼ */
        .ucc-tutorial-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
        }

        .ucc-tutorial-modal-content {
            background: var(--bg-primary);
            border: 2px solid var(--accent-color);
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }

        .ucc-tutorial-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
        }

        .ucc-tutorial-modal-header h2 {
            margin: 0;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
        }

        .ucc-tutorial-close {
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .ucc-tutorial-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .ucc-tutorial-modal-body {
            padding: 25px;
        }

        .ucc-tutorial-step {
            display: flex;
            margin-bottom: 25px;
            align-items: flex-start;
            gap: 15px;
        }

        .ucc-tutorial-step-number {
            background: var(--accent-color);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1em;
            flex-shrink: 0;
        }

        .ucc-tutorial-step-content h3 {
            margin: 0 0 10px 0;
            color: var(--accent-color);
            font-size: 1.2em;
        }

        .ucc-tutorial-step-content p {
            margin: 5px 0;
            color: var(--text-primary);
            line-height: 1.5;
        }

        .ucc-tutorial-step-content strong {
            color: var(--accent-color);
            font-weight: bold;
        }

        .ucc-tutorial-tips {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .ucc-tutorial-tips h4 {
            margin: 0 0 15px 0;
            color: var(--accent-color);
            font-size: 1.1em;
        }

        .ucc-tutorial-tips ul {
            margin: 0;
            padding-left: 20px;
        }

        .ucc-tutorial-tips li {
            margin-bottom: 8px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .ucc-tutorial-modal-footer {
            padding: 20px 25px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            background: var(--bg-secondary);
            border-radius: 0 0 15px 15px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .ucc-tutorial-modal-content {
                width: 95%;
                margin: 20px;
            }
            
            .ucc-tutorial-modal-header {
                padding: 15px 20px;
            }
            
            .ucc-tutorial-modal-header h2 {
                font-size: 1.3em;
            }
            
            .ucc-tutorial-modal-body {
                padding: 20px;
            }
            
            .ucc-tutorial-step {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }
            
            .ucc-tutorial-modal-footer {
                flex-direction: column;
                gap: 10px;
            }
        }


    </style>
</head>
<body>
    <div class="container">
        <div class="header-container">
            <h1>ğŸ® CFé£æ ¼å¤šå±‚ç«æŠ€åœ°å›¾ç”Ÿæˆå™¨</h1>
            <div class="theme-toggle" onclick="toggleTheme()">
                <span class="theme-icon">ğŸŒ™</span>
                <span class="theme-text">æ·±è‰²</span>
            </div>
        </div>
        <div class="subtitle">ç”Ÿæˆå¤šå±‚çˆ†ç ´æ¨¡å¼ç«æŠ€åœ°å›¾</div>
        
        <div class="controls">
            <div class="control-group">
                <label>åœ°å›¾Xå°ºå¯¸: <span class="value-display" id="sizeXValue">200</span></label>
                <input type="range" id="mapSizeX" min="20" max="800" value="200" step="10">
            </div>
            
            <div class="control-group">
                <label>åœ°å›¾Yå°ºå¯¸: <span class="value-display" id="sizeYValue">200</span></label>
                <input type="range" id="mapSizeY" min="20" max="800" value="200" step="10">
            </div>
            
            <div class="control-group">
                <label>åœ°å›¾å±‚æ•°: <span class="value-display" id="floorsValue">1</span></label>
                <input type="range" id="floorCount" min="1" max="10" value="1" step="1">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´æ•°é‡: <span class="value-display" id="roomValue">12</span></label>
                <input type="range" id="roomCount" min="0" max="100" value="12">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´å¤§å°: <span class="value-display" id="roomSizeValue">ä¸­</span></label>
                <input type="range" id="roomSize" min="0" max="4" value="2">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´ä½ç½®: </label>
                <select id="roomPosition">
                    <option value="random" selected>éšæœºä½ç½®</option>
                    <option value="inner">é“è·¯å†…ä¾§</option>
                    <option value="outer">é“è·¯å¤–ä¾§</option>
                    <option value="mixed">æ··åˆä½ç½®</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>èµ°å»Šå®½åº¦: <span class="value-display" id="corridorValue">2-4</span></label>
                <input type="range" id="corridorWidth" min="0" max="10" value="2">
            </div>
            
            <div class="control-group">
                <label>é“è·¯æ›²æŠ˜åº¦: <span class="value-display" id="pathValue">ä¸­</span></label>
                <input type="range" id="pathComplexity" min="0" max="4" value="2">
            </div>
            

            
            <div class="control-group">
                <label>èµ°å»Šæ¨¡å¼: </label>
                <select id="corridorRandom">
                    <option value="fixed">å›ºå®šå®½åº¦</option>
                    <option value="random" selected>éšæœºå®½åº¦</option>
                    <option value="varied">å˜åŒ–å®½åº¦</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æ©ä½“å¯†åº¦: <span class="value-display" id="coverValue">0</span>%</label>
                <input type="range" id="coverDensity" min="0" max="100" value="0" step="5">
            </div>
            
            <div class="control-group">
                <label>æ°´åŸŸ: <span class="value-display" id="waterValue">0</span>%</label>
                <input type="range" id="waterAmount" min="0" max="50" value="0" step="5">
            </div>
            
            <div class="control-group">
                <label>æ¥¼æ¢¯æ•°: <span class="value-display" id="stairsValue">0</span></label>
                <input type="range" id="stairsCount" min="0" max="20" value="0">
            </div>
            
            <div class="control-group">
                <label>çª—æˆ·å¯†åº¦: <span class="value-display" id="windowValue">0</span>%</label>
                <input type="range" id="windowDensity" min="0" max="100" value="0" step="10">
            </div>
            
            <div class="control-group">
                <label>é«˜ä½å·®: <span class="value-display" id="elevationValue">ä¸­</span></label>
                <input type="range" id="elevation" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>ç‹™å‡»é•¿é“: <span class="value-display" id="longValue">0</span></label>
                <input type="range" id="longLanes" min="0" max="20" value="0">
            </div>
            
            <div class="control-group">
                <label>ä¸­è·¯æ§åˆ¶: </label>
                <select id="midControl">
                    <option value="none">æ— ä¸­è·¯</option>
                    <option value="single" selected>å•ä¸­è·¯</option>
                    <option value="double">åŒä¸­è·¯</option>
                    <option value="complex">å¤æ‚ä¸­è·¯</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æ—‹è½¬æ—¶é—´: <span class="value-display" id="rotateValue">ä¸­</span></label>
                <input type="range" id="rotateTime" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>å‚ç›´åº¦: <span class="value-display" id="verticalValue">20</span>%</label>
                <input type="range" id="verticality" min="0" max="100" value="20" step="10">
            </div>
            
            <div class="control-group">
                <label>å¯ç ´åç‰©: <span class="value-display" id="breakValue">10</span>%</label>
                <input type="range" id="breakables" min="0" max="100" value="10" step="5">
            </div>
            
            <div class="control-group">
                <label>åœºåœ°å¸ƒå±€: </label>
                <select id="fieldLayout">
                    <option value="indoor" selected>çº¯å†…åœº</option>
                    <option value="outdoor">çº¯å¤–åœº</option>
                    <option value="mixed">æ··åˆåœºåœ°</option>
                    <option value="central_outdoor">ä¸­å¤®å¤–åœº</option>
                    <option value="peripheral_outdoor">è¾¹ç¼˜å¤–åœº</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æ¸¸æˆæ¨¡å¼: </label>
                <select id="gameMode">
                    <option value="team" selected>å›¢é˜Ÿç«æŠ€</option>
                    <option value="bomb">çˆ†ç ´æ¨¡å¼</option>
                    <option value="zombie">ç”ŸåŒ–æ¨¡å¼</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>åœ°å›¾é£æ ¼: </label>
                <select id="mapStyle">
                    <option value="balanced" selected>å¹³è¡¡å‹</option>
                    <option value="ct_sided">CTä¼˜åŠ¿</option>
                    <option value="t_sided">Tä¼˜åŠ¿</option>
                    <option value="aim_heavy">æªæ³•å‹</option>
                    <option value="tactical">æˆ˜æœ¯å‹</option>
                    <option value="rush">å¿«æ”»å‹</option>
                    <option value="black_town">é»‘è‰²åŸé•‡</option>
                    <option value="desert_gray">æ²™æ¼ ç°</option>
                    <option value="new_year_plaza">æ–°å¹´å¹¿åœº</option>
                    <option value="white_house">ç™½æˆ¿</option>
                    <option value="transport_ship">è¿è¾“èˆ¹</option>
                    <option value="satellite_base">å«æ˜ŸåŸºåœ°</option>
                    <option value="harbor_dock">æ¸¯å£ç å¤´</option>
                    <option value="subway_station">åœ°é“ç«™</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>å¤–åœºæ¯”ä¾‹: <span class="value-display" id="outdoorValue">20</span>%</label>
                <input type="range" id="outdoorRatio" min="0" max="100" value="20" step="5">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="outdoorWall" style="margin-right:8px;vertical-align:middle;"> å¤–åœºå›´å¢™
                </label>
            </div>
            
            
            
            <div class="control-group">
                <label>å¤§é“ç”Ÿæˆ: <span class="value-display" id="longLaneValue">ä¸­</span></label>
                <input type="range" id="longLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>å°é“ç”Ÿæˆ: <span class="value-display" id="shortLaneValue">ä¸­</span></label>
                <input type="range" id="shortLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ä¸­è·¯ç”Ÿæˆ: <span class="value-display" id="midLaneValue">ä¸­</span></label>
                <input type="range" id="midLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>é«˜å°ç”Ÿæˆ: <span class="value-display" id="platformValue">ä¸­</span></label>
                <input type="range" id="platform" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>æš—é“ç”Ÿæˆ: <span class="value-display" id="underpassValue">ä¸­</span></label>
                <input type="range" id="underpass" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>è¿æ¥è·¯ç”Ÿæˆ: <span class="value-display" id="connectorValue">ä¸­</span></label>
                <input type="range" id="connector" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>æ–œå¡ç”Ÿæˆ: <span class="value-display" id="rampValue">ä¸­</span></label>
                <input type="range" id="ramp" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>è½¬ç‚¹è·¯çº¿: <span class="value-display" id="rotationValue">ä¸­</span></label>
                <input type="range" id="rotation" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>åŒ…ç‚¹æ•°é‡: <span class="value-display" id="bombSiteValue">2</span></label>
                <input type="range" id="bombSiteCount" min="1" max="5" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>é˜´ç‚¹å¯†åº¦: <span class="value-display" id="shadowPointValue">æ— </span></label>
                <input type="range" id="shadowPoint" min="0" max="4" value="0" step="1">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´å¡«å……: <span class="value-display" id="roomFillValue">æ— </span></label>
                <input type="range" id="roomFill" min="0" max="4" value="0" step="1">
            </div>
            
            <div class="control-group">
                <label>ç”Ÿæˆå¤§å…: </label>
                <select id="generateLobby">
                    <option value="none">æ— å¤§å…</option>
                    <option value="small" selected>å°å‹å¤§å…</option>
                    <option value="medium">ä¸­å‹å¤§å…</option>
                    <option value="large">å¤§å‹å¤§å…</option>
                    <option value="central">ä¸­å¤®å¤§å…</option>
                    <option value="circle">åœ†å½¢å¤§å…</option>
                    <option value="cross">åå­—å¤§å…</option>
                    <option value="square">æ–¹å½¢å¤§å…</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æŠ•æ·ç‰©ç‚¹: <span class="value-display" id="nadeValue">15</span></label>
                <input type="range" id="nadeSpots" min="5" max="100" value="15" step="5">
            </div>
            
            <!-- UCCå¯¼å‡ºè®¾ç½® -->
            <div class="control-group">
                <label style="color: var(--accent-color); font-weight: bold; border-bottom: 1px solid var(--accent-color); margin-bottom: 10px; padding-bottom: 5px;">UCCå¯¼å‡ºè®¾ç½®</label>
            </div>
            
            <div class="control-group">
                <label>Zè½´æ—‹è½¬è§’åº¦: <span class="value-display" id="uccZRotationValue">180</span>Â°</label>
                <input type="range" id="uccZRotation" min="-360" max="360" value="180" step="1">
            </div>
            
            <div class="control-group">
                <label>ä½ç½®å€å¢å™¨: <span class="value-display" id="uccPositionMultiplierValue">1.00</span></label>
                <input type="range" id="uccPositionMultiplier" min="0.1" max="10" value="1" step="0.1">
            </div>
            
            <div class="control-group">
                <label>ç¼©æ”¾å€å¢å™¨: <span class="value-display" id="uccScaleMultiplierValue">1.00</span></label>
                <input type="range" id="uccScaleMultiplier" min="0.1" max="10" value="1" step="0.1">
            </div>
            
            <div class="control-group">
                <label>å¢™ä½“é«˜åº¦: <span class="value-display" id="uccWallHeightValue">1.00</span></label>
                <input type="range" id="uccWallHeight" min="0.1" max="10" value="1" step="0.1">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="uccAutoConvertNegative" style="margin-right:8px;vertical-align:middle;"> è´Ÿå€¼è½¬æ­£
                </label>
            </div>
            
            <div class="control-group">
                <label></label>
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
                    <input type="file" id="templateFileInput" accept=".ucc" style="display:none;" />
                </div>
            </div>
            
            <div class="control-group">
                <div class="button-group unified-actions">
                    <button class="btn btn--primary btn--lg" id="generateBtn">ç”Ÿæˆåœ°å›¾</button>
                    <button class="btn btn--secondary btn--lg" id="randomBtn">éšæœºç”Ÿæˆ</button>
                    <button class="btn btn--outline btn--lg" id="preview3DBtn">3Dé¢„è§ˆ</button>
                    <button class="btn btn--ghost btn--lg export-btn" id="exportBtn">å¯¼å‡º</button>
                    <button class="btn btn--ghost btn--lg export-btn" id="exportUCCBtn">å¯¼å‡ºUCC</button>
                </div>
                
                <!-- UCCå¯¼å‡ºæ—¥å¿— -->
                <div class="control-group">
                    <label></label>
                    <div id="uccExportLog" style="background: var(--bg-tertiary); padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; color: var(--text-secondary);"></div>
                </div>
            </div>
        </div>
        
        <div class="map-header">
            <div class="map-name" id="mapName">ç«æŠ€åœ°å›¾</div>
            <div>å¤šå±‚çˆ†ç ´æ¨¡å¼</div>
        </div>
        
        <div class="floor-selector" id="floorSelector"></div>
        
        <canvas id="canvas"></canvas>
        
        <div class="seeds-panel">
            <div class="seeds-panel-header">
                <h3>ç§å­æ”¶è—</h3>
                <button class="seeds-panel-close" id="seedsPanelCloseBtn">âœ•</button>
            </div>
            <div class="seed-controls">
                <button id="saveSeedBtn">ğŸ’¾ ä¿å­˜å½“å‰ç§å­</button>
                <button id="clearSeedsBtn">ğŸ—‘ï¸ æ¸…ç©ºæ”¶è—</button>
            </div>
            <div class="seeds-list" id="seedsList">
                <!-- ç§å­åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a4a4a;"></div>
                <span>ä¸­ç­‰åœ°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a6a4a;"></div>
                <span>é«˜åœ°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a2a4a;"></div>
                <span>ä½åœ°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #b0b0b0;"></div>
                <span>å¢™å£</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #303030;"></div>
                <span>æ©ä½“</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a4d69;"></div>
                <span>æ°´åŸŸ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8B7355;"></div>
                <span>æ¥¼æ¢¯(ä¸Š)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6B5345;"></div>
                <span>æ¥¼æ¢¯(ä¸‹)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a8caf;"></div>
                <span>çª—æˆ·</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a5a00;"></div>
                <span>AåŒ…ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a3a00;"></div>
                <span>BåŒ…ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a1a00;"></div>
                <span>CåŒ…ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3a5a00;"></div>
                <span>DåŒ…ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #1a5a00;"></div>
                <span>EåŒ…ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a4a4a;"></div>
                <span>ç‹™å‡»é•¿é“</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3a2020;"></div>
                <span>Tå‡ºç”Ÿç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #202030;"></div>
                <span>CTå‡ºç”Ÿç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a8a6a;"></div>
                <span>å¤–åœºåœ°é¢</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a8a7a;"></div>
                <span>å¤–åœºå›´å¢™</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a7a8a;"></div>
                <span>å¤§å…</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a6a7a;"></div>
                <span>å¤§å…å…¥å£</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a6a8a;"></div>
                <span>å¤§å…ä¸­å¿ƒ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                <span>å åŠ è§†å›¾</span>
            </div>
        </div>
    </div>

    <!-- 3Dé¢„è§ˆå®¹å™¨ -->
    <div class="preview-3d-container" id="preview3DContainer">
        <div class="preview-3d-content">
            <div class="preview-3d-header">
                <div class="preview-3d-title">ğŸ® 3Dåœ°å›¾é¢„è§ˆ</div>
                <div class="preview-3d-controls">
                    <button class="preset-view-btn" id="topViewBtn" title="ä¿¯è§†è§’åº¦">ğŸ” ä¿¯è§†</button>
                    <button class="preset-view-btn" id="isometricViewBtn" title="ç­‰è½´è§†è§’">ğŸ“ ç­‰è½´</button>
                    <button class="preset-view-btn" id="perspectiveViewBtn" title="é€è§†è§’åº¦">ğŸ‘ï¸ é€è§†</button>
                    <button class="preset-view-btn" id="walkViewBtn" title="è¡Œèµ°è§†è§’">ğŸš¶ è¡Œèµ°</button>
                    <button class="preview-3d-close" id="close3DBtn">å…³é—­</button>
                </div>
            </div>
            <div class="preview-3d-canvas" id="preview3DCanvas"></div>
            <div class="preview-3d-instructions">
                <h4>ğŸ® æ“ä½œè¯´æ˜</h4>
                <div class="control-section">
                    <h5>ğŸ–±ï¸ é¼ æ ‡æ§åˆ¶</h5>
                    <ul>
                        <li>å·¦é”®æ‹–æ‹½ï¼šæ—‹è½¬è§†è§’</li>
                        <li>å³é”®æ‹–æ‹½ï¼šå¹³ç§»è§†è§’</li>
                        <li>æ»šè½®ï¼šç¼©æ”¾è§†è§’</li>
                        <li>åŒå‡»ï¼šèšç„¦åˆ°åœ°å›¾ä¸­å¿ƒ</li>
                    </ul>
                </div>
                <div class="control-section">
                    <h5>âŒ¨ï¸ é”®ç›˜å¿«æ·é”®</h5>
                    <ul>
                        <li>Rï¼šé‡ç½®è§†è§’</li>
                        <li>Fï¼šèšç„¦åœ°å›¾</li>
                        <li>1-4ï¼šåˆ‡æ¢é¢„è®¾è§†è§’</li>
                        <li>+/-ï¼šç¼©æ”¾</li>
                        <li>æ–¹å‘é”®ï¼šç§»åŠ¨è§†è§’</li>
                        <li>ESCï¼šå…³é—­é¢„è§ˆ</li>
                    </ul>
                </div>
                <div class="control-section">
                    <h5>ğŸ“± è§¦å±æ”¯æŒ</h5>
                    <ul>
                        <li>å•æŒ‡æ‹–æ‹½ï¼šæ—‹è½¬</li>
                        <li>åŒæŒ‡æåˆï¼šç¼©æ”¾</li>
                        <li>åŒæŒ‡æ‹–æ‹½ï¼šå¹³ç§»</li>
                    </ul>
                </div>
                <div class="status-section">
                    <div class="status-item">
                        æ§åˆ¶å™¨ï¼š<span id="controlStatus">ğŸ”§ åŠ è½½ä¸­...</span>
                    </div>
                    <div class="status-item">
                        çŠ¶æ€ï¼š<span id="debug3DStatus">åˆå§‹åŒ–ä¸­...</span>
                    </div>
                    <div class="status-item">
                        å¸§ç‡ï¼š<span id="fpsCounter">-- FPS</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let mapFloors = [];
        let currentFloor = 0;
        let totalFloors = 2;
        let overlayMode = false;
        
        // 3Dé¢„è§ˆç›¸å…³å˜é‡
        let scene3D, camera3D, renderer3D, controls3D;
        let preview3DActive = false;
        
        // å¢å¼ºæ§åˆ¶å˜é‡
        let cameraAnimating = false;
        let targetPosition = new THREE.Vector3();
        let targetLookAt = new THREE.Vector3();
        let cameraVelocity = new THREE.Vector3();
        let lastCameraUpdate = 0;
        let mapCenter = new THREE.Vector3();
        let currentPresetView = 'perspective';
        
        // å¸§ç‡ç›‘æ§
        let frameCount = 0;
        let lastFPSUpdate = 0;
        
        // è§¦æ‘¸æ§åˆ¶å˜é‡
        let touches = {};
        let touchStartDistance = 0;
        let touchStartCenter = { x: 0, y: 0 };
        
        // åœ°å›¾å…ƒç´ ç±»å‹
        const TileType = {
            VOID: 0,
            FLOOR: 1,
            WALL: 2,
            DOOR: 3,
            WINDOW: 4,
            COVER: 5,
            BOMBSITE_A: 6,
            BOMBSITE_B: 7,
            BOMBSITE_C: 40, // æ–°å¢åŒ…ç‚¹C
            BOMBSITE_D: 41, // æ–°å¢åŒ…ç‚¹D
            BOMBSITE_E: 42, // æ–°å¢åŒ…ç‚¹E
            T_SPAWN: 8,
            CT_SPAWN: 9,
            STAIRS_UP: 10,
            STAIRS_DOWN: 11,
            WATER: 12,
            BRIDGE: 13,
            ELEVATED: 14,      // é«˜å°
            LOWERED: 15,       // ä½åœ°
            BREAKABLE: 16,     // å¯ç ´åå¢™
            HIGH_GROUND: 29,   // é«˜åœ°
            LOW_GROUND: 30,    // ä½åœ°
            MEDIUM_GROUND: 31, // ä¸­ç­‰åœ°
            MID_AREA: 18,      // ä¸­è·¯åŒºåŸŸ
            NADE_SPOT: 19,     // æŠ•æ·ç‰©ç‚¹
            BOOST_SPOT: 20,    // è·³ç‚¹ä½ç½®
            ONE_WAY: 21,       // å•å‘ä½ç½®
            OUTDOOR: 22,       // å¤–åœºåœ°é¢
            OUTDOOR_WALL: 23,  // å¤–åœºå¢™å£/å›´å¢™
            OUTDOOR_COVER: 24, // å¤–åœºæ©ä½“ï¼ˆé›†è£…ç®±ã€è½¦è¾†ç­‰ï¼‰
            SKYBOX: 25,       // å¤©ç©ºç›’åŒºåŸŸ
            LOBBY: 26,        // å¤§å…
            LOBBY_ENTRANCE: 27, // å¤§å…å…¥å£
            LOBBY_CENTER: 28,  // å¤§å…ä¸­å¿ƒ
            // å¸¸è§åœ°å½¢/æ¨¡å—
            LONG_LANE: 32,     // å¤§é“ï¼ˆé•¿ç›´é€šé“ï¼‰
            SHORT_LANE: 33,    // å°é“ï¼ˆçª„é€šé“ï¼‰
            MID_LANE: 34,      // ä¸­è·¯ï¼ˆäº¤æ±‡åŒºï¼‰
            PLATFORM: 35,      // é«˜å°/å¹³å°
            UNDERPASS: 36,     // æš—é“/ä¸‹æ°´é“
            CONNECTOR: 37,     // è¿æ¥è·¯
            RAMP: 38,          // æ–œå¡
            ROTATION_PATH: 39, // è½¬ç‚¹/è½®è½¬è·¯çº¿
            SHADOW_POINT: 43   // é˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
        };
        
        // æ›´æ–°æ»‘å—æ˜¾ç¤º
        document.getElementById('mapSizeX').oninput = function() {
            document.getElementById('sizeXValue').textContent = this.value;
        };
        
        document.getElementById('mapSizeY').oninput = function() {
            document.getElementById('sizeYValue').textContent = this.value;
        };
        
        document.getElementById('floorCount').oninput = function() {
            document.getElementById('floorsValue').textContent = this.value;
        };
        
        document.getElementById('roomCount').oninput = function() {
            document.getElementById('roomValue').textContent = this.value;
        };
        
        document.getElementById('corridorWidth').oninput = function() {
            const val = parseInt(this.value);
            const mode = document.getElementById('corridorRandom').value;
            if (mode === 'fixed') {
                document.getElementById('corridorValue').textContent = val + 1;
            } else if (mode === 'random') {
                document.getElementById('corridorValue').textContent = val + '-' + (val + 2);
            } else {
                document.getElementById('corridorValue').textContent = '1-' + (val + 2);
            }
        };
        
        document.getElementById('coverDensity').oninput = function() {
            document.getElementById('coverValue').textContent = this.value;
        };
        
        document.getElementById('waterAmount').oninput = function() {
            document.getElementById('waterValue').textContent = this.value;
        };
        
        document.getElementById('stairsCount').oninput = function() {
            document.getElementById('stairsValue').textContent = this.value;
        };
        
        document.getElementById('outdoorRatio').oninput = function() {
            document.getElementById('outdoorValue').textContent = this.value;
        };
        
        // å¤–åœºå›´å¢™å‚æ•°
        document.getElementById('outdoorWall').onchange = function() {
            // å¯é€‰æ‹©åœ¨æ­¤è§¦å‘é¢„è§ˆåˆ·æ–°
        };
        
        // å¸¸è§åœ°å½¢/æ¨¡å—å‚æ•°äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('longLane').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('longLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('shortLane').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('shortLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('midLane').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('midLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('platform').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('platformValue').textContent = values[this.value];
        };
        
        document.getElementById('underpass').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('underpassValue').textContent = values[this.value];
        };
        
        document.getElementById('connector').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('connectorValue').textContent = values[this.value];
        };
        
        document.getElementById('ramp').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('rampValue').textContent = values[this.value];
        };
        
        document.getElementById('rotation').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('rotationValue').textContent = values[this.value];
        };
        
        document.getElementById('bombSiteCount').oninput = function() {
            document.getElementById('bombSiteValue').textContent = this.value;
        };
        
        document.getElementById('shadowPoint').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('shadowPointValue').textContent = values[this.value];
        };
        
        document.getElementById('pathComplexity').oninput = function() {
            const values = ['ç›´çº¿', 'å¾®å¼¯', 'ä¸­ç­‰', 'æ›²æŠ˜', 'è¿·å®«'];
            document.getElementById('pathValue').textContent = values[this.value];
        };
        

        
        document.getElementById('elevation').oninput = function() {
            const values = ['ä½', 'ä¸­', 'é«˜'];
            document.getElementById('elevationValue').textContent = values[this.value];
        };
        
        document.getElementById('roomSize').oninput = function() {
            const values = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
            document.getElementById('roomSizeValue').textContent = values[this.value];
        };
        
        document.getElementById('roomFill').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('roomFillValue').textContent = values[this.value];
        };
        
        document.getElementById('longLanes').oninput = function() {
            document.getElementById('longValue').textContent = this.value;
        };
        
        document.getElementById('rotateTime').oninput = function() {
            const values = ['çŸ­', 'ä¸­', 'é•¿'];
            document.getElementById('rotateValue').textContent = values[this.value];
        };
        
        document.getElementById('verticality').oninput = function() {
            document.getElementById('verticalValue').textContent = this.value;
        };
        
        document.getElementById('breakables').oninput = function() {
            document.getElementById('breakValue').textContent = this.value;
        };
        
        document.getElementById('nadeSpots').oninput = function() {
            document.getElementById('nadeValue').textContent = this.value;
        };
        
        // UCCå¯¼å‡ºæ§åˆ¶å™¨
        document.getElementById('uccZRotation').oninput = function() {
            document.getElementById('uccZRotationValue').textContent = this.value;
        };
        
        document.getElementById('uccPositionMultiplier').oninput = function() {
            document.getElementById('uccPositionMultiplierValue').textContent = parseFloat(this.value).toFixed(2);
        };
        
        document.getElementById('uccScaleMultiplier').oninput = function() {
            document.getElementById('uccScaleMultiplierValue').textContent = parseFloat(this.value).toFixed(2);
        };
        
        document.getElementById('uccWallHeight').oninput = function() {
            document.getElementById('uccWallHeightValue').textContent = parseFloat(this.value).toFixed(2);
        };
        
        // æ¸¸æˆæ¨¡å¼é€‰æ‹©äº‹ä»¶
        document.getElementById('gameMode').onchange = function() {
            const gameMode = this.value;
            applyGameMode(gameMode);
        };
        
        // åœ°å›¾é£æ ¼é€‰æ‹©äº‹ä»¶
        document.getElementById('mapStyle').onchange = function() {
            const mapStyle = this.value;
            applyMapStyle(mapStyle);
        };
        
        // å®‰å…¨è®¾ç½®å…ƒç´ å€¼çš„è¾…åŠ©å‡½æ•°
        function safeSetValue(elementId, value) {
            try {
                const element = document.getElementById(elementId);
                if (element) {
                    element.value = value;
                    return true;
                }
            } catch (error) {
                console.warn(`æ— æ³•è®¾ç½®å…ƒç´  ${elementId} çš„å€¼:`, error);
            }
            return false;
        }
        
        // å®‰å…¨è®¾ç½®å…ƒç´ æ–‡æœ¬çš„è¾…åŠ©å‡½æ•°
        function safeSetText(elementId, text) {
            try {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = text;
                    return true;
                }
            } catch (error) {
                console.warn(`æ— æ³•è®¾ç½®å…ƒç´  ${elementId} çš„æ–‡æœ¬:`, error);
            }
            return false;
        }
        
        // å®‰å…¨è®¾ç½®å¤é€‰æ¡†çŠ¶æ€çš„è¾…åŠ©å‡½æ•°
        function safeSetChecked(elementId, checked) {
            try {
                const element = document.getElementById(elementId);
                if (element) {
                    element.checked = checked;
                    return true;
                }
            } catch (error) {
                console.warn(`æ— æ³•è®¾ç½®å…ƒç´  ${elementId} çš„é€‰ä¸­çŠ¶æ€:`, error);
            }
            return false;
        }

        // éšæœºç”Ÿæˆå‚æ•°
        function randomizeParameters() {
            // åœ°å›¾å°ºå¯¸å’Œæ¥¼å±‚æ•°ä¿æŒä¸å˜ï¼Œä¸éšæœºåŒ–
            
            // éšæœºæˆ¿é—´æ•°é‡ (3-100)
            const roomCount = Math.floor(Math.random() * 98) + 3;
            safeSetValue('roomCount', roomCount);
            safeSetText('roomValue', roomCount);
            
            // éšæœºæˆ¿é—´å¤§å° (0-4)
            const roomSize = Math.floor(Math.random() * 5);
            safeSetValue('roomSize', roomSize);
            const roomSizeTexts = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
            safeSetText('roomSizeValue', roomSizeTexts[roomSize]);
            
            // éšæœºæˆ¿é—´ä½ç½®
            const roomPositions = ['random', 'inner', 'outer', 'mixed'];
            const roomPosition = roomPositions[Math.floor(Math.random() * roomPositions.length)];
            safeSetValue('roomPosition', roomPosition);
            
            // éšæœºèµ°å»Šå®½åº¦ (1-10)
            const corridorWidth = Math.floor(Math.random() * 10) + 1;
            safeSetValue('corridorWidth', corridorWidth);
            const corridorMode = document.getElementById('corridorRandom')?.value || 'fixed';
            let corridorValueText;
            if (corridorMode === 'fixed') {
                corridorValueText = corridorWidth + 1;
            } else if (corridorMode === 'random') {
                corridorValueText = corridorWidth + '-' + (corridorWidth + 2);
            } else {
                corridorValueText = '1-' + (corridorWidth + 2);
            }
            safeSetText('corridorValue', corridorValueText);
            
            // éšæœºé“è·¯æ›²æŠ˜åº¦ (0-4)
            const pathComplexity = Math.floor(Math.random() * 5);
            safeSetValue('pathComplexity', pathComplexity);
            const complexityTexts = ['ç®€å•', 'è¾ƒç®€å•', 'ä¸­', 'è¾ƒå¤æ‚', 'å¤æ‚'];
            safeSetText('pathValue', complexityTexts[pathComplexity]);
            

            
            // éšæœºèµ°å»Šæ¨¡å¼
            const corridorModes = ['fixed', 'random', 'varied'];
            const corridorModeRandom = corridorModes[Math.floor(Math.random() * corridorModes.length)];
            safeSetValue('corridorRandom', corridorModeRandom);
            
            // éšæœºæ©ä½“å¯†åº¦ (10-100)
            const coverDensity = Math.floor(Math.random() * 91) + 10;
            safeSetValue('coverDensity', coverDensity);
            safeSetText('coverValue', coverDensity);
            
            // éšæœºæ°´åŸŸ (0-50)
            const waterAmount = Math.floor(Math.random() * 51);
            safeSetValue('waterAmount', waterAmount);
            safeSetText('waterValue', waterAmount);
            
            // éšæœºæ¥¼æ¢¯æ•° (0-20)
            const stairsCount = Math.floor(Math.random() * 21);
            safeSetValue('stairsCount', stairsCount);
            safeSetText('stairsValue', stairsCount);
            
            // éšæœºçª—æˆ·å¯†åº¦ (0-100)
            const windowDensity = Math.floor(Math.random() * 101);
            safeSetValue('windowDensity', windowDensity);
            safeSetText('windowValue', windowDensity);
            
            // éšæœºé«˜ä½å·® (0-2)
            const elevation = Math.floor(Math.random() * 3);
            safeSetValue('elevation', elevation);
            const elevationTexts = ['æ— ', 'ä¸­', 'é«˜'];
            safeSetText('elevationValue', elevationTexts[elevation]);
            
            // ç‹™å‡»é•¿é“ä¿æŒç”¨æˆ·è®¾ç½®ï¼Œä¸éšæœºåŒ–
            
            // éšæœºä¸­è·¯æ§åˆ¶
            const midControls = ['none', 'single', 'double', 'complex'];
            const midControl = midControls[Math.floor(Math.random() * midControls.length)];
            safeSetValue('midControl', midControl);
            
            // éšæœºæ—‹è½¬æ—¶é—´ (0-2)
            const rotateTime = Math.floor(Math.random() * 3);
            safeSetValue('rotateTime', rotateTime);
            const rotateTexts = ['çŸ­', 'ä¸­', 'é•¿'];
            safeSetText('rotateValue', rotateTexts[rotateTime]);
            
            // éšæœºå‚ç›´åº¦ (0-100)
            const verticality = Math.floor(Math.random() * 101);
            safeSetValue('verticality', verticality);
            safeSetText('verticalValue', verticality);
            
            // éšæœºå¯ç ´åç‰© (0-100)
            const breakables = Math.floor(Math.random() * 101);
            safeSetValue('breakables', breakables);
            safeSetText('breakValue', breakables);
            
            // éšæœºåœºåœ°å¸ƒå±€
            const fieldLayouts = ['indoor', 'outdoor', 'mixed', 'central_outdoor', 'peripheral_outdoor'];
            const fieldLayout = fieldLayouts[Math.floor(Math.random() * fieldLayouts.length)];
            safeSetValue('fieldLayout', fieldLayout);
            
            // éšæœºæ¸¸æˆæ¨¡å¼
            const gameModes = ['team', 'bomb', 'zombie'];
            const gameMode = gameModes[Math.floor(Math.random() * gameModes.length)];
            safeSetValue('gameMode', gameMode);
            try {
                applyGameMode(gameMode);
            } catch (error) {
                console.warn('åº”ç”¨æ¸¸æˆæ¨¡å¼å¤±è´¥:', error);
            }
            
            // éšæœºåœ°å›¾é£æ ¼
            const mapStyles = ['balanced', 'ct_sided', 't_sided', 'aim_heavy', 'tactical', 'rush', 
                              'black_town', 'desert_gray', 'new_year_plaza', 'white_house', 
                              'transport_ship', 'satellite_base', 'harbor_dock', 'subway_station'];
            const mapStyle = mapStyles[Math.floor(Math.random() * mapStyles.length)];
            safeSetValue('mapStyle', mapStyle);
            try {
                applyMapStyle(mapStyle);
            } catch (error) {
                console.warn('åº”ç”¨åœ°å›¾é£æ ¼å¤±è´¥:', error);
            }
            
            // éšæœºå¤–åœºæ¯”ä¾‹ (0-100)
            const outdoorRatio = Math.floor(Math.random() * 101);
            safeSetValue('outdoorRatio', outdoorRatio);
            safeSetText('outdoorValue', outdoorRatio);
            
            // å¤–åœºå›´å¢™ï¼š50% æ¦‚ç‡å¯ç”¨
            const outdoorWall = Math.random() < 0.5;
            safeSetChecked('outdoorWall', outdoorWall);
            
            // éšæœºç”Ÿæˆå¤§å…
            const lobbyTypes = ['none', 'small', 'medium', 'large', 'central', 'circle', 'cross', 'square'];
            const lobbyType = lobbyTypes[Math.floor(Math.random() * lobbyTypes.length)];
            safeSetValue('generateLobby', lobbyType);
            
            // éšæœºå¸¸è§åœ°å½¢/æ¨¡å—å‚æ•°
            const longLane = Math.floor(Math.random() * 5);
            safeSetValue('longLane', longLane);
            const longLaneTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('longLaneValue', longLaneTexts[longLane]);
            
            const shortLane = Math.floor(Math.random() * 5);
            safeSetValue('shortLane', shortLane);
            const shortLaneTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('shortLaneValue', shortLaneTexts[shortLane]);
            
            const midLane = Math.floor(Math.random() * 5);
            safeSetValue('midLane', midLane);
            const midLaneTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('midLaneValue', midLaneTexts[midLane]);
            
            const platform = Math.floor(Math.random() * 5);
            safeSetValue('platform', platform);
            const platformTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('platformValue', platformTexts[platform]);
            
            const underpass = Math.floor(Math.random() * 5);
            safeSetValue('underpass', underpass);
            const underpassTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('underpassValue', underpassTexts[underpass]);
            
            const connector = Math.floor(Math.random() * 5);
            safeSetValue('connector', connector);
            const connectorTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('connectorValue', connectorTexts[connector]);
            
            const ramp = Math.floor(Math.random() * 5);
            safeSetValue('ramp', ramp);
            const rampTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('rampValue', rampTexts[ramp]);
            
            const rotation = Math.floor(Math.random() * 5);
            safeSetValue('rotation', rotation);
            const rotationTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('rotationValue', rotationTexts[rotation]);
            
            // éšæœºåŒ…ç‚¹æ•°é‡ (1-5)
            const bombSiteCount = Math.floor(Math.random() * 5) + 1;
            safeSetValue('bombSiteCount', bombSiteCount);
            safeSetText('bombSiteValue', bombSiteCount);
            
            // éšæœºé˜´ç‚¹å¯†åº¦ (0-4)
            const shadowPoint = Math.floor(Math.random() * 5);
            safeSetValue('shadowPoint', shadowPoint);
            const shadowPointTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('shadowPointValue', shadowPointTexts[shadowPoint]);
            
            // éšæœºæˆ¿é—´å¡«å…… (0-4)
            const roomFill = Math.floor(Math.random() * 5);
            safeSetValue('roomFill', roomFill);
            const roomFillTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            safeSetText('roomFillValue', roomFillTexts[roomFill]);
            
            // éšæœºæŠ•æ·ç‰©ç‚¹ (5-100)
            const nadeSpots = Math.floor(Math.random() * 96) + 5;
            safeSetValue('nadeSpots', nadeSpots);
            safeSetText('nadeValue', nadeSpots);
        }
        
        // å®‰å…¨çš„è¾¹ç•Œæ£€æŸ¥å‡½æ•°
        function isValidPosition(x, y, floor = 0) {
            if (!mapFloors || !mapFloors[floor]) return false;
            if (y < 0 || y >= mapFloors[floor].length) return false;
            if (!mapFloors[floor][y]) return false;
            if (x < 0 || x >= mapFloors[floor][y].length) return false;
            return true;
        }
        
        // å®‰å…¨çš„æ•°ç»„è®¿é—®å‡½æ•°
        function getTile(x, y, floor = 0, defaultValue = TileType.VOID) {
            if (!isValidPosition(x, y, floor)) return defaultValue;
            return mapFloors[floor][y][x];
        }
        
        // å®‰å…¨çš„æ•°ç»„è®¾ç½®å‡½æ•°
        function setTile(x, y, value, floor = 0) {
            if (!isValidPosition(x, y, floor)) return false;
            mapFloors[floor][y][x] = value;
            return true;
        }

        // åˆå§‹åŒ–åœ°å›¾
        function initMap(sizeX, sizeY, floors) {
            mapFloors = [];
            totalFloors = floors;
            
            for (let f = 0; f < floors; f++) {
                mapFloors[f] = [];
                for (let y = 0; y < sizeY; y++) {
                    mapFloors[f][y] = [];
                    for (let x = 0; x < sizeX; x++) {
                        mapFloors[f][y][x] = TileType.VOID;
                    }
                }
            }
        }
        
        // ç”Ÿæˆæˆ¿é—´ï¼ˆæ”¯æŒå†…å¤–åœºï¼‰
        function generateRooms(sizeX, sizeY, roomCount, floor) {
            const size = Math.max(sizeX, sizeY); // å‘åå…¼å®¹
            const rooms = [];
            // æ ¹æ®æˆ¿é—´å¤§å°å‚æ•°è°ƒæ•´æˆ¿é—´å°ºå¯¸
            const roomSizeParam = parseInt(document.getElementById('roomSize').value);
            const roomSizeMultipliers = [0.2, 0.4, 0.8, 1.5, 2.5]; // æå°ã€å°ã€ä¸­ã€å¤§ã€æå¤§ - å¢åŠ å·®å¼‚
            const roomSizeMultiplier = roomSizeMultipliers[roomSizeParam];
            
            const minRoomSize = Math.max(2, Math.floor(size / 25 * roomSizeMultiplier)); // æœ€å°æˆ¿é—´å°ºå¯¸
            const maxRoomSize = Math.max(minRoomSize + 1, Math.floor(size / 4 * roomSizeMultiplier)); // æœ€å¤§æˆ¿é—´å°ºå¯¸ï¼Œç§»é™¤ç¡¬ç¼–ç é™åˆ¶
            const fieldLayout = document.getElementById('fieldLayout').value;
            const outdoorRatio = parseInt(document.getElementById('outdoorRatio').value) / 100;
            const roomPosition = document.getElementById('roomPosition').value; // æˆ¿é—´ç”Ÿæˆä½ç½®
            
            // å…ˆåˆ›å»ºå¤–åœºåŒºåŸŸ
            if (floor === 0 && fieldLayout !== 'indoor') {
                createOutdoorAreas(Math.max(sizeX, sizeY), fieldLayout, outdoorRatio);
            }
            
            // è®¡ç®—æˆ¿é—´é—´è·ï¼ˆç¡®ä¿æˆ¿é—´ç‹¬ç«‹ï¼‰
            const minSpacing = Math.max(1, Math.floor(size / 50)); // è¿›ä¸€æ­¥å‡å°é—´è·
            
            // æ ¹æ®åœ°å›¾å¤§å°åŠ¨æ€è°ƒæ•´å°è¯•æ¬¡æ•°ï¼Œé¿å…æ— é™å¾ªç¯
            const mapSize = Math.max(sizeX, sizeY);
            const maxAttempts = Math.min(roomCount * 100, mapSize * 5, 10000); // é™åˆ¶æœ€å¤§å°è¯•æ¬¡æ•°
            for (let i = 0; i < maxAttempts; i++) {
                const width = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                const height = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                
                // æ ¹æ®æˆ¿é—´ç”Ÿæˆä½ç½®å‚æ•°å†³å®šæˆ¿é—´ä½ç½®
                let x, y;
                const centerX = Math.floor(sizeX / 2);
                const centerY = Math.floor(sizeY / 2);
                const roadRadius = Math.floor(size / 3); // å‡è®¾é“è·¯åœ¨ä¸­å¿ƒåŒºåŸŸ
                
                switch(roomPosition) {
                    case 'inner':
                        // é“è·¯å†…ä¾§ï¼ˆé è¿‘ä¸­å¿ƒï¼‰
                        const innerRadius = Math.floor(size / 4);
                        const angle = Math.random() * 2 * Math.PI;
                        const distance = Math.random() * innerRadius;
                        x = Math.floor(centerX + Math.cos(angle) * distance);
                        y = Math.floor(centerY + Math.sin(angle) * distance);
                        break;
                    case 'outer':
                        // é“è·¯å¤–ä¾§ï¼ˆè¿œç¦»ä¸­å¿ƒï¼‰
                        const outerRadius = Math.floor(size / 2.5);
                        const outerAngle = Math.random() * 2 * Math.PI;
                        const outerDistance = outerRadius + Math.random() * (size / 2 - outerRadius);
                        x = Math.floor(centerX + Math.cos(outerAngle) * outerDistance);
                        y = Math.floor(centerY + Math.sin(outerAngle) * outerDistance);
                        break;
                    case 'mixed':
                        // æ··åˆä½ç½®
                        if (Math.random() > 0.5) {
                            // å†…ä¾§
                            const mixedAngle = Math.random() * 2 * Math.PI;
                            const mixedDistance = Math.random() * (size / 3);
                            x = Math.floor(centerX + Math.cos(mixedAngle) * mixedDistance);
                            y = Math.floor(centerY + Math.sin(mixedAngle) * mixedDistance);
                        } else {
                            // å¤–ä¾§
                            const mixedOuterAngle = Math.random() * 2 * Math.PI;
                            const mixedOuterDistance = (size / 3) + Math.random() * (size / 2 - size / 3);
                            x = Math.floor(centerX + Math.cos(mixedOuterAngle) * mixedOuterDistance);
                            y = Math.floor(centerY + Math.sin(mixedOuterAngle) * mixedOuterDistance);
                        }
                        break;
                    default: // 'random'
                        // éšæœºä½ç½®
                        x = Math.floor(Math.random() * (sizeX - width - minSpacing * 2)) + minSpacing;
                        y = Math.floor(Math.random() * (sizeY - height - minSpacing * 2)) + minSpacing;
                        break;
                }
                
                // ç¡®ä¿æˆ¿é—´åœ¨è¾¹ç•Œå†…
                x = Math.max(minSpacing, Math.min(x, sizeX - width - minSpacing));
                y = Math.max(minSpacing, Math.min(y, sizeY - height - minSpacing));
                
                // é¢å¤–æ£€æŸ¥ï¼šç¡®ä¿æˆ¿é—´å®Œå…¨åœ¨åœ°å›¾èŒƒå›´å†…
                if (x < 0 || y < 0 || x + width > sizeX || y + height > sizeY) {
                    continue; // è·³è¿‡è¿™ä¸ªæˆ¿é—´ï¼Œå°è¯•ä¸‹ä¸€ä¸ª
                }
                
                // è°ƒè¯•ï¼šæ˜¾ç¤ºæˆ¿é—´ä½ç½®ä¿¡æ¯
                if (rooms.length < 3) {
                    console.log(`æˆ¿é—´${rooms.length + 1}: ä½ç½®(${x},${y}), å°ºå¯¸(${width}x${height}), ä½ç½®ç±»å‹: ${roomPosition}`);
                }
                
                // æ£€æŸ¥ä¸ç°æœ‰æˆ¿é—´çš„é‡å å’Œé—´è·
                let canPlace = true;
                for (let room of rooms) {
                    // æ£€æŸ¥é‡å ï¼ˆå‡å°‘é—´è·è¦æ±‚ï¼‰
                    const expandedX = room.x - Math.floor(minSpacing / 2);
                    const expandedY = room.y - Math.floor(minSpacing / 2);
                    const expandedWidth = room.width + Math.floor(minSpacing / 2) * 2;
                    const expandedHeight = room.height + Math.floor(minSpacing / 2) * 2;
                    
                    if (x < expandedX + expandedWidth && x + width > expandedX &&
                        y < expandedY + expandedHeight && y + height > expandedY) {
                        canPlace = false;
                        break;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸å¤–åœºé‡å ï¼ˆå¤–åœºä¼˜å…ˆï¼‰
                if (canPlace && floor === 0) {
                    for (let cy = y - 1; cy < y + height + 1; cy++) {
                        for (let cx = x - 1; cx < x + width + 1; cx++) {
                            if (cy >= 0 && cy < size && cx >= 0 && cx < size) {
                            if (getTile(cx, cy, floor) === TileType.OUTDOOR) {
                                    canPlace = false;
                                break;
                            }
                        }
                        }
                        if (!canPlace) break;
                    }
                }
                
                if (canPlace) {
                    rooms.push({ x, y, width, height, floor, isIndoor: true });
                    
                    // ç»˜åˆ¶æˆ¿é—´ï¼ˆå†…åœºï¼‰- ç¡®ä¿å¢™å£å®Œæ•´
                    for (let ry = y; ry < y + height; ry++) {
                        for (let rx = x; rx < x + width; rx++) {
                            if (ry === y || ry === y + height - 1 || rx === x || rx === x + width - 1) {
                                // æˆ¿é—´è¾¹ç•Œå¢™å£
                                setTile(rx, ry, TileType.WALL, floor);
                                } else {
                                // æˆ¿é—´å†…éƒ¨åœ°æ¿
                                setTile(rx, ry, TileType.FLOOR, floor);
                            }
                        }
                    }
                    
                    // åœ¨æˆ¿é—´å‘¨å›´æ·»åŠ ç¼“å†²åŒºï¼ˆå‡å°‘ç¼“å†²åŒºå¤§å°ï¼‰
                    addRoomBuffer(x, y, width, height, floor, size, Math.floor(minSpacing / 2));
                    
                    if (rooms.length >= roomCount) break;
                }
            }
            
            // è°ƒè¯•ä¿¡æ¯ï¼šæ˜¾ç¤ºå®é™…ç”Ÿæˆçš„æˆ¿é—´æ•°é‡
            console.log(`ç›®æ ‡æˆ¿é—´æ•°é‡: ${roomCount}, å®é™…ç”Ÿæˆæˆ¿é—´æ•°é‡: ${rooms.length}`);
            console.log(`æˆ¿é—´å°ºå¯¸èŒƒå›´: ${minRoomSize}-${maxRoomSize}, é—´è·: ${minSpacing}`);
            console.log(`åœ°å›¾å¤§å°: ${size}x${size}, æˆ¿é—´å¤§å°å€æ•°: ${roomSizeMultiplier}`);
            console.log(`æˆ¿é—´å¤§å°å‚æ•°: ${roomSizeParam} (${['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'][roomSizeParam]})`);
            console.log(`å°è¯•æ¬¡æ•°: ${roomCount * 100}, æˆåŠŸç‡: ${(rooms.length / roomCount * 100).toFixed(1)}%`);
            
            return rooms;
        }
        
        // åˆ›å»ºå¤–åœºåŒºåŸŸ
        function createOutdoorAreas(size, layout, ratio) {
            // å¤–åœºå°ºå¯¸/é¢ç§¯å‚æ•°å·²ç§»é™¤ï¼Œä½¿ç”¨ä¸­æ€§ç³»æ•°
            const sizeMultiplier = 1.0;
            const areaMultiplier = 1.0;
            const outdoorTiles = Math.floor(size * size * ratio * sizeMultiplier * areaMultiplier);
            
            // è·å–å®é™…çš„åœ°å›¾å°ºå¯¸
            const actualSizeY = mapFloors[0] ? mapFloors[0].length : size;
            const actualSizeX = mapFloors[0] && mapFloors[0][0] ? mapFloors[0][0].length : size;
            
            switch(layout) {
                case 'outdoor':
                    // å…¨å¤–åœº
                    for (let y = 0; y < actualSizeY; y++) {
                        for (let x = 0; x < actualSizeX; x++) {
                            setTile(x, y, TileType.OUTDOOR, 0);
                        }
                    }
                    break;
                    
                case 'central_outdoor':
                    // ä¸­å¤®å¤–åœºï¼ˆè§„åˆ™çŸ©å½¢ï¼‰
                    const centerX = Math.floor(actualSizeX / 2);
                    const centerY = Math.floor(actualSizeY / 2);
                    const areaWidth = Math.floor(actualSizeX * Math.sqrt(ratio));
                    const areaHeight = Math.floor(actualSizeY * Math.sqrt(ratio));
                    
                    const startX = Math.max(0, centerX - Math.floor(areaWidth / 2));
                    const endX = Math.min(actualSizeX - 1, centerX + Math.floor(areaWidth / 2));
                    const startY = Math.max(0, centerY - Math.floor(areaHeight / 2));
                    const endY = Math.min(actualSizeY - 1, centerY + Math.floor(areaHeight / 2));
                    
                    for (let y = startY; y <= endY; y++) {
                        for (let x = startX; x <= endX; x++) {
                            setTile(x, y, TileType.OUTDOOR, 0);
                        }
                    }
                    break;
                    
                case 'peripheral_outdoor':
                    // è¾¹ç¼˜å¤–åœºï¼ˆè§„åˆ™è¾¹æ¡†ï¼‰
                    const marginX = Math.floor((1 - Math.sqrt(1 - ratio)) * actualSizeX / 2);
                    const marginY = Math.floor((1 - Math.sqrt(1 - ratio)) * actualSizeY / 2);
                    
                    for (let y = 0; y < actualSizeY; y++) {
                        for (let x = 0; x < actualSizeX; x++) {
                            if (x < marginX || x >= actualSizeX - marginX || 
                                y < marginY || y >= actualSizeY - marginY) {
                                setTile(x, y, TileType.OUTDOOR, 0);
                            }
                        }
                    }
                    break;
                    
                case 'mixed':
                default:
                    // æ··åˆåœºåœ°ï¼ˆè§„åˆ™çŸ©å½¢åŒºåŸŸï¼‰
                    const numOutdoorAreas = 2 + Math.floor(Math.random() * 2); // 2-3ä¸ªåŒºåŸŸ
                    const areaSize = Math.floor(Math.sqrt(outdoorTiles / numOutdoorAreas));
                    
                    for (let i = 0; i < numOutdoorAreas; i++) {
                        // ç¡®ä¿åŒºåŸŸä¸é‡å 
                        let attempts = 0;
                        let placed = false;
                        
                        // é™åˆ¶åŒºåŸŸå¤§å°ï¼Œé¿å…è¶…å‡ºè¾¹ç•Œ
                        const maxAreaSize = Math.min(areaSize, Math.floor(Math.min(actualSizeX, actualSizeY) / 4));
                        
                        while (!placed && attempts < 50) {
                            const cx = Math.floor(Math.random() * (actualSizeX - maxAreaSize * 2)) + maxAreaSize;
                            const cy = Math.floor(Math.random() * (actualSizeY - maxAreaSize * 2)) + maxAreaSize;
                        
                            // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰å¤–åœºåŒºåŸŸé‡å 
                            let overlaps = false;
                            for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                    if (isValidPosition(x, y, 0)) {
                                        if (getTile(x, y, 0) === TileType.OUTDOOR) {
                                            overlaps = true;
                                            break;
                                        }
                                    }
                                }
                                if (overlaps) break;
                            }
                            
                            if (!overlaps) {
                                // åˆ›å»ºè§„åˆ™çŸ©å½¢å¤–åœºåŒºåŸŸ
                                for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                    for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                        setTile(x, y, TileType.OUTDOOR, 0);
                                    }
                                }
                                placed = true;
                            }
                            attempts++;
                        }
                        
                        // å¦‚æœæ— æ³•æ”¾ç½®ï¼Œåœ¨è§’è½åˆ›å»ºå°åŒºåŸŸ
                        if (!placed) {
                            const cornerSize = Math.min(maxAreaSize, 10); // é™åˆ¶è§’è½åŒºåŸŸå¤§å°
                            const cornerX = (i % 2 === 0) ? cornerSize : actualSizeX - cornerSize - 1;
                            const cornerY = (i < 2) ? cornerSize : actualSizeY - cornerSize - 1;
                            
                            for (let y = cornerY - cornerSize; y <= cornerY + cornerSize; y++) {
                                for (let x = cornerX - cornerSize; x <= cornerX + cornerSize; x++) {
                                    setTile(x, y, TileType.OUTDOOR, 0);
                                }
                            }
                        }
                    }
                    break;
            }
            
            // åœ¨å¤–åœºæ·»åŠ ä¸€äº›æ©ä½“å’Œç‰¹å¾
            addOutdoorFeatures(size);
            
            // å¯é€‰ï¼šå¤–åœºå›´å¢™ï¼Œå°†å¤–åœºè¾¹ç¼˜åŒ…å›´ä¸ºå¢™
            const withOutdoorWall = document.getElementById('outdoorWall') && document.getElementById('outdoorWall').checked;
            if (withOutdoorWall) {
                addOutdoorWalls();
            }
        }

        // ä¸ºæ‰€æœ‰å¤–åœºåŒºåŸŸçš„è¾¹ç¼˜æ·»åŠ å¢™ä½“
        function addOutdoorWalls() {
            if (!mapFloors || !mapFloors[0]) return;
            const height = mapFloors[0].length;
            const width = mapFloors[0][0].length;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (getTile(x, y, 0) === TileType.OUTDOOR) {
                        const neighbors = [
                            [x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]
                        ];
                        for (const [nx, ny] of neighbors) {
                            if (isValidPosition(nx, ny, 0)) {
                                const t = getTile(nx, ny, 0);
                                if (t !== TileType.OUTDOOR && t !== TileType.WALL) {
                                    setTile(nx, ny, TileType.WALL, 0);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // ç”Ÿæˆå¤§å…
        function generateLobby(size, floor) {
            const lobbyType = document.getElementById('generateLobby').value;
            
            if (lobbyType === 'none') return;
            
            let lobbyWidth, lobbyHeight, lobbyX, lobbyY;
            
            switch(lobbyType) {
                case 'small':
                    lobbyWidth = 8;
                    lobbyHeight = 6;
                    break;
                case 'medium':
                    lobbyWidth = 12;
                    lobbyHeight = 8;
                    break;
                case 'large':
                    lobbyWidth = 16;
                    lobbyHeight = 10;
                    break;
                case 'central':
                    lobbyWidth = 14;
                    lobbyHeight = 12;
                    break;
                case 'circle':
                    lobbyWidth = 12;
                    lobbyHeight = 12;
                    break;
                case 'cross':
                    lobbyWidth = 15;
                    lobbyHeight = 15;
                    break;
                case 'square':
                    lobbyWidth = 14;
                    lobbyHeight = 14;
                    break;
                default:
                    return;
            }
            
            // ç¡®å®šå¤§å…ä½ç½®
            if (lobbyType === 'central') {
                // ä¸­å¤®å¤§å…
                lobbyX = Math.floor((size - lobbyWidth) / 2);
                lobbyY = Math.floor((size - lobbyHeight) / 2);
            } else {
                // éšæœºä½ç½®ï¼Œä½†é¿å…ä¸å¤–åœºé‡å 
                let attempts = 0;
                do {
                    lobbyX = Math.floor(Math.random() * (size - lobbyWidth - 4)) + 2;
                    lobbyY = Math.floor(Math.random() * (size - lobbyHeight - 4)) + 2;
                    attempts++;
                } while (hasOutdoorOverlap(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) && attempts < 50);
                
                if (attempts >= 50) return; // å¦‚æœæ‰¾ä¸åˆ°åˆé€‚ä½ç½®ï¼Œè·³è¿‡
            }
            
            // ç¡®ä¿å¤§å…å®Œå…¨åœ¨åœ°å›¾èŒƒå›´å†…
            if (lobbyX < 0 || lobbyY < 0 || lobbyX + lobbyWidth > size || lobbyY + lobbyHeight > size) {
                return; // å¦‚æœå¤§å…è¶…å‡ºè¾¹ç•Œï¼Œè·³è¿‡
            }
            
            // æ ¹æ®å¤§å…ç±»å‹åˆ›å»ºä¸åŒå½¢çŠ¶
            switch(lobbyType) {
                case 'circle':
                    createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'cross':
                    createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'square':
                    createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                default:
                    createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
            }
            
            // æ·»åŠ å¤§å…å…¥å£
            addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
            
            // è¿æ¥å¤§å…åˆ°å…¶ä»–åŒºåŸŸ
            connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
        }
        
        // åˆ›å»ºçŸ©å½¢å¤§å…
        function createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // å¢™å£
                        setTile(x, y, TileType.WALL, floor);
                    } else {
                        // å¤§å…å†…éƒ¨
                        if (x === Math.floor(lobbyX + lobbyWidth / 2) && 
                            y === Math.floor(lobbyY + lobbyHeight / 2)) {
                            setTile(x, y, TileType.LOBBY_CENTER, floor);
                        } else {
                            setTile(x, y, TileType.LOBBY, floor);
                        }
                    }
                }
            }
        }
        
        // åˆ›å»ºåœ†å½¢å¤§å…
        function createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const radius = Math.min(lobbyWidth, lobbyHeight) / 2 - 1;
            
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    
                    if (distance <= radius) {
                        // å¤§å…å†…éƒ¨
                        if (distance <= 1) {
                            setTile(x, y, TileType.LOBBY_CENTER, floor);
                        } else {
                            setTile(x, y, TileType.LOBBY, floor);
                        }
                    } else if (distance <= radius + 1) {
                        // å¢™å£
                        setTile(x, y, TileType.WALL, floor);
                    }
                }
            }
        }
        
        // åˆ›å»ºåå­—å¤§å…
        function createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const armWidth = 3;
            const armLength = Math.min(lobbyWidth, lobbyHeight) / 2 - 2;
            
            // æ¸…ç©ºåŒºåŸŸ
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    setTile(x, y, TileType.VOID, floor);
                }
            }
            
            // åˆ›å»ºåå­—å½¢çŠ¶
            // æ°´å¹³è‡‚
            for (let y = centerY - armWidth; y <= centerY + armWidth; y++) {
                for (let x = centerX - armLength; x <= centerX + armLength; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (x === centerX - armLength || x === centerX + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // å‚ç›´è‡‚
            for (let y = centerY - armLength; y <= centerY + armLength; y++) {
                for (let x = centerX - armWidth; x <= centerX + armWidth; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (y === centerY - armLength || y === centerY + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // ä¸­å¿ƒç‚¹
            mapFloors[floor][centerY][centerX] = TileType.LOBBY_CENTER;
            
            // æ·»åŠ å¤–éƒ¨å¢™å£
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (getTile(x, y, floor) === TileType.VOID) {
                        // æ£€æŸ¥æ˜¯å¦ä¸å¤§å…å†…éƒ¨ç›¸é‚»
                        let adjacentToLobby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= lobbyX && nx < lobbyX + lobbyWidth && 
                                    ny >= lobbyY && ny < lobbyY + lobbyHeight) {
                                    if (getTile(nx, ny, floor) === TileType.LOBBY || 
                                        getTile(nx, ny, floor) === TileType.LOBBY_CENTER) {
                                        adjacentToLobby = true;
                                        break;
                                    }
                                }
                            }
                            if (adjacentToLobby) break;
                        }
                        if (adjacentToLobby) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        }
                    }
                }
            }
        }
        
        // åˆ›å»ºæ–¹å½¢å¤§å…
        function createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const innerSize = Math.min(lobbyWidth, lobbyHeight) - 4;
            
            // åˆ›å»ºå¤–éƒ¨æ–¹å½¢
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // å¤–éƒ¨å¢™å£
                        mapFloors[floor][y][x] = TileType.WALL;
                    } else {
                        // å†…éƒ¨åŒºåŸŸ
                        const innerX = Math.floor((lobbyWidth - innerSize) / 2);
                        const innerY = Math.floor((lobbyHeight - innerSize) / 2);
                        
                        if (x >= lobbyX + innerX && x < lobbyX + innerX + innerSize &&
                            y >= lobbyY + innerY && y < lobbyY + innerY + innerSize) {
                            // å†…éƒ¨æ–¹å½¢
                            if (x === lobbyX + innerX || x === lobbyX + innerX + innerSize - 1 ||
                                y === lobbyY + innerY || y === lobbyY + innerY + innerSize - 1) {
                                // å†…éƒ¨å¢™å£
                                mapFloors[floor][y][x] = TileType.WALL;
                            } else {
                                // å†…éƒ¨ç©ºé—´
                                if (x === centerX && y === centerY) {
                                    mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                                } else {
                                    mapFloors[floor][y][x] = TileType.LOBBY;
                                }
                            }
                        } else {
                            // ä¸­é—´åŒºåŸŸï¼ˆèµ°å»Šï¼‰
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸å¤–åœºé‡å 
        function hasOutdoorOverlap(x, y, width, height, floor) {
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length &&
                        mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                        if (mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // æ·»åŠ å¤§å…å…¥å£
        function addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const entranceCount = 2 + Math.floor(Math.random() * 2); // 2-3ä¸ªå…¥å£
            
            for (let i = 0; i < entranceCount; i++) {
                let entranceX, entranceY;
                
                // éšæœºé€‰æ‹©å…¥å£ä½ç½®ï¼ˆå››è¾¹ï¼‰
                const side = Math.floor(Math.random() * 4);
                
                switch(side) {
                    case 0: // ä¸Šè¾¹
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY;
                        break;
                    case 1: // ä¸‹è¾¹
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY + lobbyHeight - 1;
                        break;
                    case 2: // å·¦è¾¹
                        entranceX = lobbyX;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                    case 3: // å³è¾¹
                        entranceX = lobbyX + lobbyWidth - 1;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                }
                
                // åˆ›å»ºå…¥å£
                mapFloors[floor][entranceY][entranceX] = TileType.LOBBY_ENTRANCE;
                
                // åˆ›å»ºå…¥å£é€šé“
                createEntrancePath(entranceX, entranceY, floor);
            }
        }
        
        // åˆ›å»ºå…¥å£é€šé“
        function createEntrancePath(entranceX, entranceY, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const pathLength = 3 + Math.floor(Math.random() * 3); // 3-5æ ¼é•¿
            
            for (let [dx, dy] of directions) {
                let canCreatePath = true;
                
                // æ£€æŸ¥è·¯å¾„æ–¹å‘æ˜¯å¦å¯è¡Œ
                for (let i = 1; i <= pathLength; i++) {
                    const nx = entranceX + dx * i;
                    const ny = entranceY + dy * i;
                    
                    if (nx < 0 || nx >= mapFloors[floor][0].length || 
                        ny < 0 || ny >= mapFloors[floor].length ||
                        !mapFloors[floor][ny] || mapFloors[floor][ny][nx] === undefined) {
                        canCreatePath = false;
                        break;
                    }
                    
                    if (mapFloors[floor][ny][nx] !== TileType.VOID && 
                        mapFloors[floor][ny][nx] !== TileType.OUTDOOR) {
                        canCreatePath = false;
                        break;
                    }
                }
                
                if (canCreatePath) {
                    // åˆ›å»ºé€šé“
                    for (let i = 1; i <= pathLength; i++) {
                        const nx = entranceX + dx * i;
                        const ny = entranceY + dy * i;
                        mapFloors[floor][ny][nx] = TileType.FLOOR;
                    }
                    break; // åªåˆ›å»ºä¸€ä¸ªæ–¹å‘çš„é€šé“
                }
            }
        }
        
        // è¿æ¥å¤§å…åˆ°å…¶ä»–åŒºåŸŸ
        function connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            // æ‰¾åˆ°æœ€è¿‘çš„æˆ¿é—´æˆ–èµ°å»Š
            let nearestArea = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (!mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                        continue;
                    }
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN) {
                        
                        const dist = Math.abs(x - (lobbyX + lobbyWidth/2)) + 
                                   Math.abs(y - (lobbyY + lobbyHeight/2));
                        
                        if (dist < minDist && dist > 5) { // è·ç¦»å¤§äº5æ‰éœ€è¦è¿æ¥
                            minDist = dist;
                            nearestArea = {x, y};
                        }
                    }
                }
            }
            
            // å¦‚æœæ‰¾åˆ°äº†éœ€è¦è¿æ¥çš„åŒºåŸŸï¼Œåˆ›å»ºèµ°å»Š
            if (nearestArea && minDist < 20) {
                const lobbyCenterX = Math.floor(lobbyX + lobbyWidth / 2);
                const lobbyCenterY = Math.floor(lobbyY + lobbyHeight / 2);
                
                createSimpleCorridor(lobbyCenterX, lobbyCenterY, nearestArea.x, nearestArea.y, floor);
            }
        }
        
        // æ£€æŸ¥ä½ç½®æ˜¯å¦é å¢™æˆ–é é—¨
        function isNearWallOrDoor(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const adjacentTile = mapFloors[floor][ny][nx];
                    
                    // æ£€æŸ¥æ˜¯å¦é å¢™
                    if (adjacentTile === TileType.WALL) {
                        return true;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é é—¨ï¼ˆé—¨é€šå¸¸æ˜¯åœ°æ¿ï¼Œä½†è¿æ¥æˆ¿é—´ï¼‰
                    if (adjacentTile === TileType.FLOOR || 
                        adjacentTile === TileType.MEDIUM_GROUND ||
                        adjacentTile === TileType.HIGH_GROUND ||
                        adjacentTile === TileType.LOW_GROUND) {
                        // æ£€æŸ¥è¿™ä¸ªåœ°æ¿æ˜¯å¦è¿æ¥æˆ¿é—´ï¼ˆå³å‘¨å›´æœ‰å¢™å£ï¼‰
                        if (isDoorway(nx, ny, floor)) {
                            return true;
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é çª—æˆ·
                    if (adjacentTile === TileType.WINDOW) {
                        return true;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é å¤§å…å…¥å£
                    if (adjacentTile === TileType.LOBBY_ENTRANCE) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // æ£€æŸ¥ä½ç½®æ˜¯å¦æ˜¯é—¨å£
        function isDoorway(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            let wallCount = 0;
            let voidCount = 0;
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const tile = mapFloors[floor][ny][nx];
                    if (tile === TileType.WALL) {
                        wallCount++;
                    } else if (tile === TileType.VOID) {
                        voidCount++;
                    }
                }
            }
            
            // å¦‚æœå‘¨å›´æœ‰å¢™å£å’Œç©ºåœ°ï¼Œè¯´æ˜è¿™æ˜¯é—¨å£
            return wallCount >= 1 && voidCount >= 1;
        }
        
        // æ·»åŠ å¤–åœºç‰¹å¾
        function addOutdoorFeatures(size) {
            // æ·»åŠ è§„åˆ™çš„å¤–åœºæ©ä½“ï¼ˆé›†è£…ç®±ã€è½¦è¾†ç­‰ï¼‰- åªç”Ÿæˆåœ¨é å¢™ä½ç½®
            const coverCount = Math.floor(size * size * 0.01); // 1%çš„å¯†åº¦
            let placedCount = 0;
            let attempts = 0;
            
            while (placedCount < coverCount && attempts < coverCount * 10) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR && isOutdoorCoverPosition(x, y, size)) {
                    // åˆ›å»ºè§„åˆ™çŸ©å½¢æ©ä½“
                    const coverWidth = 2 + Math.floor(Math.random() * 2); // 2-3æ ¼å®½
                    const coverHeight = 2; // å›ºå®š2æ ¼é«˜
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´
                    let canPlace = true;
                            for (let dy = 0; dy < coverHeight; dy++) {
                                for (let dx = 0; dx < coverWidth; dx++) {
                            if (y + dy >= size - 1 || x + dx >= size - 1) {
                                canPlace = false;
                                break;
                            }
                            if (mapFloors[0][y + dy][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        if (!canPlace) break;
                    }
                    
                    if (canPlace) {
                        for (let dy = 0; dy < coverHeight; dy++) {
                            for (let dx = 0; dx < coverWidth; dx++) {
                                            mapFloors[0][y + dy][x + dx] = TileType.OUTDOOR_COVER;
                                        }
                                    }
                        placedCount++;
                    }
                }
                attempts++;
            }
            
            // åœ¨å¤–åœºè¾¹ç¼˜æ·»åŠ è§„åˆ™å›´å¢™
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // æ£€æŸ¥æ˜¯å¦ä¸å¤–åœºè¾¹ç¼˜ç›¸é‚»
                        let isEdge = false;
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                mapFloors[0][ny][nx] === TileType.VOID) {
                                        isEdge = true;
                                break;
                            }
                        }
                        
                        if (isEdge && Math.random() < 0.9) { // æé«˜å›´å¢™ç”Ÿæˆæ¦‚ç‡
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // ç¡®ä¿å¤–åœºæœ‰å®Œæ•´çš„å›´å¢™è¾¹ç•Œ
            createOutdoorWallBoundary(size);
            
            // æ·»åŠ è§„åˆ™çš„é“è·¯è¿æ¥
            addOutdoorPaths(size);
        }
        
        // æ£€æŸ¥å¤–åœºæ©ä½“ä½ç½®æ˜¯å¦åˆé€‚ï¼ˆé å¢™æˆ–è¾¹ç¼˜ï¼‰
        function isOutdoorCoverPosition(x, y, size) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // æ£€æŸ¥æ˜¯å¦é å¤–åœºè¾¹ç¼˜
                if (nx < 0 || nx >= size || ny < 0 || ny >= size) {
                    return true;
                }
                
                // æ£€æŸ¥è¾¹ç•Œå’Œæ•°ç»„æœ‰æ•ˆæ€§
                if (nx < 0 || nx >= size || ny < 0 || ny >= size ||
                    !mapFloors[0][ny] || mapFloors[0][ny][nx] === undefined) {
                    continue;
                }
                
                // æ£€æŸ¥æ˜¯å¦é å¤–åœºå›´å¢™
                if (mapFloors[0][ny][nx] === TileType.OUTDOOR_WALL) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦é å†…åœºè¾¹ç•Œï¼ˆå¢™å£ï¼‰
                if (mapFloors[0][ny][nx] === TileType.WALL) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦é ç©ºåœ°ï¼ˆå¤–åœºè¾¹ç¼˜ï¼‰
                if (mapFloors[0][ny][nx] === TileType.VOID) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦é é“è·¯ï¼ˆåœ°æ¿ï¼‰
                if (mapFloors[0][ny][nx] === TileType.FLOOR) {
                    return true;
                }
            }
            
            return false;
        }
        
        // åˆ›å»ºå¤–åœºå›´å¢™è¾¹ç•Œ
        function createOutdoorWallBoundary(size) {
            // æ‰«æå¤–åœºåŒºåŸŸï¼Œç¡®ä¿è¾¹ç•Œå®Œæ•´
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        let needsWall = false;
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            // å¦‚æœé‚»æ¥åœ°å›¾è¾¹ç•Œæˆ–ç©ºåœ°ï¼Œéœ€è¦å›´å¢™
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                (mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined &&
                                 mapFloors[0][ny][nx] === TileType.VOID)) {
                                needsWall = true;
                                break;
                            }
                        }
                        
                        // å¦‚æœå½“å‰æ˜¯å¤–åœºä¸”éœ€è¦å›´å¢™ï¼Œä½†è¿˜æ²¡æœ‰å›´å¢™ï¼Œåˆ™æ·»åŠ å›´å¢™
                        if (needsWall && mapFloors[0][y][x] === TileType.OUTDOOR) {
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // æ·»åŠ å¤–åœºå†…éƒ¨çš„å›´å¢™ç»“æ„ï¼ˆå¦‚åˆ†éš”å¢™ï¼‰
            addOutdoorInternalWalls(size);
        }
        
        // æ·»åŠ å¤–åœºå†…éƒ¨å›´å¢™
        function addOutdoorInternalWalls(size) {
            // åœ¨å¤–åœºåŒºåŸŸæ·»åŠ ä¸€äº›å†…éƒ¨å›´å¢™ï¼Œåˆ›é€ æˆ˜æœ¯æ©ä½“
            const wallCount = Math.floor(size * 0.5); // æ ¹æ®åœ°å›¾å¤§å°å†³å®šå›´å¢™æ•°é‡ï¼Œæ”¯æŒæ›´å¤§åœ°å›¾
            
            for (let i = 0; i < wallCount; i++) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // éšæœºé€‰æ‹©å›´å¢™æ–¹å‘ï¼ˆæ°´å¹³æˆ–å‚ç›´ï¼‰
                    const isHorizontal = Math.random() > 0.5;
                    const wallLength = 3 + Math.floor(Math.random() * 4); // 3-6æ ¼é•¿
                    
                    if (isHorizontal) {
                        // åˆ›å»ºæ°´å¹³å›´å¢™
                        let canPlace = true;
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx >= size || 
                                !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                                mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dx = 0; dx < wallLength; dx++) {
                                if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                    mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    } else {
                        // åˆ›å»ºå‚ç›´å›´å¢™
                        let canPlace = true;
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dy = 0; dy < wallLength; dy++) {
                                if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                    mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    }
                }
            }
            
            // æ·»åŠ Lå½¢å›´å¢™ï¼ˆè§’è½æ©ä½“ï¼‰
            addOutdoorCornerWalls(size);
        }
        
        // æ·»åŠ å¤–åœºè§’è½å›´å¢™
        function addOutdoorCornerWalls(size) {
            const cornerCount = Math.floor(size * 0.2); // è§’è½å›´å¢™æ•°é‡ï¼Œæ”¯æŒæ›´å¤§åœ°å›¾
            
            for (let i = 0; i < cornerCount; i++) {
                const x = Math.floor(Math.random() * (size - 6)) + 3;
                const y = Math.floor(Math.random() * (size - 6)) + 3;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´åˆ›å»ºLå½¢å›´å¢™
                    const wallLength = 3;
                    let canPlace = true;
                    
                    // æ£€æŸ¥æ°´å¹³æ®µ
                    for (let dx = 0; dx < wallLength; dx++) {
                        if (x + dx >= size || 
                            !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                            mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    // æ£€æŸ¥å‚ç›´æ®µ
                    if (canPlace) {
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                    }
                    
                    if (canPlace) {
                        // åˆ›å»ºLå½¢å›´å¢™
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                            }
                        }
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // ç”Ÿæˆé«˜ä½å·®åŒºåŸŸ - æ•´æ®µé“è·¯å‡é«˜æˆ–é™ä½
        function generateElevationAreas(size, floor) {
            const elevation = parseInt(document.getElementById('elevation').value);
            if (elevation === 0) return; // æ— é«˜ä½å·®
            
            // æ‰¾åˆ°æ‰€æœ‰è¿ç»­çš„é“è·¯æ®µ
            const roadSegments = findRoadSegments(size, floor);
            
            // æ ¹æ®é«˜ä½å·®è®¾ç½®å†³å®šè¦æ”¹å˜çš„é“è·¯æ®µæ•°é‡
            const elevationIntensity = elevation * 0.4; // 0.4 = 40%çš„é“è·¯æ®µä¼šæœ‰é«˜ä½å·®
            const segmentsToElevate = Math.floor(roadSegments.length * elevationIntensity);
            
            // éšæœºé€‰æ‹©é“è·¯æ®µè¿›è¡Œé«˜ä½å·®å¤„ç†
            const shuffledSegments = [...roadSegments].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < Math.min(segmentsToElevate, shuffledSegments.length); i++) {
                const segment = shuffledSegments[i];
                const isHighGround = Math.random() > 0.5; // 50%æ¦‚ç‡æ˜¯é«˜åœ°ï¼Œ50%æ¦‚ç‡æ˜¯ä½åœ°
                
                // å°†æ•´ä¸ªé“è·¯æ®µæ ‡è®°ä¸ºé«˜åœ°æˆ–ä½åœ°
                for (const point of segment) {
                    if (mapFloors[floor][point.y][point.x] === TileType.FLOOR) {
                        mapFloors[floor][point.y][point.x] = isHighGround ? TileType.HIGH_GROUND : TileType.LOW_GROUND;
                    }
                }
            }
            
            // å°†å‰©ä½™çš„åœ°æ¿å’Œé“è·¯åŒºåŸŸæ ‡è®°ä¸ºä¸­ç­‰åœ°
            markMediumGround(size, floor);
        }
        
        // æ‰¾åˆ°è¿ç»­çš„é“è·¯æ®µ
        function findRoadSegments(size, floor) {
            const visited = Array(size).fill().map(() => Array(size).fill(false));
            const segments = [];
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (!visited[y][x] && 
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        const segment = [];
                        floodFillRoad(x, y, size, floor, visited, segment);
                        
                        // åªä¿ç•™è¶³å¤Ÿå¤§çš„é“è·¯æ®µï¼ˆè‡³å°‘5ä¸ªè¿ç»­ç‚¹ï¼‰
                        if (segment.length >= 5) {
                            segments.push(segment);
                        }
                    }
                }
            }
            
            return segments;
        }
        
        // æ´ªæ°´å¡«å……ç®—æ³•æ‰¾åˆ°è¿ç»­çš„é“è·¯æ®µï¼ˆä½¿ç”¨è¿­ä»£é¿å…æ ˆæº¢å‡ºï¼‰
        function floodFillRoad(startX, startY, size, floor, visited, segment) {
            const stack = [{x: startX, y: startY}];
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                
                // æ£€æŸ¥è¾¹ç•Œå’Œæ¡ä»¶
                if (x < 0 || x >= size || y < 0 || y >= size || 
                    visited[y][x] || 
                    !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined ||
                    mapFloors[floor][y][x] !== TileType.FLOOR) {
                    continue;
                }
                
                visited[y][x] = true;
                segment.push({x, y});
                
                // å‘å››ä¸ªæ–¹å‘æ‰©å±•
                stack.push({x: x + 1, y: y});
                stack.push({x: x - 1, y: y});
                stack.push({x: x, y: y + 1});
                stack.push({x: x, y: y - 1});
            }
        }
        
        // åˆ›å»ºé«˜ä½å·®åŒºåŸŸ
        function createElevationArea(centerX, centerY, size, elevationType, floor) {
            const halfSize = Math.floor(size / 2);
            
            for (let y = centerY - halfSize; y <= centerY + halfSize; y++) {
                for (let x = centerX - halfSize; x <= centerX + halfSize; x++) {
                    if (x >= 0 && x < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length &&
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        
                        // åªå¯¹åœ°é¢å’Œé“è·¯åº”ç”¨é«˜ä½å·®
                        if (mapFloors[floor][y][x] === TileType.FLOOR) {
                            mapFloors[floor][y][x] = elevationType;
                        }
                    }
                }
            }
        }
        
        // æ ‡è®°ä¸­ç­‰åœ°
        function markMediumGround(size, floor) {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // åªå¯¹åœ°é¢å’Œé“è·¯æ ‡è®°ä¸ºä¸­ç­‰åœ°ï¼Œä¿æŒå…¶ä»–å…ƒç´ ä¸å˜
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        mapFloors[floor][y][x] = TileType.MEDIUM_GROUND;
                    }
                }
            }
        }
        
        // æ·»åŠ å¤–åœºé“è·¯
        function addOutdoorPaths(size) {
            // åœ¨å¤–åœºåŒºåŸŸä¹‹é—´åˆ›å»ºè§„åˆ™çš„é“è·¯è¿æ¥
            const pathCount = Math.floor(size / 20) + Math.floor(Math.random() * 5); // æ ¹æ®åœ°å›¾å¤§å°è°ƒæ•´é“è·¯æ•°é‡
            
            for (let i = 0; i < pathCount; i++) {
                // æ‰¾åˆ°ä¸¤ä¸ªå¤–åœºåŒºåŸŸçš„ä¸­å¿ƒç‚¹
                let outdoorAreas = [];
                
                // æ‰«æå¤–åœºåŒºåŸŸ
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                            mapFloors[0][y][x] === TileType.OUTDOOR) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°åŒºåŸŸçš„ä¸­å¿ƒ
                            let isCenter = true;
                            for (let dy = -3; dy <= 3; dy++) {
                                for (let dx = -3; dx <= 3; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < size && nx >= 0 && nx < size &&
                                        mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined) {
                                        if (mapFloors[0][ny][nx] !== TileType.OUTDOOR && 
                                            mapFloors[0][ny][nx] !== TileType.OUTDOOR_COVER) {
                                            isCenter = false;
                                        }
                                    }
                                }
                            }
                            if (isCenter) {
                                outdoorAreas.push({x, y});
                            }
                        }
                    }
                }
                
                // è¿æ¥ä¸åŒçš„å¤–åœºåŒºåŸŸ
                if (outdoorAreas.length >= 2) {
                    const area1 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    let area2;
                    do {
                        area2 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    } while (area2 === area1);
                    
                    // åˆ›å»ºç›´çº¿é“è·¯è¿æ¥
                    createStraightPath(area1.x, area1.y, area2.x, area2.y);
                }
            }
        }
        
        // åˆ›å»ºé“è·¯ï¼ˆç›´çº¿ï¼‰
        function createStraightPath(x1, y1, x2, y2) {
            
            // ç›´çº¿é“è·¯
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // åˆ›å»ºé“è·¯ï¼ˆ2æ ¼å®½ï¼‰
                for (let w = -1; w <= 1; w++) {
                    for (let h = -1; h <= 1; h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[0][0].length && 
                            ny >= 0 && ny < mapFloors[0].length) {
                            if (mapFloors[0][ny][nx] === TileType.OUTDOOR) {
                                mapFloors[0][ny][nx] = TileType.FLOOR; // é“è·¯ä½¿ç”¨åœ°æ¿ç±»å‹
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        

        
        // åœ¨æˆ¿é—´å‘¨å›´æ·»åŠ ç¼“å†²åŒºï¼ˆç¡®ä¿ç‹¬ç«‹æ€§ï¼‰
        function addRoomBuffer(x, y, width, height, floor, size, minSpacing) {
            // åœ¨æˆ¿é—´å‘¨å›´åˆ›å»ºç¼“å†²åŒºï¼Œç¡®ä¿æˆ¿é—´ä¹‹é—´æœ‰è¶³å¤Ÿç©ºé—´
            for (let by = y - minSpacing; by < y + height + minSpacing; by++) {
                for (let bx = x - minSpacing; bx < x + width + minSpacing; bx++) {
                    if (bx >= 0 && bx < size && by >= 0 && by < size) {
                        // å¦‚æœç¼“å†²åŒºä½ç½®æ˜¯ç©ºåœ°ï¼Œä¿æŒä¸ºç©ºåœ°
                        if (mapFloors[floor][by][bx] === TileType.VOID) {
                            // ä¿æŒä¸ºç©ºåœ°ï¼Œä¸æ·»åŠ ä»»ä½•è£…é¥°
                        }
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦é‚»æ¥å¤–åœº
        function isAdjacentToOutdoor(x, y, floor) {
            if (floor !== 0) return false;
            
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                    return true;
                }
            }
            return false;
        }
        
        // è¿æ¥æˆ¿é—´ï¼ˆæ”¹è¿›ç‰ˆï¼šéšæœºèµ°å»Šå®½åº¦ï¼Œç¡®ä¿æ‰€æœ‰æˆ¿é—´è¿é€šï¼‰
        function connectRooms(rooms, floor, baseCorridorWidth) {
            if (rooms.length < 2) return;
            
            const corridorMode = document.getElementById('corridorRandom').value;
            
            // ä½¿ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ç¡®ä¿æ‰€æœ‰æˆ¿é—´è¿é€š
            const connected = new Set([0]); // ä»ç¬¬ä¸€ä¸ªæˆ¿é—´å¼€å§‹
            const unconnected = new Set();
            for (let i = 1; i < rooms.length; i++) {
                unconnected.add(i);
            }
            
            // è¿æ¥æ‰€æœ‰æˆ¿é—´
            while (unconnected.size > 0) {
                let minDist = Infinity;
                let bestConnected = -1;
                let bestUnconnected = -1;
                
                // æ‰¾åˆ°æœ€è¿‘çš„æœªè¿æ¥æˆ¿é—´å¯¹
                for (let c of connected) {
                    for (let u of unconnected) {
                        const room1 = rooms[c];
                        const room2 = rooms[u];
                        const dist = Math.abs(room1.x + room1.width/2 - room2.x - room2.width/2) + 
                                   Math.abs(room1.y + room1.height/2 - room2.y - room2.height/2);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            bestConnected = c;
                            bestUnconnected = u;
                        }
                    }
                }
                
                if (bestConnected !== -1 && bestUnconnected !== -1) {
                    // æ ¹æ®æ¨¡å¼å†³å®šèµ°å»Šå®½åº¦
                    let corridorWidth = baseCorridorWidth;
                    if (corridorMode === 'random') {
                        corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                    } else if (corridorMode === 'varied') {
                        corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                    } else {
                        corridorWidth = baseCorridorWidth + 1;
                    }
                    
                    // åˆ›å»ºèµ°å»Šè¿æ¥ä¸¤ä¸ªæˆ¿é—´
                    createCorridorBetweenRooms(rooms[bestConnected], rooms[bestUnconnected], floor, corridorWidth);
                    
                    // å°†æˆ¿é—´æ ‡è®°ä¸ºå·²è¿æ¥
                    connected.add(bestUnconnected);
                    unconnected.delete(bestUnconnected);
                }
            }
            
            // æ·»åŠ é¢å¤–çš„è¿æ¥å¢åŠ è·¯çº¿å¤šæ ·æ€§ï¼ˆ20%æ¦‚ç‡ï¼Œå‡å°‘è¿‡åº¦è¿æ¥ï¼‰
            for (let i = 0; i < rooms.length; i++) {
                for (let j = i + 1; j < rooms.length; j++) {
                    if (Math.random() < 0.2) {
                        let corridorWidth = baseCorridorWidth;
                        if (corridorMode === 'random') {
                            corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                        } else if (corridorMode === 'varied') {
                            corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                        }
                        createCorridorBetweenRooms(rooms[i], rooms[j], floor, corridorWidth);
                    }
                }
                    }
        
        // æ¸…ç†å­¤ç«‹çš„æˆ¿é—´ï¼ˆç¡®ä¿æ‰€æœ‰æˆ¿é—´éƒ½å¯è¾¾ï¼‰
        function cleanupIsolatedRooms(rooms, floor) {
            // æ£€æŸ¥æ¯ä¸ªæˆ¿é—´æ˜¯å¦éƒ½æœ‰é—¨æˆ–ä¸èµ°å»Šè¿æ¥
            for (let room of rooms) {
                let hasAccess = false;
                
                // æ£€æŸ¥æˆ¿é—´è¾¹ç•Œæ˜¯å¦æœ‰å¼€å£
                const directions = [
                    { x: room.x - 1, y: room.y + Math.floor(room.height / 2) }, // å·¦
                    { x: room.x + room.width, y: room.y + Math.floor(room.height / 2) }, // å³
                    { x: room.x + Math.floor(room.width / 2), y: room.y - 1 }, // ä¸Š
                    { x: room.x + Math.floor(room.width / 2), y: room.y + room.height } // ä¸‹
                ];
                
                for (let dir of directions) {
                    if (dir.x >= 0 && dir.x < mapFloors[floor][0].length && 
                        dir.y >= 0 && dir.y < mapFloors[floor].length) {
                        if (mapFloors[floor][dir.y][dir.x] === TileType.FLOOR) {
                            hasAccess = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰è®¿é—®è·¯å¾„ï¼Œåˆ›å»ºä¸€ä¸ªé—¨
                if (!hasAccess) {
                    createRoomDoor(room, floor);
                }
            }
        }
        
        // ä¸ºæˆ¿é—´åˆ›å»ºé—¨
        function createRoomDoor(room, floor) {
            // éšæœºé€‰æ‹©ä¸€é¢å¢™åˆ›å»ºé—¨
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0 }, // å·¦
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0 }, // å³
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1 }, // ä¸Š
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1 } // ä¸‹
            ];
            
            const side = sides[Math.floor(Math.random() * sides.length)];
            
            // åˆ›å»ºé—¨
            if (side.x >= 0 && side.x < mapFloors[floor][0].length && 
                side.y >= 0 && side.y < mapFloors[floor].length) {
                mapFloors[floor][side.y][side.x] = TileType.FLOOR;
                
                // åˆ›å»ºé—¨å¤–çš„èµ°å»Š
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        mapFloors[floor][corridorY][corridorX] = TileType.FLOOR;
                    }
                    }
                }
            }
            
            // ç¡®ä¿æ¯ä¸ªæˆ¿é—´éƒ½æœ‰é—¨
            ensureRoomDoors(rooms, floor);
            
            // æ·»åŠ èµ°å»Šå¢™å£
            addCorridorWalls(floor);
            
            // æ¸…ç†å­¤ç«‹çš„æˆ¿é—´ï¼ˆç¡®ä¿æ‰€æœ‰æˆ¿é—´éƒ½å¯è¾¾ï¼‰
            cleanupIsolatedRooms(rooms, floor);
        }
        
        // åˆ›å»ºä¸¤ä¸ªæˆ¿é—´ä¹‹é—´çš„èµ°å»Šï¼ˆæ”¯æŒæ›²æŠ˜åº¦å’Œå¼¯æ›²åº¦ï¼‰
        function createCorridorBetweenRooms(room1, room2, floor, width) {
            const x1 = Math.floor(room1.x + room1.width / 2);
            const y1 = Math.floor(room1.y + room1.height / 2);
            const x2 = Math.floor(room2.x + room2.width / 2);
            const y2 = Math.floor(room2.y + room2.height / 2);
            
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            switch(pathComplexity) {
                case 0: // ç›´çº¿
                    createStraightCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 1: // å¾®å¼¯
                    createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 2: // ä¸­ç­‰ï¼ˆLå½¢ï¼‰
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 3: // æ›²æŠ˜
                    createZigzagCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 4: // è¿·å®«
                    createMazeLikeCorridor(x1, y1, x2, y2, floor, width);
                    break;
                default:
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
            }
        }
        
        // ç›´çº¿èµ°å»Šï¼ˆæœ€çŸ­è·¯å¾„ï¼‰
        function createStraightCorridor(x1, y1, x2, y2, floor, width) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // ç»˜åˆ¶å®½åº¦çš„èµ°å»Š
                for (let w = -Math.floor(width/2); w <= Math.floor(width/2); w++) {
                    for (let h = -Math.floor(width/2); h <= Math.floor(width/2); h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[floor][0].length && 
                            ny >= 0 && ny < mapFloors[floor].length) {
                            if (mapFloors[floor][ny][nx] === TileType.VOID || 
                                mapFloors[floor][ny][nx] === TileType.WALL) {
                                mapFloors[floor][ny][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        
        // å¾®å¼¯èµ°å»Šï¼ˆå¸¦å°å¼§åº¦ï¼‰
        function createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width) {
            
            const midX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 6) - 3;
            const midY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 6) - 3;
            
            createStraightCorridor(x1, y1, midX, midY, floor, width);
            createStraightCorridor(midX, midY, x2, y2, floor, width);
        }
        
        // Lå½¢èµ°å»Šï¼ˆç»å…¸90åº¦è½¬å¼¯ï¼‰
        function createLShapedCorridor(x1, y1, x2, y2, floor, width) {
            if (Math.random() > 0.5) {
                // å…ˆæ°´å¹³åå‚ç›´
                createHorizontalCorridor(x1, x2, y1, floor, width);
                createVerticalCorridor(x2, y1, y2, floor, width);
            } else {
                // å…ˆå‚ç›´åæ°´å¹³
                createVerticalCorridor(x1, y1, y2, floor, width);
                createHorizontalCorridor(x1, x2, y2, floor, width);
            }
        }
        
        // æ›²æŠ˜èµ°å»Šï¼ˆå¤šä¸ªè½¬å¼¯ï¼‰
        function createZigzagCorridor(x1, y1, x2, y2, floor, width) {
            // æ£€æŸ¥æ›²æŠ˜åº¦è®¾ç½®
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // å¦‚æœæ›²æŠ˜åº¦ä¸º0ï¼ˆç›´çº¿ï¼‰ï¼Œåˆ™ä½¿ç”¨ç›´çº¿èµ°å»Š
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            const points = [];
            points.push({x: x1, y: y1});
            
            // æ·»åŠ 2-3ä¸ªä¸­é—´ç‚¹
            const numPoints = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                // æ·»åŠ éšæœºåç§»ï¼ˆç¡®ä¿åœ¨è¾¹ç•Œå†…ï¼‰
                const offsetX = Math.floor(Math.random() * 10) - 5;
                const offsetY = Math.floor(Math.random() * 10) - 5;
                
                points.push({
                    x: Math.max(1, Math.min(Math.floor(baseX + offsetX), mapWidth - 2)),
                    y: Math.max(1, Math.min(Math.floor(baseY + offsetY), mapHeight - 2))
                });
            }
            
            points.push({x: x2, y: y2});
            
            // è¿æ¥æ‰€æœ‰ç‚¹
            for (let i = 0; i < points.length - 1; i++) {
                if (i % 2 === 0) {
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i].y, floor, width);
                    createVerticalCorridor(points[i+1].x, points[i].y, points[i+1].y, floor, width);
                } else {
                    createVerticalCorridor(points[i].x, points[i].y, points[i+1].y, floor, width);
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i+1].y, floor, width);
                }
            }
        }
        
        // è¿·å®«å¼èµ°å»Šï¼ˆå¤æ‚è·¯å¾„ï¼‰
        function createMazeLikeCorridor(x1, y1, x2, y2, floor, width) {
            // æ£€æŸ¥æ›²æŠ˜åº¦è®¾ç½®
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // å¦‚æœæ›²æŠ˜åº¦ä¸º0ï¼ˆç›´çº¿ï¼‰ï¼Œåˆ™ä½¿ç”¨ç›´çº¿èµ°å»Š
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            x1 = Math.max(1, Math.min(x1, mapWidth - 2));
            y1 = Math.max(1, Math.min(y1, mapHeight - 2));
            x2 = Math.max(1, Math.min(x2, mapWidth - 2));
            y2 = Math.max(1, Math.min(y2, mapHeight - 2));
            
            // åˆ›å»ºä¸»è·¯å¾„
            createZigzagCorridor(x1, y1, x2, y2, floor, width);
            
            // æ·»åŠ 1-2æ¡é¢å¤–è·¯å¾„
            const extraPaths = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < extraPaths; i++) {
                // åˆ›å»ºåç§»èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆç¡®ä¿åœ¨è¾¹ç•Œå†…ï¼‰
                const offsetX1 = Math.max(1, Math.min(x1 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY1 = Math.max(1, Math.min(y1 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                const offsetX2 = Math.max(1, Math.min(x2 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY2 = Math.max(1, Math.min(y2 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                
                // ä½¿ç”¨è¾ƒçª„çš„å®½åº¦
                const narrowWidth = Math.max(1, width - 1);
                
                // éšæœºé€‰æ‹©è·¯å¾„ç±»å‹
                if (Math.random() > 0.5) {
                    createLShapedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                } else {
                    createSlightlyCurvedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                }
            }
            
            // æ·»åŠ ä¸€äº›è¿æ¥æ¨ªé“
            const crossPaths = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < crossPaths; i++) {
                const crossX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossLength = 5 + Math.floor(Math.random() * 10);
                
                if (Math.random() > 0.5) {
                    // æ°´å¹³æ¨ªé“
                    const startX = Math.max(0, crossX - Math.floor(crossLength/2));
                    const endX = Math.min(mapWidth - 1, crossX + Math.floor(crossLength/2));
                    
                    if (crossY >= 0 && crossY < mapHeight) {
                        for (let x = startX; x <= endX; x++) {
                            if (mapFloors[floor][crossY][x] === TileType.VOID) {
                                mapFloors[floor][crossY][x] = TileType.FLOOR;
                            }
                        }
                    }
                } else {
                    // å‚ç›´æ¨ªé“
                    const startY = Math.max(0, crossY - Math.floor(crossLength/2));
                    const endY = Math.min(mapHeight - 1, crossY + Math.floor(crossLength/2));
                    
                    if (crossX >= 0 && crossX < mapWidth) {
                        for (let y = startY; y <= endY; y++) {
                            if (mapFloors[floor][y][crossX] === TileType.VOID) {
                                mapFloors[floor][y][crossX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        

        
        // åˆ›å»ºæ°´å¹³èµ°å»Š
        function createHorizontalCorridor(x1, x2, y, floor, width) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const halfWidth = Math.floor(width / 2);
            
            for (let x = minX; x <= maxX; x++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const ny = y + w;
                    if (ny >= 0 && ny < mapFloors[floor].length && 
                        x >= 0 && x < mapFloors[floor][0].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                            if (mapFloors[floor][ny][x] === TileType.VOID || 
                                mapFloors[floor][ny][x] === TileType.WALL) {
                                mapFloors[floor][ny][x] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // åˆ›å»ºå‚ç›´èµ°å»Š
        function createVerticalCorridor(x, y1, y2, floor, width) {
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            const halfWidth = Math.floor(width / 2);
            
            for (let y = minY; y <= maxY; y++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const nx = x + w;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length) {
                        if (mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                            if (mapFloors[floor][y][nx] === TileType.VOID || 
                                mapFloors[floor][y][nx] === TileType.WALL) {
                                mapFloors[floor][y][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // ç¡®ä¿æ¯ä¸ªæˆ¿é—´éƒ½æœ‰è‡³å°‘ä¸€ä¸ªé—¨
        function ensureRoomDoors(rooms, floor) {
            for (let room of rooms) {
                let hasDoor = false;
                
                // æ£€æŸ¥æˆ¿é—´è¾¹ç•Œæ˜¯å¦æœ‰å¼€å£
                // ä¸Šè¾¹
                for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                    if (mapFloors[floor][room.y][x] === TileType.FLOOR) {
                        hasDoor = true;
                        break;
                    }
                }
                
                // ä¸‹è¾¹
                if (!hasDoor) {
                    for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                        if (mapFloors[floor][room.y + room.height - 1][x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // å·¦è¾¹
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // å³è¾¹
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x + room.width - 1] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰é—¨ï¼Œåˆ›å»ºä¸€ä¸ª
                if (!hasDoor) {
                    // éšæœºé€‰æ‹©ä¸€é¢å¢™åˆ›å»ºé—¨
                    const side = Math.floor(Math.random() * 4);
                    const doorWidth = 2; // é—¨çš„å®½åº¦
                    
                    switch(side) {
                        case 0: // ä¸Š
                            const topX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (topX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y][topX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 1: // ä¸‹
                            const bottomX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (bottomX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y + room.height - 1][bottomX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 2: // å·¦
                            const leftY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (leftY + i < room.y + room.height - 1) {
                                    mapFloors[floor][leftY + i][room.x] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 3: // å³
                            const rightY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (rightY + i < room.y + room.height - 1) {
                                    mapFloors[floor][rightY + i][room.x + room.width - 1] = TileType.FLOOR;
                                }
                            }
                            break;
                    }
                }
            }
        }
        
        // æ·»åŠ èµ°å»Šå¢™å£
        function addCorridorWalls(floor) {
            const tempMap = JSON.parse(JSON.stringify(mapFloors[floor]));
            
            for (let y = 1; y < mapFloors[floor].length - 1; y++) {
                for (let x = 1; x < mapFloors[floor][0].length - 1; x++) {
                    if (tempMap[y][x] === TileType.FLOOR || 
                        tempMap[y][x] === TileType.MEDIUM_GROUND ||
                        tempMap[y][x] === TileType.HIGH_GROUND ||
                        tempMap[y][x] === TileType.LOW_GROUND ||
                        tempMap[y][x] === TileType.T_SPAWN ||
                        tempMap[y][x] === TileType.CT_SPAWN ||
                        tempMap[y][x] === TileType.BOMBSITE_A ||
                        tempMap[y][x] === TileType.BOMBSITE_B) {
                        
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘
                        const directions = [[-1, 0], [0, -1], [0, 1], [1, 0]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < mapFloors[floor].length && 
                                nx >= 0 && nx < mapFloors[floor][0].length) {
                                if (tempMap[ny][nx] === TileType.VOID && 
                                    mapFloors[floor][ny][nx] === TileType.VOID) {
                                    mapFloors[floor][ny][nx] = TileType.WALL;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // æ·»åŠ æ¥¼æ¢¯ï¼ˆæ”¹è¿›ç‰ˆï¼šç¡®ä¿ä¸é“è·¯è¿æ¥ï¼‰
        function addStairs(rooms, stairsCount) {
            if (totalFloors <= 1 || stairsCount === 0) return;
            
            // ä¸ºæ¯å¯¹ç›¸é‚»æ¥¼å±‚åˆ›å»ºæ¥¼æ¢¯
            for (let floor = 0; floor < totalFloors - 1; floor++) {
                let stairsPlaced = 0;
                
                // æ”¶é›†æ‰€æœ‰é“è·¯ä½ç½®
                const roadPositions = [];
                for (let y = 0; y < mapFloors[floor].length; y++) {
                    for (let x = 0; x < mapFloors[floor][0].length; x++) {
                        if (mapFloors[floor][y][x] === TileType.FLOOR ||
                            mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][x] === TileType.LOW_GROUND) {
                            roadPositions.push({ x, y });
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰é“è·¯ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
                if (roadPositions.length === 0) {
                    roadPositions.push(
                        { x: Math.floor(mapFloors[0][0].length / 2), y: Math.floor(mapFloors[0].length / 2) }
                    );
                }
                
                // æ‰“ä¹±é“è·¯ä½ç½®é¡ºåº
                roadPositions.sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < Math.min(stairsCount, roadPositions.length); i++) {
                    const roadPos = roadPositions[i];
                    
                    // åœ¨é“è·¯é™„è¿‘å¯»æ‰¾åˆé€‚çš„ä½ç½®
                    let found = false;
                    for (let dy = -3; dy <= 3 && !found; dy++) {
                        for (let dx = -3; dx <= 3 && !found; dx++) {
                            const x = roadPos.x + dx;
                            const y = roadPos.y + dy;
                            
                            // æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆ2x2åŒºåŸŸï¼‰
                            if (x >= 1 && x < mapFloors[0][0].length - 2 &&
                                y >= 1 && y < mapFloors[0].length - 2) {
                                
                                // æ£€æŸ¥å½“å‰å±‚æ˜¯å¦å¯ä»¥æ”¾ç½®æ¥¼æ¢¯
                                let canPlaceLower = true;
                                let canPlaceUpper = true;
                                
                                for (let sy = 0; sy < 2; sy++) {
                                    for (let sx = 0; sx < 2; sx++) {
                                        // æ£€æŸ¥ä¸‹å±‚
                                        if (mapFloors[floor][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceLower = false;
                                        }
                                        // æ£€æŸ¥ä¸Šå±‚
                                        if (mapFloors[floor + 1][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceUpper = false;
                                        }
                                    }
                                }
                                
                                // æ£€æŸ¥æ˜¯å¦ä¸é“è·¯ç›¸é‚»
                                let hasRoadAdjacent = false;
                                for (let sy = -1; sy <= 2; sy++) {
                                    for (let sx = -1; sx <= 2; sx++) {
                                        const nx = x + sx;
                                        const ny = y + sy;
                                        if (nx >= 0 && nx < mapFloors[floor][0].length &&
                                            ny >= 0 && ny < mapFloors[floor].length) {
                                            if (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                                mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.LOW_GROUND) {
                                                hasRoadAdjacent = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (hasRoadAdjacent) break;
                                }
                                
                                if ((canPlaceLower || canPlaceUpper) && hasRoadAdjacent) {
                                    // åœ¨ä¸‹å±‚åˆ›å»ºå‘ä¸Šçš„æ¥¼æ¢¯
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // å¦‚æœæ˜¯ç©ºåœ°ï¼Œå…ˆåˆ›å»ºåœ°æ¿
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // ç„¶åè®¾ç½®ä¸ºæ¥¼æ¢¯ï¼ˆæ”¯æŒæ‰€æœ‰åœ°é¢ç±»å‹ï¼‰
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.FLOOR ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.LOW_GROUND) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.STAIRS_UP;
                                            }
                                        }
                                    }
                                    
                                    // åœ¨ä¸Šå±‚çš„ç›¸åŒä½ç½®åˆ›å»ºå‘ä¸‹çš„æ¥¼æ¢¯
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // å¦‚æœæ˜¯ç©ºåœ°ï¼Œå…ˆåˆ›å»ºåœ°æ¿
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // ç„¶åè®¾ç½®ä¸ºæ¥¼æ¢¯
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.FLOOR) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.STAIRS_DOWN;
                                            }
                                        }
                                    }
                                    
                                    // ç¡®ä¿æ¥¼æ¢¯å‘¨å›´æœ‰å¢™å£
                                    ensureStairWalls(x, y, floor);
                                    ensureStairWalls(x, y, floor + 1);
                                    
                                    stairsPlaced++;
                                    found = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // ç¡®ä¿æ¥¼æ¢¯å‘¨å›´æœ‰é€‚å½“çš„å¢™å£
        function ensureStairWalls(x, y, floor) {
            // æ£€æŸ¥æ¥¼æ¢¯å‘¨å›´3x3åŒºåŸŸ
            for (let dy = -1; dy <= 2; dy++) {
                for (let dx = -1; dx <= 2; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // è·³è¿‡æ¥¼æ¢¯æœ¬èº«ï¼ˆ2x2ä¸­å¿ƒåŒºåŸŸï¼‰
                    if (dx >= 0 && dx <= 1 && dy >= 0 && dy <= 1) {
                        continue;
                    }
                    
                    // å¦‚æœæ˜¯è¾¹ç•Œä½ç½®ä¸”æ˜¯ç©ºåœ°ï¼Œæ·»åŠ å¢™å£
                    if (nx >= 0 && nx < mapFloors[floor][0].length &&
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny][nx] === TileType.VOID) {
                            // æ£€æŸ¥æ˜¯å¦ä¸é“è·¯ç›¸é‚»ï¼Œå¦‚æœæ˜¯åˆ™ä¸æ·»åŠ å¢™å£
                            let hasRoadAdjacent = false;
                            for (let sy = -1; sy <= 1; sy++) {
                                for (let sx = -1; sx <= 1; sx++) {
                                    const checkX = nx + sx;
                                    const checkY = ny + sy;
                                    if (checkX >= 0 && checkX < mapFloors[floor][0].length &&
                                        checkY >= 0 && checkY < mapFloors[floor].length) {
                                        if (mapFloors[floor][checkY][checkX] === TileType.FLOOR ||
                                            mapFloors[floor][checkY][checkX] === TileType.MEDIUM_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.HIGH_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.LOW_GROUND) {
                                            hasRoadAdjacent = true;
                                            break;
                                        }
                                    }
                                }
                                if (hasRoadAdjacent) break;
                            }
                            
                            // åªåœ¨æ²¡æœ‰é“è·¯ç›¸é‚»çš„è¾¹ç¼˜æ·»åŠ å¢™å£
                            if (!hasRoadAdjacent && (Math.abs(dx) === 1 || Math.abs(dy) === 1)) {
                                mapFloors[floor][ny][nx] = TileType.WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // è¿æ¥æ¥¼æ¢¯åˆ°æœ€è¿‘çš„æˆ¿é—´æˆ–èµ°å»Š
        function connectStairToRooms(stairX, stairY, floor) {
            // æŸ¥æ‰¾æœ€è¿‘çš„åœ°æ¿åŒºåŸŸ
            let nearestFloor = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_A ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_B) {
                        
                        const dist = Math.abs(x - stairX) + Math.abs(y - stairY);
                        if (dist < minDist && dist > 3) { // è·ç¦»å¤§äº3æ‰éœ€è¦è¿æ¥
                            minDist = dist;
                            nearestFloor = { x, y };
                        }
                    }
                }
            }
            
            // å¦‚æœæ‰¾åˆ°äº†éœ€è¦è¿æ¥çš„åœ°æ¿ï¼Œåˆ›å»ºèµ°å»Š
            if (nearestFloor && minDist < 15) {
                createSimpleCorridor(stairX + 1, stairY + 1, nearestFloor.x, nearestFloor.y, floor);
            }
        }
        
        // åˆ›å»ºç®€å•èµ°å»Šè¿æ¥ä¸¤ç‚¹
        function createSimpleCorridor(x1, y1, x2, y2, floor) {
            // å…ˆæ°´å¹³åå‚ç›´
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            
            // æ°´å¹³æ®µ
            for (let x = minX; x <= maxX; x++) {
                if (mapFloors[floor][y1][x] === TileType.VOID) {
                    mapFloors[floor][y1][x] = TileType.FLOOR;
                }
                // æ·»åŠ å¢™å£
                if (y1 > 0 && mapFloors[floor][y1 - 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 - 1][x] = TileType.WALL;
                }
                if (y1 < mapFloors[floor].length - 1 && mapFloors[floor][y1 + 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 + 1][x] = TileType.WALL;
                }
            }
            
            // å‚ç›´æ®µ
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            for (let y = minY; y <= maxY; y++) {
                if (mapFloors[floor][y][x2] === TileType.VOID) {
                    mapFloors[floor][y][x2] = TileType.FLOOR;
                }
                // æ·»åŠ å¢™å£
                if (x2 > 0 && mapFloors[floor][y][x2 - 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 - 1] = TileType.WALL;
                }
                if (x2 < mapFloors[floor][0].length - 1 && mapFloors[floor][y][x2 + 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 + 1] = TileType.WALL;
                }
            }
        }
        
        // æ·»åŠ ç‰¹æ®Šå…ƒç´ 
        function addSpecialElements(rooms, coverDensity, waterAmount, windowDensity) {
            // è®¾ç½®å‡ºç”Ÿç‚¹å’ŒåŒ…ç‚¹
            if (rooms.length >= 3) {
                const firstFloorRooms = rooms.filter(r => r.floor === 0);
                if (firstFloorRooms.length >= 3) {
                    // Tå‡ºç”Ÿç‚¹
                    const tRoom = firstFloorRooms[0];
                    for (let y = tRoom.y + 1; y < tRoom.y + tRoom.height - 1; y++) {
                        for (let x = tRoom.x + 1; x < tRoom.x + tRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.T_SPAWN;
                            }
                        }
                    }
                    
                    // CTå‡ºç”Ÿç‚¹
                    const ctRoom = firstFloorRooms[firstFloorRooms.length - 1];
                    for (let y = ctRoom.y + 1; y < ctRoom.y + ctRoom.height - 1; y++) {
                        for (let x = ctRoom.x + 1; x < ctRoom.x + ctRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.CT_SPAWN;
                            }
                        }
                    }
                    
                    // ç”ŸæˆåŒ…ç‚¹
                    const bombSiteCount = parseInt(document.getElementById('bombSiteCount').value);
                    const availableRooms = firstFloorRooms.slice(2); // è·³è¿‡å‡ºç”Ÿç‚¹æˆ¿é—´
                    
                    // ç¡®ä¿æœ‰è¶³å¤Ÿçš„æˆ¿é—´
                    const maxBombSites = Math.min(bombSiteCount, availableRooms.length);
                    
                    for (let i = 0; i < maxBombSites; i++) {
                        const roomIndex = Math.floor((i + 1) * availableRooms.length / (maxBombSites + 1));
                        const bombRoom = availableRooms[roomIndex];
                        
                        if (bombRoom) {
                            const centerX = Math.floor(bombRoom.x + bombRoom.width / 2);
                            const centerY = Math.floor(bombRoom.y + bombRoom.height / 2);
                            
                            // æ ¹æ®åŒ…ç‚¹ç´¢å¼•é€‰æ‹©TileType
                            const bombSiteType = i === 0 ? TileType.BOMBSITE_A : 
                                               i === 1 ? TileType.BOMBSITE_B :
                                               i === 2 ? TileType.BOMBSITE_C :
                                               i === 3 ? TileType.BOMBSITE_D :
                                               TileType.BOMBSITE_E;
                            
                            // åˆ›å»ºåŒ…ç‚¹åŒºåŸŸ
                            for (let y = centerY - 2; y <= centerY + 2; y++) {
                                for (let x = centerX - 2; x <= centerX + 2; x++) {
                                    if (y > bombRoom.y && y < bombRoom.y + bombRoom.height - 1 &&
                                        x > bombRoom.x && x < bombRoom.x + bombRoom.width - 1) {
                                        if (mapFloors[0][y][x] === TileType.FLOOR || 
                                            mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                                            mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                                            mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                            mapFloors[0][y][x] = bombSiteType;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // æ·»åŠ æ©ä½“ï¼ˆåªç”Ÿæˆåœ¨é å¢™æˆ–é é—¨ä½ç½®ï¼Œæ¯æ®µé“è·¯æœ€å¤š3ä¸ªï¼‰
            for (let floor = 0; floor < totalFloors; floor++) {
                // æ‰¾åˆ°æ‰€æœ‰é“è·¯æ®µ
                const roadSegments = findRoadSegments(mapFloors[floor][0].length, floor);
                
                // ä¸ºæ¯ä¸ªé“è·¯æ®µæ·»åŠ æ©ä½“
                for (const segment of roadSegments) {
                    const maxCoversPerSegment = 3; // æ¯æ®µé“è·¯æœ€å¤š3ä¸ªæ©ä½“
                    const segmentCoverCount = Math.min(
                        Math.floor(segment.length * coverDensity / 1000), 
                        maxCoversPerSegment
                    );
                    
                    let placedCount = 0;
                    let attempts = 0;
                    const maxAttempts = segment.length * 2; // é™åˆ¶å°è¯•æ¬¡æ•°
                    
                    // éšæœºæ‰“ä¹±é“è·¯æ®µä¸­çš„ç‚¹
                    const shuffledPoints = [...segment].sort(() => Math.random() - 0.5);
                    
                    for (const point of shuffledPoints) {
                        if (placedCount >= segmentCoverCount || attempts >= maxAttempts) break;
                        
                        const x = point.x;
                        const y = point.y;
                        
                        if ((mapFloors[floor][y][x] === TileType.FLOOR || 
                             mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                             mapFloors[floor][y][x] === TileType.LOW_GROUND) && 
                            isNearWallOrDoor(x, y, floor)) {
                        mapFloors[floor][y][x] = TileType.COVER;
                            placedCount++;
                        }
                        attempts++;
                    }
                }
            }
            
            // æ·»åŠ æ°´åŸŸï¼ˆåªåœ¨ç¬¬ä¸€å±‚ï¼‰- ä½¿ç”¨æ´ªæ°´å¡«å……åˆ›å»ºè¿ç»­æ°´åŸŸ
            if (waterAmount > 0) {
                createWaterAreas(waterAmount);
            }
            
            // æ·»åŠ é˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
            const shadowPointDensity = parseInt(document.getElementById('shadowPoint').value);
            if (shadowPointDensity > 0) {
                // åœ¨æ‰€æœ‰æ¥¼å±‚æ·»åŠ é˜´ç‚¹
                for (let floor = 0; floor < totalFloors; floor++) {
                    addShadowPoints(shadowPointDensity, floor);
                }
            }
            
            // æ·»åŠ çª—æˆ·
            for (let floor = 0; floor < totalFloors; floor++) {
                const windowCount = Math.floor(mapFloors[floor].length * mapFloors[floor][0].length * windowDensity / 1000);
                for (let i = 0; i < windowCount; i++) {
                    const x = Math.floor(Math.random() * (mapFloors[floor][0].length - 2)) + 1;
                    const y = Math.floor(Math.random() * (mapFloors[floor].length - 2)) + 1;
                    if (mapFloors[floor][y][x] === TileType.WALL) {
                        // æ£€æŸ¥æ˜¯å¦åˆé€‚æ”¾çª—æˆ·
                        let hasFloorNearby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                if (ny >= 0 && ny < mapFloors[floor].length && 
                                    nx >= 0 && nx < mapFloors[floor][0].length &&
                                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                                    (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                     mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                                    hasFloorNearby = true;
                                }
                            }
                        }
                        if (hasFloorNearby) {
                            mapFloors[floor][y][x] = TileType.WINDOW;
                        }
                    }
                }
            }
        }
        
        // æ¸¸æˆæ¨¡å¼é…ç½®
        const gameModes = {
            team: {
                name: "å›¢é˜Ÿç«æŠ€",
                description: "å›¢é˜Ÿç«æŠ€æ¨¡å¼",
                spawnPoints: { t: 2, ct: 2 },
                objectives: ["elimination"],
                features: ["cover", "water", "stairs", "windows"]
            },
            bomb: {
                name: "çˆ†ç ´æ¨¡å¼", 
                description: "çˆ†ç ´æ¨¡å¼",
                spawnPoints: { t: 5, ct: 5 },
                objectives: ["bomb_a", "bomb_b"],
                features: ["cover", "water", "stairs", "windows", "bombsites"]
            },
            zombie: {
                name: "ç”ŸåŒ–æ¨¡å¼",
                description: "ç”ŸåŒ–æ¨¡å¼", 
                spawnPoints: { human: 8, zombie: 2 },
                objectives: ["survival"],
                features: ["cover", "water", "stairs", "windows", "safe_zones"]
            }
        };

        // åœ°å›¾é£æ ¼é…ç½®
        const mapStyles = {
            balanced: {
                name: "å¹³è¡¡å‹",
                description: "å¹³è¡¡å‹åœ°å›¾",
                layout: "balanced",
                coverDensity: 1.0,
                waterAmount: 1.0,
                complexity: 1.0
            },
            ct_sided: {
                name: "CTä¼˜åŠ¿",
                description: "CTä¼˜åŠ¿åœ°å›¾",
                layout: "ct_sided", 
                coverDensity: 0.8,
                waterAmount: 1.2,
                complexity: 1.1
            },
            t_sided: {
                name: "Tä¼˜åŠ¿",
                description: "Tä¼˜åŠ¿åœ°å›¾",
                layout: "t_sided",
                coverDensity: 1.2,
                waterAmount: 0.8,
                complexity: 0.9
            },
            aim_heavy: {
                name: "æªæ³•å‹",
                description: "æªæ³•å‹åœ°å›¾",
                layout: "aim_heavy",
                coverDensity: 0.6,
                waterAmount: 0.5,
                complexity: 0.8
            },
            tactical: {
                name: "æˆ˜æœ¯å‹",
                description: "æˆ˜æœ¯å‹åœ°å›¾",
                layout: "tactical",
                coverDensity: 1.3,
                waterAmount: 1.1,
                complexity: 1.2
            },
            rush: {
                name: "å¿«æ”»å‹",
                description: "å¿«æ”»å‹åœ°å›¾",
                layout: "rush",
                coverDensity: 0.7,
                waterAmount: 0.6,
                complexity: 0.7
            },
            black_town: {
                name: "é»‘è‰²åŸé•‡",
                description: "é»‘è‰²åŸé•‡é£æ ¼",
                layout: "urban",
                coverDensity: 1.1,
                waterAmount: 0.3,
                complexity: 1.0,
                theme: "dark_urban"
            },
            desert_gray: {
                name: "æ²™æ¼ ç°",
                description: "æ²™æ¼ ç°é£æ ¼",
                layout: "desert",
                coverDensity: 0.8,
                waterAmount: 0.1,
                complexity: 0.9,
                theme: "desert"
            },
            new_year_plaza: {
                name: "æ–°å¹´å¹¿åœº",
                description: "æ–°å¹´å¹¿åœºé£æ ¼",
                layout: "plaza",
                coverDensity: 1.0,
                waterAmount: 0.5,
                complexity: 1.1,
                theme: "festival"
            },
            white_house: {
                name: "ç™½æˆ¿",
                description: "ç™½æˆ¿é£æ ¼",
                layout: "mansion",
                coverDensity: 1.2,
                waterAmount: 0.4,
                complexity: 1.3,
                theme: "luxury"
            },
            transport_ship: {
                name: "è¿è¾“èˆ¹",
                description: "è¿è¾“èˆ¹é£æ ¼",
                layout: "ship",
                coverDensity: 0.9,
                waterAmount: 0.8,
                complexity: 1.0,
                theme: "naval"
            },
            satellite_base: {
                name: "å«æ˜ŸåŸºåœ°",
                description: "å«æ˜ŸåŸºåœ°é£æ ¼",
                layout: "military",
                coverDensity: 1.1,
                waterAmount: 0.2,
                complexity: 1.2,
                theme: "military"
            },
            harbor_dock: {
                name: "æ¸¯å£ç å¤´",
                description: "æ¸¯å£ç å¤´é£æ ¼",
                layout: "harbor",
                coverDensity: 1.0,
                waterAmount: 1.5,
                complexity: 1.1,
                theme: "harbor"
            },
            subway_station: {
                name: "åœ°é“ç«™",
                description: "åœ°é“ç«™é£æ ¼",
                layout: "underground",
                coverDensity: 1.3,
                waterAmount: 0.1,
                complexity: 1.4,
                theme: "underground"
            }
        };

        // åº”ç”¨æ¸¸æˆæ¨¡å¼è®¾ç½®
        function applyGameMode(gameMode) {
            const mode = gameModes[gameMode];
            if (!mode) return;
            
            // æ›´æ–°åœ°å›¾æ ‡é¢˜
            document.getElementById('mapName').textContent = mode.name + "åœ°å›¾";
            
            // æ›´æ–°æ¨¡å¼æè¿°
            const modeDescription = document.querySelector('.map-header div:last-child');
            if (modeDescription) {
                modeDescription.textContent = mode.description;
            }
            
            return mode;
        }

        // åº”ç”¨åœ°å›¾é£æ ¼è®¾ç½®
        function applyMapStyle(mapStyle) {
            const style = mapStyles[mapStyle];
            if (!style) return;
            
            // æ ¹æ®é£æ ¼è°ƒæ•´å‚æ•°
            const coverDensitySlider = document.getElementById('coverDensity');
            const waterAmountSlider = document.getElementById('waterAmount');
            const pathComplexitySlider = document.getElementById('pathComplexity');
            
            if (coverDensitySlider && style.coverDensity) {
                const currentValue = parseInt(coverDensitySlider.value);
                const newValue = Math.round(currentValue * style.coverDensity);
                coverDensitySlider.value = Math.min(100, Math.max(10, newValue));
                document.getElementById('coverValue').textContent = coverDensitySlider.value;
            }
            
            if (waterAmountSlider && style.waterAmount) {
                const currentValue = parseInt(waterAmountSlider.value);
                const newValue = Math.round(currentValue * style.waterAmount);
                waterAmountSlider.value = Math.min(50, Math.max(0, newValue));
                document.getElementById('waterValue').textContent = waterAmountSlider.value;
            }
            
            if (pathComplexitySlider && style.complexity) {
                const currentValue = parseInt(pathComplexitySlider.value);
                const newValue = Math.round(currentValue * style.complexity);
                pathComplexitySlider.value = Math.min(4, Math.max(0, newValue));
                document.getElementById('pathValue').textContent = getComplexityText(pathComplexitySlider.value);
            }
            
            return style;
        }

        // è·å–å¤æ‚åº¦æ–‡æœ¬
        function getComplexityText(value) {
            const texts = ['ç®€å•', 'è¾ƒç®€å•', 'ä¸­', 'è¾ƒå¤æ‚', 'å¤æ‚'];
            return texts[value] || 'ä¸­';
        }
        
        // ç”Ÿæˆåœ°å›¾
        function generateMap() {
            try {
                // é˜²é‡å¤ç‚¹å‡»
                const generateBtn = document.getElementById('generateBtn');
                if (generateBtn.disabled) {
                    console.log('åœ°å›¾æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...');
                    return;
                }
                
                console.log('ç”Ÿæˆåœ°å›¾å‡½æ•°è¢«è°ƒç”¨ï¼ŒæŒ‰é’®çŠ¶æ€:', generateBtn.disabled);
                
                // ç¦ç”¨æŒ‰é’®å¹¶æ˜¾ç¤ºç”ŸæˆçŠ¶æ€
                generateBtn.disabled = true;
                generateBtn.textContent = 'ç”Ÿæˆä¸­...';
                
                console.log('å¼€å§‹ç”Ÿæˆåœ°å›¾...');
                
                // è·å–åœ°å›¾å‚æ•°
                const sizeX = parseInt(document.getElementById('mapSizeX').value);
                const sizeY = parseInt(document.getElementById('mapSizeY').value);
                const isLargeMap = (sizeX >= 400 || sizeY >= 400) || (sizeX * sizeY >= 120000);
                
                // å¯¹äºå¤§åœ°å›¾ä½¿ç”¨å¼‚æ­¥å¤„ç†
                if (isLargeMap) {
                    console.log(`æ£€æµ‹åˆ°å¤§åœ°å›¾ ${sizeX}x${sizeY}ï¼Œä½¿ç”¨å¼‚æ­¥ç”Ÿæˆ...`);
                    setTimeout(() => {
                        try {
                            generateMapInternal();
                        } catch (error) {
                            console.error('å¼‚æ­¥åœ°å›¾ç”Ÿæˆå¤±è´¥:', error);
                            alert('åœ°å›¾ç”Ÿæˆå¤±è´¥: ' + error.message + '\nè¯·å°è¯•è°ƒæ•´å‚æ•°åé‡æ–°ç”Ÿæˆã€‚');
                        } finally {
                            // æ¢å¤æŒ‰é’®çŠ¶æ€
                            const generateBtn = document.getElementById('generateBtn');
                            generateBtn.disabled = false;
                            generateBtn.textContent = 'ç”Ÿæˆåœ°å›¾';
                        }
                    }, 50);
                    return;
                }
                
                generateMapInternal();
                
        function generateMapInternal() {
                // è·å–æ¸¸æˆæ¨¡å¼å’Œåœ°å›¾é£æ ¼
                const gameMode = document.getElementById('gameMode').value;
                const mapStyle = document.getElementById('mapStyle').value;
                
                // è·å–åœ°å›¾å‚æ•°å¹¶è¿›è¡Œå®‰å…¨æ£€æŸ¥
                const mapSizeX = parseInt(document.getElementById('mapSizeX').value);
                const mapSizeY = parseInt(document.getElementById('mapSizeY').value);
                
                // é™åˆ¶æå¤§åœ°å›¾çš„å‚æ•°ä»¥é¿å…æ€§èƒ½é—®é¢˜
                if (mapSizeX > 800 || mapSizeY > 800) {
                    console.warn(`åœ°å›¾å°ºå¯¸è¿‡å¤§ ${mapSizeX}x${mapSizeY}ï¼Œå¯èƒ½å½±å“æ€§èƒ½`);
                    // å¯¹å¤§åœ°å›¾è°ƒæ•´ä¸€äº›å‚æ•°
                    const roomCountSlider = document.getElementById('roomCount');
                    const currentRoomCount = parseInt(roomCountSlider.value);
                    if (currentRoomCount > 30) {
                        console.log(`å¤§åœ°å›¾è‡ªåŠ¨è°ƒæ•´æˆ¿é—´æ•°é‡ä» ${currentRoomCount} åˆ° 30`);
                        roomCountSlider.value = 30;
                        document.getElementById('roomValue').textContent = 30;
                    }
                }
            
            // åº”ç”¨æ¸¸æˆæ¨¡å¼è®¾ç½®
            const modeConfig = applyGameMode(gameMode);
            
            // åº”ç”¨åœ°å›¾é£æ ¼è®¾ç½®
            const styleConfig = applyMapStyle(mapStyle);
            
            const sizeX = parseInt(document.getElementById('mapSizeX').value);
            const sizeY = parseInt(document.getElementById('mapSizeY').value);
            const size = Math.max(sizeX, sizeY); // å‘åå…¼å®¹ï¼Œä½¿ç”¨è¾ƒå¤§çš„å°ºå¯¸
            const floors = parseInt(document.getElementById('floorCount').value);
            const roomCount = parseInt(document.getElementById('roomCount').value);
            const corridorWidth = parseInt(document.getElementById('corridorWidth').value);
            const coverDensity = parseInt(document.getElementById('coverDensity').value);
            const waterAmount = parseInt(document.getElementById('waterAmount').value);
            const stairsCount = parseInt(document.getElementById('stairsCount').value);
            const windowDensity = parseInt(document.getElementById('windowDensity').value);
            
            // åˆå§‹åŒ–åœ°å›¾
            initMap(sizeX, sizeY, floors);
            
            // ç”Ÿæˆæ¯å±‚çš„æˆ¿é—´
            const allRooms = [];
            for (let floor = 0; floor < floors; floor++) {
                const rooms = generateRooms(sizeX, sizeY, roomCount, floor);
                connectRooms(rooms, floor, corridorWidth);
                
                // ç”Ÿæˆå¤§å…ï¼ˆåªåœ¨ç¬¬ä¸€å±‚ï¼‰
                if (floor === 0) {
                    generateLobby(Math.max(sizeX, sizeY), floor);
                }
                
                // ç”Ÿæˆé«˜ä½å·®åŒºåŸŸ
                generateElevationAreas(Math.max(sizeX, sizeY), floor);
                
                // æ·»åŠ æˆ¿é—´å¡«å……ï¼ˆåœ¨æˆ¿é—´å†…éƒ¨åˆ›å»ºæ›´å¤šå°æˆ¿é—´ï¼‰
                addRoomFilling(rooms, floor);
                
                allRooms.push(...rooms);
            }
            
            // æ·»åŠ æ¥¼æ¢¯
            addStairs(allRooms, stairsCount);
            
            // æ·»åŠ ç‰¹æ®Šå…ƒç´ 
            addSpecialElements(allRooms, coverDensity, waterAmount, windowDensity);
            
            // æ·»åŠ ç‹™å‡»é•¿é“
            const longLanesCount = parseInt(document.getElementById('longLanes').value);
            if (longLanesCount > 0) {
                addLongLanes(allRooms, longLanesCount);
            }
            
            // æ·»åŠ æš—é“
            const underpassDensity = parseInt(document.getElementById('underpass').value);
            if (underpassDensity > 0) {
                addUnderpass(allRooms, underpassDensity);
            }
            
            // åˆ›å»ºæ¥¼å±‚é€‰æ‹©å™¨
            createFloorSelector();
            
            // é‡ç½®åˆ°ç¬¬ä¸€å±‚
            currentFloor = 0;
            
            // ç»˜åˆ¶åœ°å›¾
            drawMap();
            
            console.log('åœ°å›¾ç”Ÿæˆå®Œæˆï¼');
            
            // å¯¹äºå¼‚æ­¥è°ƒç”¨ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€
            const generateBtn = document.getElementById('generateBtn');
            if (generateBtn.disabled) {
                generateBtn.disabled = false;
                generateBtn.textContent = 'ç”Ÿæˆåœ°å›¾';
            }
        }
            
        } catch (error) {
            console.error('åœ°å›¾ç”Ÿæˆå¤±è´¥:', error);
            alert('åœ°å›¾ç”Ÿæˆå¤±è´¥: ' + error.message + '\nè¯·å°è¯•è°ƒæ•´å‚æ•°åé‡æ–°ç”Ÿæˆã€‚');
        } finally {
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = false;
            generateBtn.textContent = 'ç”Ÿæˆåœ°å›¾';
        }
        }
        
        // è·å–å½“å‰ä¸»é¢˜çš„canvasèƒŒæ™¯è‰²
        function getCanvasBackgroundColor() {
            const rootStyles = getComputedStyle(document.documentElement);
            return rootStyles.getPropertyValue('--canvas-bg').trim();
        }
        
        // è·å–ç§»åŠ¨ç«¯é€‚é…çš„canvaså°ºå¯¸
        function getMobileOptimizedCanvasSize(mapWidth, mapHeight, baseCellSize) {
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            
            if (!isMobile) {
                return { cellSize: baseCellSize, maxCanvasSize: 1200 };
            }
            
            // ç§»åŠ¨ç«¯é™åˆ¶æ›´å°çš„canvaså°ºå¯¸
            const maxCanvasSize = isSmallMobile ? 350 : 450;
            const screenWidth = window.innerWidth - 20; // å‡å»padding
            const maxWidth = Math.min(maxCanvasSize, screenWidth);
            
            // è®¡ç®—é€‚åˆçš„cellSize
            let cellSize = baseCellSize;
            const actualWidth = mapWidth * cellSize;
            const actualHeight = mapHeight * cellSize;
            
            if (actualWidth > maxWidth || actualHeight > maxWidth) {
                const scale = Math.min(maxWidth / actualWidth, maxWidth / actualHeight);
                cellSize = Math.max(1, Math.floor(cellSize * scale));
            }
            
            return { cellSize: cellSize, maxCanvasSize: maxWidth };
        }
        
        // ç»˜åˆ¶å åŠ è§†å›¾åœ°å›¾
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const optimizedSize = getMobileOptimizedCanvasSize(map[0].length, map.length, 10);
            const cellSize = optimizedSize.cellSize;
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = getCanvasBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ä»åº•å±‚åˆ°é¡¶å±‚ç»˜åˆ¶ï¼Œä½¿ç”¨é€æ˜åº¦
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25); // é«˜å±‚æ›´é€æ˜
                const offset = floor * 2; // æ¯å±‚åç§»ï¼Œåˆ›å»º3Dæ•ˆæœ
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let color = '#000';
                            
                            // æ ¹æ®æ¥¼å±‚è°ƒæ•´é¢œè‰²
                            switch(tile) {
                                case TileType.FLOOR: 
                                    color = floor === 0 ? 'rgba(74, 74, 74, ' : 
                                           floor === 1 ? 'rgba(90, 90, 90, ' : 
                                           floor === 2 ? 'rgba(106, 106, 106, ' : 
                                           'rgba(122, 122, 122, ';
                                    break;
                                case TileType.WALL: 
                                    color = floor === 0 ? 'rgba(176, 176, 176, ' : 
                                           floor === 1 ? 'rgba(160, 160, 176, ' : 
                                           floor === 2 ? 'rgba(144, 144, 176, ' : 
                                           'rgba(128, 128, 176, ';
                                    break;
                                case TileType.DOOR: 
                                    color = 'rgba(96, 96, 96, '; 
                                    break;
                                case TileType.WINDOW: 
                                    color = 'rgba(106, 140, 175, '; 
                                    break;
                                case TileType.COVER: 
                                    color = 'rgba(48, 48, 48, '; 
                                    break;
                                case TileType.BOMBSITE_A: 
                                    color = 'rgba(90, 90, 0, '; 
                                    break;
                                case TileType.BOMBSITE_B: 
                                    color = 'rgba(90, 58, 0, '; 
                                    break;
                                case TileType.T_SPAWN: 
                                    color = 'rgba(58, 32, 32, '; 
                                    break;
                                case TileType.CT_SPAWN: 
                                    color = 'rgba(32, 32, 48, '; 
                                    break;
                                case TileType.STAIRS_UP: 
                                    color = 'rgba(139, 115, 85, '; 
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    color = 'rgba(107, 83, 69, '; 
                                    break;
                                case TileType.WATER: 
                                    color = 'rgba(42, 77, 105, '; 
                                    break;
                                case TileType.BRIDGE: 
                                    color = 'rgba(90, 90, 90, '; 
                                    break;
                            }
                            
                            // æ·»åŠ é€æ˜åº¦
                            color += opacity + ')';
                            
                            ctx.fillStyle = color;
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // ç»˜åˆ¶å¢™å£è¾¹æ¡†
                            if (tile === TileType.WALL) {
                                ctx.strokeStyle = 'rgba(128, 128, 128, ' + (opacity * 0.5) + ')';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(
                                    x * cellSize + offset, 
                                    y * cellSize + offset, 
                                    cellSize, 
                                    cellSize
                                );
                            }
                            
                            // ç»˜åˆ¶æ¥¼æ¢¯ç®­å¤´å’Œæ¥¼å±‚æ ‡è®°
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                ctx.font = '8px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? 'â†‘' : 'â†“';
                                ctx.fillText(
                                    arrow + (floor + 1), 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + 3 + offset
                                );
                            }
                        }
                    }
                }
                
                // ç»˜åˆ¶æ¥¼å±‚æ ‡ç­¾
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`F${floor + 1}`, 10 + offset, 20 + offset);
            }
            
            // ç»˜åˆ¶è¯´æ˜
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('å åŠ è§†å›¾æ¨¡å¼', canvas.width - 10, 20);
            
            // ç»˜åˆ¶æ¥¼å±‚å›¾ä¾‹
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.fillRect(10, 40 + i * 20, 15, 15);
                ctx.fillStyle = '#ccc';
                ctx.fillText(`ç¬¬${i + 1}å±‚`, 30, 50 + i * 20);
            }
            
            // ç»˜åˆ¶åŒ…ç‚¹æ ‡è®°ï¼ˆæ‰€æœ‰å±‚ï¼‰
            const overlayBombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + overlayBombFontSize + 'px Arial';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                ctx.fillStyle = 'rgba(255, 215, 0, ' + opacity + ')';
                
                // AåŒ…ç‚¹
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_A) {
                            ctx.strokeText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // BåŒ…ç‚¹
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_B) {
                            ctx.strokeText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // CåŒ…ç‚¹
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_C) {
                            ctx.strokeText('C', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('C', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // DåŒ…ç‚¹
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_D) {
                            ctx.strokeText('D', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('D', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // EåŒ…ç‚¹
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_E) {
                            ctx.strokeText('E', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('E', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
            }
        }
        
        // åˆ›å»ºæ¥¼å±‚é€‰æ‹©å™¨
        function createFloorSelector() {
            const selector = document.getElementById('floorSelector');
            selector.innerHTML = '';
            
            // æ·»åŠ æ¥¼å±‚æŒ‰é’®
            for (let i = 0; i < totalFloors; i++) {
                const btn = document.createElement('button');
                btn.className = 'floor-btn';
                btn.textContent = `ç¬¬${i + 1}å±‚`;
                btn.onclick = function() {
                    overlayMode = false;
                    currentFloor = i;
                    updateFloorButtons();
                    drawMap();
                };
                if (i === 0 && !overlayMode) {
                    btn.classList.add('active');
                }
                selector.appendChild(btn);
            }
            
            // æ·»åŠ å åŠ è§†å›¾æŒ‰é’®
            if (totalFloors > 1) {
                const overlayBtn = document.createElement('button');
                overlayBtn.className = 'overlay-btn';
                overlayBtn.textContent = 'ğŸ”² å åŠ è§†å›¾';
                overlayBtn.onclick = function() {
                    overlayMode = !overlayMode;
                    updateFloorButtons();
                    
                    if (overlayMode) {
                        overlayBtn.classList.add('active');
                        drawOverlayMap();
                    } else {
                        overlayBtn.classList.remove('active');
                        drawMap();
                    }
                };
                selector.appendChild(overlayBtn);
            }
        }
        
        // æ›´æ–°æ¥¼å±‚æŒ‰é’®çŠ¶æ€
        function updateFloorButtons() {
            const buttons = document.querySelectorAll('.floor-btn');
            const overlayBtn = document.querySelector('.overlay-btn');
            
            buttons.forEach((btn, index) => {
                if (!overlayMode && index === currentFloor) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            if (overlayBtn) {
                if (overlayMode) {
                    overlayBtn.classList.add('active');
                } else {
                    overlayBtn.classList.remove('active');
                }
            }
        }
        
        // ç»˜åˆ¶åœ°å›¾
        function drawMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // å¯ç”¨æŠ—é”¯é½¿å’Œå¹³æ»‘æ•ˆæœ
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[currentFloor]) return;
            
            const map = mapFloors[currentFloor];
            const mapSizeX = parseInt(document.getElementById('mapSizeX').value);
            const mapSizeY = parseInt(document.getElementById('mapSizeY').value);
            const mapSize = Math.max(mapSizeX, mapSizeY); // ä½¿ç”¨è¾ƒå¤§çš„å°ºå¯¸æ¥ç¡®å®šæ ¼å­å¤§å°
            
            // æ ¹æ®åœ°å›¾å°ºå¯¸åŠ¨æ€è°ƒæ•´æ–¹å—å¤§å°ï¼Œä½¿ç”¨æ›´å°çš„å°ºå¯¸å‡å°‘åƒç´ æ„Ÿ
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // é™åˆ¶ç”»å¸ƒæœ€å¤§å°ºå¯¸ï¼Œé¿å…è¿‡å¤§
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = getCanvasBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶åœ°å›¾
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[0].length; x++) {
                    const tile = map[y][x];
                    let color = '#000';
                    
                    switch(tile) {
                        case TileType.FLOOR: color = '#4a4a4a'; break;
                        case TileType.WALL: color = '#b0b0b0'; break;
                        case TileType.DOOR: color = '#606060'; break;
                        case TileType.WINDOW: color = '#6a8caf'; break;
                        case TileType.COVER: color = '#303030'; break;
                        case TileType.HIGH_GROUND: color = '#6a6a4a'; break;    // é«˜åœ°ï¼ˆæµ…é»„ç°ï¼‰
                        case TileType.LOW_GROUND: color = '#2a2a4a'; break;     // ä½åœ°ï¼ˆæ·±è“ç°ï¼‰
                        case TileType.MEDIUM_GROUND: color = '#4a4a4a'; break;  // ä¸­ç­‰åœ°ï¼ˆæ ‡å‡†ç°ï¼‰
                        case TileType.BOMBSITE_A: color = '#5a5a00'; break;
                        case TileType.BOMBSITE_B: color = '#5a3a00'; break;
                        case TileType.BOMBSITE_C: color = '#5a1a00'; break; // åŒ…ç‚¹Cï¼ˆæ·±æ©™ï¼‰
                        case TileType.BOMBSITE_D: color = '#3a5a00'; break; // åŒ…ç‚¹Dï¼ˆæ·±ç»¿ï¼‰
                        case TileType.BOMBSITE_E: color = '#1a5a00'; break; // åŒ…ç‚¹Eï¼ˆæ·±é’ï¼‰
                        case TileType.T_SPAWN: color = '#3a2020'; break;
                        case TileType.CT_SPAWN: color = '#202030'; break;
                        case TileType.STAIRS_UP: color = '#8B7355'; break;
                        case TileType.STAIRS_DOWN: color = '#6B5345'; break;
                        case TileType.WATER: color = '#2a4d69'; break;
                        case TileType.BRIDGE: color = '#5a5a5a'; break;
                        case TileType.OUTDOOR: color = '#7a8a6a'; break;           // å¤–åœºåœ°é¢ï¼ˆæµ…ç»¿ç°ï¼‰
                        case TileType.OUTDOOR_WALL: color = '#8a8a7a'; break;     // å¤–åœºå›´å¢™ï¼ˆæµ…ç°ï¼‰
                        case TileType.OUTDOOR_COVER: color = '#4a5a4a'; break;    // å¤–åœºæ©ä½“ï¼ˆæ·±ç»¿ç°ï¼‰
                        case TileType.LOBBY: color = '#6a7a8a'; break;            // å¤§å…
                        case TileType.LOBBY_ENTRANCE: color = '#8a6a7a'; break;   // å¤§å…å…¥å£
                        case TileType.LOBBY_CENTER: color = '#7a6a8a'; break;     // å¤§å…ä¸­å¿ƒ
                        // å¸¸è§åœ°å½¢/æ¨¡å—é¢œè‰²
                        case TileType.LONG_LANE: color = '#8a4a4a'; break;        // å¤§é“ï¼ˆæ·±çº¢ç°ï¼‰
                        case TileType.SHORT_LANE: color = '#4a8a4a'; break;       // å°é“ï¼ˆæ·±ç»¿ç°ï¼‰
                        case TileType.MID_LANE: color = '#4a4a8a'; break;         // ä¸­è·¯ï¼ˆæ·±è“ç°ï¼‰
                        case TileType.PLATFORM: color = '#8a8a4a'; break;         // é«˜å°ï¼ˆæ·±é»„ç°ï¼‰
                        case TileType.UNDERPASS: color = '#4a8a8a'; break;        // æš—é“ï¼ˆæ·±é’ç°ï¼‰
                        case TileType.CONNECTOR: color = '#8a4a8a'; break;        // è¿æ¥è·¯ï¼ˆæ·±ç´«ç°ï¼‰
                        case TileType.RAMP: color = '#6a6a6a'; break;             // æ–œå¡ï¼ˆä¸­ç°ï¼‰
                        case TileType.ROTATION_PATH: color = '#5a5a5a'; break;    // è½¬ç‚¹è·¯çº¿ï¼ˆæ·±ç°ï¼‰
                        case TileType.SHADOW_POINT: color = '#8a6a4a'; break;      // é˜´ç‚¹ï¼ˆæ·±æ£•ç°ï¼‰
                    }
                    
                    if (tile !== TileType.VOID) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        
                        // ç§»é™¤å¢™å£è¾¹æ¡†ï¼Œä¸ä½¿ç”¨æ ¼å­
                        
                        // ç»˜åˆ¶æ¥¼æ¢¯ç®­å¤´
                        if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                            ctx.fillStyle = '#fff';
                            const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                            ctx.font = fontSize + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(tile === TileType.STAIRS_UP ? 'â†‘' : 'â†“', 
                                x * cellSize + cellSize/2, y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3));
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶åŒ…ç‚¹æ ‡è®°
            const bombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + bombFontSize + 'px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            // åŒ…ç‚¹æ ‡è®°æ˜ å°„
            const bombSiteMarkers = {
                [TileType.BOMBSITE_A]: 'A',
                [TileType.BOMBSITE_B]: 'B',
                [TileType.BOMBSITE_C]: 'C',
                [TileType.BOMBSITE_D]: 'D',
                [TileType.BOMBSITE_E]: 'E'
            };
            
            // ç»˜åˆ¶æ‰€æœ‰åŒ…ç‚¹æ ‡è®°
            for (const [tileType, marker] of Object.entries(bombSiteMarkers)) {
                for (let y = 0; y < map.length; y++) {
                    for (let x = 0; x < map[0].length; x++) {
                        if (map[y][x] === parseInt(tileType)) {
                            ctx.strokeText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                            ctx.fillText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                            y = map.length;
                            break;
                        }
                    }
                }
            }
        }
        
        // ç»˜åˆ¶å åŠ è§†å›¾
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // å¯ç”¨æŠ—é”¯é½¿å’Œå¹³æ»‘æ•ˆæœ
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const mapSizeX = parseInt(document.getElementById('mapSizeX').value);
            const mapSizeY = parseInt(document.getElementById('mapSizeY').value);
            const mapSize = Math.max(mapSizeX, mapSizeY); // ä½¿ç”¨è¾ƒå¤§çš„å°ºå¯¸æ¥ç¡®å®šæ ¼å­å¤§å°
            
            // æ ¹æ®åœ°å›¾å°ºå¯¸åŠ¨æ€è°ƒæ•´æ–¹å—å¤§å°ï¼Œä½¿ç”¨æ›´å°çš„å°ºå¯¸å‡å°‘åƒç´ æ„Ÿ
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // é™åˆ¶ç”»å¸ƒæœ€å¤§å°ºå¯¸ï¼Œé¿å…è¿‡å¤§
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = getCanvasBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ä»åº•å±‚åˆ°é¡¶å±‚ç»˜åˆ¶
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let baseColor = [0, 0, 0];
                            
                            switch(tile) {
                                case TileType.FLOOR: 
                                    baseColor = [74 + floor * 16, 74 + floor * 16, 74 + floor * 16];
                                    break;
                                case TileType.WALL: 
                                    baseColor = [176 - floor * 16, 176 - floor * 16, 176];
                                    break;
                                case TileType.HIGH_GROUND: 
                                    baseColor = [106, 106, 74]; // é«˜åœ°ï¼ˆæµ…é»„ç°ï¼‰
                                    break;
                                case TileType.LOW_GROUND: 
                                    baseColor = [42, 42, 74]; // ä½åœ°ï¼ˆæ·±è“ç°ï¼‰
                                    break;
                                case TileType.MEDIUM_GROUND: 
                                    baseColor = [74, 74, 74]; // ä¸­ç­‰åœ°ï¼ˆæ ‡å‡†ç°ï¼‰
                                    break;
                                case TileType.COVER: 
                                    baseColor = [48, 48, 48];
                                    break;
                                case TileType.BOMBSITE_A: 
                                    baseColor = [90, 90, 0];
                                    break;
                                case TileType.BOMBSITE_B: 
                                    baseColor = [90, 58, 0];
                                    break;
                                case TileType.BOMBSITE_C: 
                                    baseColor = [90, 26, 0]; // åŒ…ç‚¹Cï¼ˆæ·±æ©™ï¼‰
                                    break;
                                case TileType.BOMBSITE_D: 
                                    baseColor = [58, 90, 0]; // åŒ…ç‚¹Dï¼ˆæ·±ç»¿ï¼‰
                                    break;
                                case TileType.BOMBSITE_E: 
                                    baseColor = [26, 90, 0]; // åŒ…ç‚¹Eï¼ˆæ·±é’ï¼‰
                                    break;
                                case TileType.T_SPAWN: 
                                    baseColor = [58, 32, 32];
                                    break;
                                case TileType.CT_SPAWN: 
                                    baseColor = [32, 32, 48];
                                    break;
                                case TileType.STAIRS_UP: 
                                    baseColor = [139, 115, 85];
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    baseColor = [107, 83, 69];
                                    break;
                                case TileType.WATER: 
                                    baseColor = [42, 77, 105];
                                    break;
                                case TileType.WINDOW:
                                    baseColor = [106, 140, 175];
                                    break;
                                // å¸¸è§åœ°å½¢/æ¨¡å—é¢œè‰²
                                case TileType.LONG_LANE:
                                    baseColor = [138, 74, 74]; // å¤§é“ï¼ˆæ·±çº¢ç°ï¼‰
                                    break;
                                case TileType.SHORT_LANE:
                                    baseColor = [74, 138, 74]; // å°é“ï¼ˆæ·±ç»¿ç°ï¼‰
                                    break;
                                case TileType.MID_LANE:
                                    baseColor = [74, 74, 138]; // ä¸­è·¯ï¼ˆæ·±è“ç°ï¼‰
                                    break;
                                case TileType.PLATFORM:
                                    baseColor = [138, 138, 74]; // é«˜å°ï¼ˆæ·±é»„ç°ï¼‰
                                    break;
                                case TileType.UNDERPASS:
                                    baseColor = [74, 138, 138]; // æš—é“ï¼ˆæ·±é’ç°ï¼‰
                                    break;
                                case TileType.CONNECTOR:
                                    baseColor = [138, 74, 138]; // è¿æ¥è·¯ï¼ˆæ·±ç´«ç°ï¼‰
                                    break;
                                case TileType.RAMP:
                                    baseColor = [106, 106, 106]; // æ–œå¡ï¼ˆä¸­ç°ï¼‰
                                    break;
                                case TileType.ROTATION_PATH:
                                    baseColor = [90, 90, 90]; // è½¬ç‚¹è·¯çº¿ï¼ˆæ·±ç°ï¼‰
                                    break;
                                case TileType.SHADOW_POINT:
                                    baseColor = [138, 106, 74]; // é˜´ç‚¹ï¼ˆæ·±æ£•ç°ï¼‰
                                    break;
                                default:
                                    baseColor = [50, 50, 50];
                            }
                            
                            ctx.fillStyle = 'rgba(' + baseColor[0] + ',' + baseColor[1] + ',' + baseColor[2] + ',' + opacity + ')';
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // ç§»é™¤å¢™å£è¾¹æ¡†ï¼Œä¸ä½¿ç”¨æ ¼å­
                            
                            // æ¥¼æ¢¯æ ‡è®°
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                                ctx.font = fontSize + 'px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? 'â†‘' : 'â†“';
                                ctx.fillText(
                                    arrow, 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3) + offset
                                );
                            }
                        }
                    }
                }
                
                // æ¥¼å±‚æ ‡ç­¾
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                const floorFontSize = Math.max(8, Math.floor(cellSize * 0.8));
                ctx.font = 'bold ' + floorFontSize + 'px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('F' + (floor + 1), Math.floor(cellSize * 0.8) + offset, Math.floor(cellSize * 1.5) + offset);
            }
            
            // æ ‡é¢˜
            ctx.fillStyle = '#4CAF50';
            const titleFontSize = Math.max(10, Math.floor(cellSize * 1.0));
            ctx.font = 'bold ' + titleFontSize + 'px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('å åŠ è§†å›¾', canvas.width - Math.floor(cellSize * 0.8), Math.floor(cellSize * 1.5));
            
            // å›¾ä¾‹
            const legendFontSize = Math.max(8, Math.floor(cellSize * 0.7));
            ctx.font = legendFontSize + 'px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(200, 200, 200, ' + opacity + ')';
                const legendY = Math.floor(cellSize * 2.5) + i * Math.floor(cellSize * 1.5);
                ctx.fillRect(Math.floor(cellSize * 0.8), legendY, Math.floor(cellSize * 1.2), Math.floor(cellSize * 1.2));
                ctx.fillStyle = '#ccc';
                ctx.fillText('ç¬¬' + (i + 1) + 'å±‚', Math.floor(cellSize * 2.2), legendY + Math.floor(cellSize * 0.8));
            }
        }
        
        // å¯¼å‡ºåœ°å›¾
        function exportMap() {
            const data = {
                floors: mapFloors,
                totalFloors: totalFloors,
                currentFloor: currentFloor
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map_' + Date.now() + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // UCCå¯¼å‡ºæ—¥å¿—åŠŸèƒ½
        function logUCCExport(message) {
            const logElement = document.getElementById('uccExportLog');
            if (logElement) {
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `[${timestamp}] ${message}<br>`;
                logElement.scrollTop = logElement.scrollHeight;
            }
            console.log(message);
        }

        function clearUCCLog() {
            const logElement = document.getElementById('uccExportLog');
            if (logElement) {
                logElement.innerHTML = '';
            }
        }

        // UCCå¯¼å‡ºä½¿ç”¨è¯´æ˜å¼¹çª—ç›¸å…³å‡½æ•°
        function showUccTutorial() {
            const modal = document.getElementById('uccTutorialModal');
            if (modal) {
                modal.style.display = 'flex';
                // æ·»åŠ ESCé”®å…³é—­åŠŸèƒ½
                document.addEventListener('keydown', handleTutorialKeydown);
            }
        }

        function closeUccTutorial(neverShowAgain = false) {
            const modal = document.getElementById('uccTutorialModal');
            if (modal) {
                modal.style.display = 'none';
                // ç§»é™¤ESCé”®ç›‘å¬
                document.removeEventListener('keydown', handleTutorialKeydown);
                
                // å¦‚æœç”¨æˆ·é€‰æ‹©ä¸å†æ˜¾ç¤ºï¼Œä¿å­˜åˆ°localStorage
                if (neverShowAgain) {
                    localStorage.setItem('uccTutorialShown', 'true');
                }
            }
        }

        function handleTutorialKeydown(event) {
            if (event.key === 'Escape') {
                closeUccTutorial();
            }
        }

        function shouldShowUccTutorial() {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¾ç¤ºè¿‡æ•™ç¨‹
            return localStorage.getItem('uccTutorialShown') !== 'true';
        }

        // UCCå¯¼å‡ºåŠŸèƒ½ - åŸºäºPythonè„šæœ¬ç²¾ç¡®å®ç°
        async function exportUCC() {
            try {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºé¦–æ¬¡ä½¿ç”¨æ•™ç¨‹
                if (shouldShowUccTutorial()) {
                    showUccTutorial();
                    return; // æ˜¾ç¤ºæ•™ç¨‹ååœæ­¢æ‰§è¡Œï¼Œç”¨æˆ·å…³é—­æ•™ç¨‹åéœ€è¦é‡æ–°ç‚¹å‡»å¯¼å‡ºæŒ‰é’®
                }

                clearUCCLog();
                logUCCExport('ğŸš€ å¼€å§‹UCCå¯¼å‡º...');
                
                // è·å–å¯¼å‡ºå‚æ•°
                const zRotation = parseFloat(document.getElementById('uccZRotation').value);
                const positionMultiplier = parseFloat(document.getElementById('uccPositionMultiplier').value);
                const scaleMultiplier = parseFloat(document.getElementById('uccScaleMultiplier').value);
                const autoConvertNegative = document.getElementById('uccAutoConvertNegative').checked;
                const wallHeightMultiplier = parseFloat(document.getElementById('uccWallHeight').value) || 1;
                const sourceFile = 'mf5';

                logUCCExport(`ğŸ“‹ å¯¼å‡ºå‚æ•°: Zè½´æ—‹è½¬=${zRotation}Â°, ä½ç½®å€å¢=${positionMultiplier}, ç¼©æ”¾å€å¢=${scaleMultiplier}, å¢™é«˜å€å¢=${wallHeightMultiplier}, è´Ÿå€¼è½¬æ­£=${autoConvertNegative}, æºæ–‡ä»¶=${sourceFile}.uccï¼ˆä»…å…è®¸å¯¼å…¥å¼¹çª—æ–¹å¼ï¼‰`);

                // æ£€æŸ¥åœ°å›¾æ•°æ®
                if (!mapFloors || mapFloors.length === 0) {
                    throw new Error('è¯·å…ˆç”Ÿæˆåœ°å›¾å†å¯¼å‡º');
                }
                logUCCExport(`ğŸ“Š åœ°å›¾æ•°æ®: ${mapFloors.length}å±‚, æ€»å…±${totalFloors}å±‚`);
                
                // ä½¿ç”¨å¯¼å…¥å¼¹çª—æ‹¾å–çš„ mf5.ucc æ¨¡æ¿ï¼›è‹¥æœªå¯¼å…¥åˆ™ç«‹åˆ»å¼¹å‡ºé€‰æ‹©
                let sourceTemplate = window.__importedUccTemplate;
                if (!sourceTemplate || !(sourceTemplate instanceof ArrayBuffer)) {
                    const fileInput = document.getElementById('templateFileInput');
                    if (!fileInput) throw new Error('ç¼ºå°‘æ¨¡æ¿æ–‡ä»¶è¾“å…¥æ§ä»¶');
                    logUCCExport('ğŸ“¥ éœ€è¦ mf5.ucc æ¨¡æ¿ï¼Œæ­£åœ¨æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†...');
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const handler = async function() {
                            const file = fileInput.files && fileInput.files[0];
                            if (!file) {
                                reject(new Error('æœªé€‰æ‹©æ–‡ä»¶'));
                                fileInput.removeEventListener('change', handler);
                                return;
                            }
                            const nameLower = file.name.toLowerCase();
                            if (nameLower !== 'mf5.ucc') {
                                reject(new Error('åªå…è®¸é€‰æ‹©æ–‡ä»¶åä¸º mf5.ucc çš„æ¨¡æ¿'));
                                fileInput.value = '';
                                fileInput.removeEventListener('change', handler);
                                return;
                            }
                            try {
                                const buf = await file.arrayBuffer();
                                resolve(buf);
                            } catch(e) {
                                reject(e);
                            } finally {
                                fileInput.removeEventListener('change', handler);
                            }
                        };
                        fileInput.addEventListener('change', handler);
                        // è§¦å‘ç³»ç»Ÿæ–‡ä»¶é€‰æ‹©
                        fileInput.value = '';
                        fileInput.click();
                    });
                    window.__importedUccTemplate = arrayBuffer;
                    sourceTemplate = arrayBuffer;
                }
                logUCCExport(`âœ… å·²ä½¿ç”¨å¯¼å…¥çš„ mf5.ucc æ¨¡æ¿ (${sourceTemplate.byteLength} å­—èŠ‚)`);

                // åˆ›å»ºUCCäºŒè¿›åˆ¶æ–‡ä»¶
                logUCCExport('ğŸ”§ æ­£åœ¨å¤„ç†åœ°å›¾æ•°æ®å¹¶ç”ŸæˆUCCæ–‡ä»¶...');
                const uccData = await createUCCFileFromTemplate(sourceTemplate, mapFloors, totalFloors, {
                    zRotation,
                    positionMultiplier,
                    scaleMultiplier,
                    wallHeightMultiplier,
                    autoConvertNegative,
                    sourceFile
                });

                // ä¸‹è½½æ–‡ä»¶
                const filename = 'exported_map_' + Date.now() + '.ucc';
                const blob = new Blob([uccData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                logUCCExport(`ğŸ‰ UCCæ–‡ä»¶å¯¼å‡ºæˆåŠŸï¼æ–‡ä»¶å: ${filename} (${uccData.byteLength} å­—èŠ‚)`);
            } catch (error) {
                logUCCExport(`âŒ UCCå¯¼å‡ºå¤±è´¥: ${error.message}`);
                console.error('UCCå¯¼å‡ºå¤±è´¥:', error);
                alert('UCCå¯¼å‡ºå¤±è´¥: ' + error.message);
            }
        }

        // å·²ç¦ç”¨çš„æ¨¡æ¿åŠ è½½ï¼ˆç»Ÿä¸€é€šè¿‡å¯¼å…¥å¼¹çª—ï¼‰
        async function loadUCCTemplate() {
            throw new Error('æ¨¡æ¿åŠ è½½å·²æ”¹ä¸ºä»…é€šè¿‡å¯¼å…¥å¼¹çª—é€‰æ‹© mf5.ucc');
        }

        // åˆ›å»ºæœ€å°UCCæ¨¡æ¿ï¼ˆå·²ç¦ç”¨ - ä»…ä½¿ç”¨ç°æœ‰æ¨¡æ¿ï¼‰
        function createMinimalUCCTemplate() {
            // æ­¤åŠŸèƒ½å·²è¢«ç¦ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬åªå…è®¸ä½¿ç”¨ç°æœ‰çš„æ¨¡æ¿æ–‡ä»¶
            throw new Error("ç¦æ­¢åˆ›å»ºæ–°çš„UCCæ¨¡æ¿æ–‡ä»¶ã€‚å¿…é¡»ä½¿ç”¨Coreæ–‡ä»¶å¤¹ä¸­ç°æœ‰çš„æ¨¡æ¿æ–‡ä»¶ã€‚");
        }

        // åŸºäºç°æœ‰æ¨¡æ¿ä¿®æ”¹UCCæ–‡ä»¶ - éµå¾ªPythonè„šæœ¬çš„ç²¾ç¡®å®ç°
        async function createUCCFileFromTemplate(templateBuffer, floors, totalFloors, options) {
            // å¤åˆ¶ç°æœ‰æ¨¡æ¿åˆ°ç¼“å†²åŒºè¿›è¡Œä¿®æ”¹ (ç¦æ­¢æ–°å»ºæ–‡ä»¶)
            const buffer = templateBuffer.slice();
            const view = new DataView(buffer);
            
            logUCCExport(`ğŸ“‹ åŸºäºç°æœ‰æ¨¡æ¿è¿›è¡Œä¿®æ”¹ (${buffer.byteLength} å­—èŠ‚)`);
            
            // æ”¶é›†æ‰€æœ‰ç«‹æ–¹ä½“æ•°æ®
            const cubes = [];
            
            for (let floorIndex = 0; floorIndex < floors.length; floorIndex++) {
                const floor = floors[floorIndex];
                const floorHeight = floorIndex * 10; // æ¯å±‚10ä¸ªå•ä½é«˜
                
                for (let y = 0; y < floor.length; y++) {
                    for (let x = 0; x < floor[y].length; x++) {
                        const cell = floor[y][x];
                        if (cell === TileType.WALL) { // å¢™ä½“
                            cubes.push({
                                name: `Wall_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.FLOOR) { // æˆ¿é—´åœ°æ¿
                            cubes.push({
                                name: `Floor_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight - 0.5,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 0.1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.DOOR) { // ç‰¹æ®Šæ–¹å—
                            cubes.push({
                                name: `Special_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        }
                    }
                }
            }
            
            logUCCExport(`ğŸ“¦ æ”¶é›†åˆ° ${cubes.length} ä¸ªç«‹æ–¹ä½“å¯¹è±¡`);
            
            // åº”ç”¨å›´ç»•ä¸­å¿ƒç‚¹çš„Zè½´æ—‹è½¬ - åŸºäºPythonå®ç°
            if (options.zRotation !== 0) {
                logUCCExport(`ğŸ”„ åº”ç”¨Zè½´æ—‹è½¬ ${options.zRotation}Â°...`);
                applyCenterRotationPython(cubes, options.zRotation);
            }
            
            // è®¡ç®—æ–‡ä»¶èƒ½å®¹çº³çš„æœ€å¤§æ–¹å—æ•° - åŸºäºPythonå…¬å¼
            const maxPossibleCubes = Math.floor((buffer.byteLength - 127) / 200);
            logUCCExport(`ğŸ—‚ï¸ æ–‡ä»¶å¯å®¹çº³çº¦ ${maxPossibleCubes} ä¸ªç«‹æ–¹ä½“ï¼Œå®é™…éœ€è¦ ${cubes.length} ä¸ª`);
            
            // æŒ‰Pythonè„šæœ¬æ–¹å¼å†™å…¥ç«‹æ–¹ä½“æ•°æ®
            for (let i = 0; i < cubes.length && i < maxPossibleCubes; i++) {
                const cube = cubes[i];
                
                // ä½¿ç”¨Pythonè„šæœ¬çš„å›ºå®šç´¢å¼•è®¡ç®—æ–¹å¼
                const baseIndex = 127 + (i * 200);
                const coordStart = baseIndex;
                const rotationStart = baseIndex + 12;
                const sizeIndex = baseIndex + 28;
                
                // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åœ¨æ–‡ä»¶èŒƒå›´å†…
                if (sizeIndex + 12 > buffer.byteLength) {
                    console.warn(`ç«‹æ–¹ä½“ ${cube.name} åœ¨ç´¢å¼• ${i} å¤„è¶…å‡ºæ–‡ä»¶å¤§å°`);
                    continue;
                }
                
                // è½¬æ¢åæ ‡ç³»ç»Ÿï¼ˆBlenderåˆ°UCCï¼‰- åŸºäºPythonå®ç°
                const uccX = cube.x * 35 * options.positionMultiplier;
                const uccY = cube.y * 35 * options.positionMultiplier;
                const uccZ = cube.z * 35 * options.positionMultiplier;
                
                // è½¬æ¢æ—‹è½¬ï¼ˆå››å…ƒæ•°ï¼‰
                const uccRotation = [cube.rotationX, cube.rotationY, cube.rotationZ, cube.rotationW];
                
                // è½¬æ¢å°ºå¯¸ï¼Œåº”ç”¨ç¼©æ”¾å€å¢å™¨å’Œè´Ÿå€¼è½¬æ¢
                let scaleX = cube.scaleX * options.scaleMultiplier;
                let scaleY = cube.scaleY * options.scaleMultiplier;
                let scaleZ = cube.scaleZ * options.scaleMultiplier;
                // å¯¹å¢™ä½“åº”ç”¨é¢å¤–çš„é«˜åº¦å€å¢
                if (cube.name.startsWith('Wall_') && typeof options.wallHeightMultiplier === 'number') {
                    scaleZ = scaleZ * options.wallHeightMultiplier;
                }
                
                if (options.autoConvertNegative) {
                    scaleX = Math.abs(scaleX);
                    scaleY = Math.abs(scaleY);
                    scaleZ = Math.abs(scaleZ);
                }
                
                // å†™å…¥æ•°æ®åˆ°æŒ‡å®šä½ç½® - éµå¾ªPythonçš„struct.packæ ¼å¼
                // å†™å…¥åæ ‡ (12å­—èŠ‚ï¼Œå°ç«¯åº)
                if (coordStart >= 0 && coordStart + 12 <= buffer.byteLength) {
                    view.setFloat32(coordStart, uccX, true);
                    view.setFloat32(coordStart + 4, uccY, true);
                    view.setFloat32(coordStart + 8, uccZ, true);
                }
                
                // å†™å…¥æ—‹è½¬ (16å­—èŠ‚ï¼Œå°ç«¯åºï¼Œå››å…ƒæ•°XYZW)
                if (rotationStart >= 0 && rotationStart + 16 <= buffer.byteLength) {
                    view.setFloat32(rotationStart, uccRotation[0], true);
                    view.setFloat32(rotationStart + 4, uccRotation[1], true);
                    view.setFloat32(rotationStart + 8, uccRotation[2], true);
                    view.setFloat32(rotationStart + 12, uccRotation[3], true);
                }
                
                // å†™å…¥å°ºå¯¸ (åœ¨åˆ†éš”ç¬¦å12å­—èŠ‚ï¼Œå°ç«¯åº)
                if (sizeIndex >= 0 && sizeIndex + 16 <= buffer.byteLength) {
                    // ç¡®ä¿åˆ†éš”ç¬¦å­˜åœ¨
                    view.setUint8(sizeIndex, 0x00);
                    view.setUint8(sizeIndex + 1, 0x00);
                    view.setUint8(sizeIndex + 2, 0x80);
                    view.setUint8(sizeIndex + 3, 0x3F);
                    
                    // å†™å…¥å°ºå¯¸æ•°æ®
                    view.setFloat32(sizeIndex + 4, scaleX, true);
                    view.setFloat32(sizeIndex + 8, scaleY, true);
                    view.setFloat32(sizeIndex + 12, scaleZ, true);
                }
                
                // æ¯éš”ä¸€å®šæ•°é‡æ˜¾ç¤ºè¿›åº¦
                if (i % 50 === 0 || i === cubes.length - 1) {
                    logUCCExport(`ğŸ“ æ­£åœ¨å†™å…¥ç«‹æ–¹ä½“æ•°æ®... ${i + 1}/${cubes.length}`);
                }
            }
            
            // å°†å¤šä½™çš„æ–¹å—ä½ç½®å½’é›¶ - åŸºäºPythonå®ç°
            const maxCubes = Math.min(10000, maxPossibleCubes);
            logUCCExport(`ğŸ§¹ æ¸…ç†å¤šä½™ä½ç½®... (${cubes.length} åˆ° ${maxCubes})`);
            for (let i = cubes.length; i < maxCubes; i++) {
                const baseIndex = 127 + (i * 200);
                const coordStart = baseIndex;
                const rotationStart = baseIndex + 12;
                const sizeIndex = baseIndex + 28;
                
                // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åœ¨æ–‡ä»¶èŒƒå›´å†…
                if (sizeIndex + 12 > buffer.byteLength) {
                    break;
                }
                
                // ä½ç½®å½’é›¶
                if (coordStart >= 0 && coordStart + 12 <= buffer.byteLength) {
                    view.setFloat32(coordStart, 0.0, true);
                    view.setFloat32(coordStart + 4, 0.0, true);
                    view.setFloat32(coordStart + 8, 0.0, true);
                }
                
                // æ—‹è½¬å½’é›¶ï¼ˆé»˜è®¤å››å…ƒæ•°ï¼‰
                if (rotationStart >= 0 && rotationStart + 16 <= buffer.byteLength) {
                    view.setFloat32(rotationStart, 0.0, true);
                    view.setFloat32(rotationStart + 4, 0.0, true);
                    view.setFloat32(rotationStart + 8, 0.0, true);
                    view.setFloat32(rotationStart + 12, 1.0, true);
                }
                
                // å°ºå¯¸å½’é›¶
                if (sizeIndex >= 0 && sizeIndex + 16 <= buffer.byteLength) {
                    view.setFloat32(sizeIndex + 4, 0.0, true);
                    view.setFloat32(sizeIndex + 8, 0.0, true);
                    view.setFloat32(sizeIndex + 12, 0.0, true);
                }
            }
            
            logUCCExport(`âœ… å·²å¯¼å‡º ${cubes.length} ä¸ªç«‹æ–¹ä½“ï¼Œå¤šä½™ä½ç½®å·²æ¸…ç†`);
            return buffer;
        }

        // åº”ç”¨å›´ç»•ä¸­å¿ƒç‚¹çš„Zè½´æ—‹è½¬ - åŸºäºPython mathutilså®ç°
        function applyCenterRotationPython(cubes, zAngleDegrees) {
            if (cubes.length === 0) return;
            
            // è®¡ç®—æ‰€æœ‰ç«‹æ–¹ä½“çš„å¹³å‡ä½ç½®ï¼ˆç»„åˆä¸­å¿ƒç‚¹ï¼‰
            let totalX = 0, totalY = 0, totalZ = 0;
            for (const cube of cubes) {
                totalX += cube.x;
                totalY += cube.y;
                totalZ += cube.z;
            }
            const centerX = totalX / cubes.length;
            const centerY = totalY / cubes.length;
            const centerZ = totalZ / cubes.length;
            
            logUCCExport(`ğŸ¯ è®¡ç®—ç»„åˆä¸­å¿ƒç‚¹: (${centerX.toFixed(3)}, ${centerY.toFixed(3)}, ${centerZ.toFixed(3)})`);
            
            // è½¬æ¢è§’åº¦ä¸ºå¼§åº¦
            const zAngleRad = zAngleDegrees * Math.PI / 180;
            
            // åˆ›å»ºZè½´æ—‹è½¬å››å…ƒæ•° - åŸºäºPythonçš„å®ç°
            const zQuat = {
                x: 0,
                y: 0,
                z: Math.sin(zAngleRad / 2),
                w: Math.cos(zAngleRad / 2)
            };
            
            // å¯¹æ¯ä¸ªç«‹æ–¹ä½“åº”ç”¨å›´ç»•ç»„åˆä¸­å¿ƒçš„æ—‹è½¬
            for (const cube of cubes) {
                // è®¡ç®—ç›¸å¯¹äºç»„åˆä¸­å¿ƒçš„åç§»
                const offsetX = cube.x - centerX;
                const offsetY = cube.y - centerY;
                const offsetZ = cube.z - centerZ;
                
                // åº”ç”¨Zè½´æ—‹è½¬åˆ°åç§»å‘é‡
                const rotatedOffsetX = offsetX * Math.cos(zAngleRad) - offsetY * Math.sin(zAngleRad);
                const rotatedOffsetY = offsetX * Math.sin(zAngleRad) + offsetY * Math.cos(zAngleRad);
                const rotatedOffsetZ = offsetZ; // Zè½´æ—‹è½¬ä¸å½±å“Zåæ ‡
                
                // è®¡ç®—æ–°çš„ä½ç½®
                cube.x = centerX + rotatedOffsetX;
                cube.y = centerY + rotatedOffsetY;
                cube.z = centerZ + rotatedOffsetZ;
                
                // åº”ç”¨æ—‹è½¬åˆ°ç‰©ä½“çš„æœå‘ï¼ˆå››å…ƒæ•°ä¹˜æ³•ï¼‰
                const originalQuat = {
                    x: cube.rotationX,
                    y: cube.rotationY,
                    z: cube.rotationZ,
                    w: cube.rotationW
                };
                
                // å››å…ƒæ•°ä¹˜æ³•ï¼šzQuat * originalQuat
                const newQuat = multiplyQuaternions(zQuat, originalQuat);
                cube.rotationX = newQuat.x;
                cube.rotationY = newQuat.y;
                cube.rotationZ = newQuat.z;
                cube.rotationW = newQuat.w;
            }
            
            logUCCExport(`âœ… æ‰€æœ‰ç«‹æ–¹ä½“å·²å›´ç»•ç»„åˆä¸­å¿ƒå®Œæˆ Zè½´${zAngleDegrees}Â° æ•´ä½“æ—‹è½¬`);
        }
        
        // å››å…ƒæ•°ä¹˜æ³•
        function multiplyQuaternions(q1, q2) {
            return {
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
            };
        }

        // åˆ›å»ºUCCæ–‡ä»¶çš„æ ¸å¿ƒå‡½æ•°ï¼ˆä¿ç•™å…¼å®¹æ€§ï¼‰
        function createUCCFile(floors, totalFloors, options) {
            // åˆ›å»ºåŸºç¡€UCCæ–‡ä»¶æ¨¡æ¿
            const baseTemplate = createUCCTemplate(options.sourceFile);
            
            // æ”¶é›†æ‰€æœ‰ç«‹æ–¹ä½“æ•°æ®
            const cubes = [];
            
            for (let floorIndex = 0; floorIndex < floors.length; floorIndex++) {
                const floor = floors[floorIndex];
                const floorHeight = floorIndex * 10; // æ¯å±‚10ä¸ªå•ä½é«˜
                
                for (let y = 0; y < floor.length; y++) {
                    for (let x = 0; x < floor[y].length; x++) {
                        const cell = floor[y][x];
                        if (cell === TileType.WALL) { // å¢™ä½“
                            cubes.push({
                                name: `Wall_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.FLOOR) { // æˆ¿é—´åœ°æ¿
                            cubes.push({
                                name: `Floor_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight - 0.5,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 0.1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.DOOR) { // ç‰¹æ®Šæ–¹å—
                            cubes.push({
                                name: `Special_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1.2,
                                scaleY: 1.2,
                                scaleZ: 1.2,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        }
                    }
                }
            }

            console.log(`ç”Ÿæˆäº† ${cubes.length} ä¸ªç«‹æ–¹ä½“`);

            // åº”ç”¨Zè½´æ—‹è½¬å˜æ¢ï¼ˆå›´ç»•ä¸­å¿ƒç‚¹ï¼‰
            if (options.zRotation !== 0) {
                applyCenterRotation(cubes, options.zRotation);
            }

            // å†™å…¥ç«‹æ–¹ä½“æ•°æ®åˆ°UCCæ¨¡æ¿
            return writeObjectsToUCC(baseTemplate, cubes, options);
        }

        // åˆ›å»ºUCCæ¨¡æ¿
        function createUCCTemplate(sourceType) {
            // åˆ›å»ºåŸºç¡€UCCæ–‡ä»¶ç»“æ„
            // æœ€å°UCCæ–‡ä»¶å¤§å°çº¦ä¸º127å­—èŠ‚çš„å¤´éƒ¨ + 20000 * 200å­—èŠ‚çš„æ•°æ®åŒºåŸŸ
            const headerSize = 127;
            const maxObjects = 10000;
            const objectSize = 200; // æ¯ä¸ªç‰©ä½“200å­—èŠ‚
            const totalSize = headerSize + (maxObjects * objectSize);
            
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            
            // å†™å…¥UCCæ–‡ä»¶å¤´ (ç®€åŒ–ç‰ˆæœ¬)
            // è¿™é‡Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæœ€å°çš„æœ‰æ•ˆUCCå¤´éƒ¨
            const header = new Uint8Array([
                0x55, 0x43, 0x43, 0x20, // "UCC "
                0x01, 0x00, 0x00, 0x00, // ç‰ˆæœ¬
                0x00, 0x00, 0x00, 0x00, // ä¿ç•™å­—æ®µ
                0x7F, 0x00, 0x00, 0x00  // æ•°æ®å¼€å§‹åç§» (127)
            ]);
            
            // å¤åˆ¶å¤´éƒ¨åˆ°ç¼“å†²åŒº
            const headerView = new Uint8Array(buffer, 0, header.length);
            headerView.set(header);
            
            // å¡«å……å‰©ä½™å¤´éƒ¨ä¸ºé›¶
            for (let i = header.length; i < headerSize; i++) {
                view.setUint8(i, 0);
            }
            
            return buffer;
        }

        // åº”ç”¨å›´ç»•ä¸­å¿ƒç‚¹çš„Zè½´æ—‹è½¬
        function applyCenterRotation(cubes, zAngleDegrees) {
            if (cubes.length === 0) return;
            
            // è®¡ç®—æ‰€æœ‰ç«‹æ–¹ä½“çš„ä¸­å¿ƒç‚¹
            let centerX = 0, centerY = 0, centerZ = 0;
            for (const cube of cubes) {
                centerX += cube.x;
                centerY += cube.y;
                centerZ += cube.z;
            }
            centerX /= cubes.length;
            centerY /= cubes.length;
            centerZ /= cubes.length;
            
            console.log(`ä¸­å¿ƒç‚¹: (${centerX.toFixed(2)}, ${centerY.toFixed(2)}, ${centerZ.toFixed(2)})`);
            
            // è½¬æ¢è§’åº¦ä¸ºå¼§åº¦
            const zAngleRad = zAngleDegrees * Math.PI / 180;
            const cos = Math.cos(zAngleRad);
            const sin = Math.sin(zAngleRad);
            
            // åˆ›å»ºZè½´æ—‹è½¬å››å…ƒæ•°
            const rotationQuat = {
                x: 0,
                y: 0,
                z: Math.sin(zAngleRad / 2),
                w: Math.cos(zAngleRad / 2)
            };
            
            // å¯¹æ¯ä¸ªç«‹æ–¹ä½“åº”ç”¨æ—‹è½¬
            for (const cube of cubes) {
                // è®¡ç®—ç›¸å¯¹äºä¸­å¿ƒç‚¹çš„åç§»
                const offsetX = cube.x - centerX;
                const offsetY = cube.y - centerY;
                
                // åº”ç”¨æ—‹è½¬åˆ°åç§»å‘é‡
                const rotatedX = offsetX * cos - offsetY * sin;
                const rotatedY = offsetX * sin + offsetY * cos;
                
                // æ›´æ–°ä½ç½®
                cube.x = centerX + rotatedX;
                cube.y = centerY + rotatedY;
                
                // åº”ç”¨æ—‹è½¬åˆ°ç‰©ä½“çš„æœå‘ï¼ˆå››å…ƒæ•°ä¹˜æ³•ï¼‰
                const currentQuat = {
                    x: cube.rotationX,
                    y: cube.rotationY,
                    z: cube.rotationZ,
                    w: cube.rotationW
                };
                
                const newQuat = multiplyQuaternions(rotationQuat, currentQuat);
                cube.rotationX = newQuat.x;
                cube.rotationY = newQuat.y;
                cube.rotationZ = newQuat.z;
                cube.rotationW = newQuat.w;
            }
            
            console.log(`å·²å¯¹ ${cubes.length} ä¸ªç«‹æ–¹ä½“åº”ç”¨ ${zAngleDegrees}Â° Zè½´æ—‹è½¬`);
        }

        // å››å…ƒæ•°ä¹˜æ³•
        function multiplyQuaternions(q1, q2) {
            return {
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
            };
        }

        // å°†ç«‹æ–¹ä½“æ•°æ®å†™å…¥UCCæ–‡ä»¶
        function writeObjectsToUCC(templateBuffer, cubes, options) {
            const buffer = templateBuffer.slice(); // åˆ›å»ºå‰¯æœ¬
            const view = new DataView(buffer);
            
            const headerSize = 127;
            const objectSize = 200;
            const maxObjects = Math.min(cubes.length, 10000);
            
            console.log(`å†™å…¥ ${maxObjects} ä¸ªç‰©ä½“åˆ°UCCæ–‡ä»¶`);
            
            // å†™å…¥æ¯ä¸ªç«‹æ–¹ä½“çš„æ•°æ®
            for (let i = 0; i < maxObjects; i++) {
                const cube = cubes[i];
                const baseIndex = headerSize + (i * objectSize);
                
                // è½¬æ¢åæ ‡ç³»ç»Ÿï¼ˆWebåæ ‡åˆ°UCCåæ ‡ï¼‰
                const uccX = cube.x * 35 * options.positionMultiplier;
                const uccY = cube.y * 35 * options.positionMultiplier;
                const uccZ = cube.z * 35 * options.positionMultiplier;
                
                // å¤„ç†ç¼©æ”¾
                let scaleX = cube.scaleX * options.scaleMultiplier;
                let scaleY = cube.scaleY * options.scaleMultiplier;
                let scaleZ = cube.scaleZ * options.scaleMultiplier;
                
                if (options.autoConvertNegative) {
                    scaleX = Math.abs(scaleX);
                    scaleY = Math.abs(scaleY);
                    scaleZ = Math.abs(scaleZ);
                }
                
                // å†™å…¥åæ ‡ (12å­—èŠ‚)
                const coordStart = baseIndex;
                view.setFloat32(coordStart, uccX, true);      // Xåæ ‡
                view.setFloat32(coordStart + 4, uccY, true);  // Yåæ ‡
                view.setFloat32(coordStart + 8, uccZ, true);  // Zåæ ‡
                
                // å†™å…¥æ—‹è½¬ (16å­—èŠ‚ï¼Œå››å…ƒæ•°XYZW)
                const rotationStart = baseIndex + 12;
                view.setFloat32(rotationStart, cube.rotationX, true);     // X
                view.setFloat32(rotationStart + 4, cube.rotationY, true); // Y
                view.setFloat32(rotationStart + 8, cube.rotationZ, true); // Z
                view.setFloat32(rotationStart + 12, cube.rotationW, true); // W
                
                // å†™å…¥å°ºå¯¸åˆ†éš”ç¬¦å’Œå°ºå¯¸ (4 + 12å­—èŠ‚)
                const sizeStart = baseIndex + 28;
                // å°ºå¯¸åˆ†éš”ç¬¦
                view.setUint8(sizeStart, 0x00);
                view.setUint8(sizeStart + 1, 0x00);
                view.setUint8(sizeStart + 2, 0x80);
                view.setUint8(sizeStart + 3, 0x3F);
                
                // å°ºå¯¸æ•°æ®
                view.setFloat32(sizeStart + 4, scaleX, true);  // Xå°ºå¯¸
                view.setFloat32(sizeStart + 8, scaleY, true);  // Yå°ºå¯¸
                view.setFloat32(sizeStart + 12, scaleZ, true); // Zå°ºå¯¸
                
                // å†™å…¥ç‰©ä½“åç§° (ä»44å­—èŠ‚å¼€å§‹)
                const nameStart = baseIndex + 44;
                const nameBytes = new TextEncoder().encode(cube.name);
                const maxNameLength = Math.min(nameBytes.length, 155); // é¢„ç•™ç©ºé—´
                
                for (let j = 0; j < maxNameLength; j++) {
                    view.setUint8(nameStart + j, nameBytes[j]);
                }
                // åç§°ç»“æŸç¬¦
                if (nameStart + maxNameLength < buffer.byteLength) {
                    view.setUint8(nameStart + maxNameLength, 0);
                }
            }
            
            // æ¸…é›¶å‰©ä½™çš„ç‰©ä½“ä½ç½®
            for (let i = maxObjects; i < 10000; i++) {
                const baseIndex = headerSize + (i * objectSize);
                if (baseIndex + objectSize <= buffer.byteLength) {
                    // æ¸…é›¶æ•´ä¸ªç‰©ä½“æ•°æ®åŒºåŸŸ
                    for (let j = 0; j < objectSize; j++) {
                        view.setUint8(baseIndex + j, 0);
                    }
                    
                    // è®¾ç½®é»˜è®¤æ—‹è½¬å››å…ƒæ•° (0, 0, 0, 1)
                    const rotationStart = baseIndex + 12;
                    view.setFloat32(rotationStart + 12, 1.0, true); // W = 1
                }
            }
            
            console.log('UCCæ–‡ä»¶æ•°æ®å†™å…¥å®Œæˆ');
            return buffer;
        }
        
        // æ‰¾åˆ°æœ€ä½³çš„é—¨ä½ç½®
        function findBestDoorPosition(room, floor) {
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0, score: 0 }, // å·¦
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0, score: 0 }, // å³
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1, score: 0 }, // ä¸Š
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1, score: 0 } // ä¸‹
            ];
            
            // ä¸ºæ¯ä¸ªä½ç½®è¯„åˆ†
            for (let side of sides) {
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    
                    // æ£€æŸ¥é—¨å¤–æ˜¯å¦æœ‰ç©ºåœ°
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        side.score += 10;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é è¿‘å…¶ä»–æˆ¿é—´
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = -3; dx <= 3; dx++) {
                            const nx = corridorX + dx;
                            const ny = corridorY + dy;
                            if (nx >= 0 && nx < mapFloors[floor][0].length && 
                                ny >= 0 && ny < mapFloors[floor].length) {
                                if (mapFloors[floor][ny][nx] === TileType.FLOOR) {
                                    side.score += 5;
                                }
                            }
                        }
                    }
                }
            }
            
            // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„ä½ç½®
            sides.sort((a, b) => b.score - a.score);
            return sides[0].score > 0 ? sides[0] : null;
        }
        
        // åˆ›å»ºè¿ç»­æ°´åŸŸåŒºåŸŸ
        function createWaterAreas(waterAmount) {
            const mapSize = mapFloors[0].length;
            const waterCount = Math.floor(mapSize * mapSize * waterAmount / 1000);
            
            // åˆ›å»ºå¤šä¸ªæ°´åŸŸåŒºåŸŸ
            const waterAreas = Math.max(1, Math.floor(waterCount / 50)); // æ ¹æ®æ°´åŸŸæ•°é‡å†³å®šåŒºåŸŸæ•°é‡
            
            for (let area = 0; area < waterAreas; area++) {
                // éšæœºé€‰æ‹©æ°´åŸŸèµ·å§‹ç‚¹
                let startX, startY;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    startX = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    startY = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    (startX < 0 || startX >= mapSize || startY < 0 || startY >= mapSize ||
                     !mapFloors[0][startY] || mapFloors[0][startY][startX] === undefined ||
                     (mapFloors[0][startY][startX] !== TileType.FLOOR &&
                      mapFloors[0][startY][startX] !== TileType.MEDIUM_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.HIGH_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.LOW_GROUND))
                );
                
                if (attempts >= maxAttempts) continue;
                
                // ä½¿ç”¨æ´ªæ°´å¡«å……ç®—æ³•åˆ›å»ºè¿ç»­æ°´åŸŸ
                const areaSize = Math.floor(waterCount / waterAreas);
                floodFillWater(startX, startY, areaSize);
            }
        }
        
        // æ´ªæ°´å¡«å……ç®—æ³•åˆ›å»ºæ°´åŸŸ
        function floodFillWater(startX, startY, maxSize) {
            const queue = [{x: startX, y: startY}];
            const visited = new Set();
            let filledCount = 0;
            
            while (queue.length > 0 && filledCount < maxSize) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                                        // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦é€‚åˆæ”¾ç½®æ°´åŸŸ
                        if (current.x >= 0 && current.x < mapFloors[0][0].length &&
                            current.y >= 0 && current.y < mapFloors[0].length &&
                            mapFloors[0][current.y] && mapFloors[0][current.y][current.x] !== undefined) {
                            
                            if (mapFloors[0][current.y][current.x] === TileType.FLOOR ||
                                mapFloors[0][current.y][current.x] === TileType.MEDIUM_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.HIGH_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.LOW_GROUND) {
                                
                                // æ”¾ç½®æ°´åŸŸ
                                mapFloors[0][current.y][current.x] = TileType.WATER;
                        filledCount++;
                        
                        // æ·»åŠ ç›¸é‚»ä½ç½®åˆ°é˜Ÿåˆ—
                        const directions = [
                            {dx: -1, dy: 0}, {dx: 1, dy: 0},
                            {dx: 0, dy: -1}, {dx: 0, dy: 1}
                        ];
                        
                        for (const dir of directions) {
                            const nextX = current.x + dir.dx;
                            const nextY = current.y + dir.dy;
                            const nextKey = `${nextX},${nextY}`;
                            
                            if (!visited.has(nextKey) && 
                                nextX >= 0 && nextX < mapFloors[0][0].length &&
                                nextY >= 0 && nextY < mapFloors[0].length) {
                                
                                // éšæœºå†³å®šæ˜¯å¦ç»§ç»­æ‰©å±•ï¼ˆåˆ›å»ºè‡ªç„¶å½¢çŠ¶ï¼‰
                                if (Math.random() < 0.7) { // 70%æ¦‚ç‡ç»§ç»­æ‰©å±•
                                    queue.push({x: nextX, y: nextY});
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // ç§å­ç³»ç»Ÿ
        let savedSeeds = [];
        let currentSeed = null;
        
        // ç”Ÿæˆå½“å‰å‚æ•°çš„å”¯ä¸€ç§å­
        function generateSeed() {
            const params = {
                mapSizeX: document.getElementById('mapSizeX').value,
                mapSizeY: document.getElementById('mapSizeY').value,
                floorCount: document.getElementById('floorCount').value,
                roomCount: document.getElementById('roomCount').value,
                roomSize: document.getElementById('roomSize').value,
                roomPosition: document.getElementById('roomPosition').value,
                corridorWidth: document.getElementById('corridorWidth').value,
                pathComplexity: document.getElementById('pathComplexity').value,
                corridorRandom: document.getElementById('corridorRandom').value,
                coverDensity: document.getElementById('coverDensity').value,
                waterAmount: document.getElementById('waterAmount').value,
                stairsCount: document.getElementById('stairsCount').value,
                windowDensity: document.getElementById('windowDensity').value,
                elevation: document.getElementById('elevation').value,
                longLanes: document.getElementById('longLanes').value,
                midControl: document.getElementById('midControl').value,
                rotateTime: document.getElementById('rotateTime').value,
                verticality: document.getElementById('verticality').value,
                breakables: document.getElementById('breakables').value,
                fieldLayout: document.getElementById('fieldLayout').value,
                gameMode: document.getElementById('gameMode').value,
                mapStyle: document.getElementById('mapStyle').value,
                outdoorRatio: document.getElementById('outdoorRatio').value,
                outdoorWall: document.getElementById('outdoorWall').checked,
                generateLobby: document.getElementById('generateLobby').value,
                nadeSpots: document.getElementById('nadeSpots').value,
                // å¸¸è§åœ°å½¢/æ¨¡å—å‚æ•°
                longLane: document.getElementById('longLane').value,
                shortLane: document.getElementById('shortLane').value,
                midLane: document.getElementById('midLane').value,
                platform: document.getElementById('platform').value,
                underpass: document.getElementById('underpass').value,
                connector: document.getElementById('connector').value,
                ramp: document.getElementById('ramp').value,
                rotation: document.getElementById('rotation').value,
                bombSiteCount: document.getElementById('bombSiteCount').value,
                shadowPoint: document.getElementById('shadowPoint').value,
                roomFill: document.getElementById('roomFill').value
            };
            
            // åˆ›å»ºç§å­å­—ç¬¦ä¸²
            const seedString = JSON.stringify(params);
            return btoa(seedString).substring(0, 16); // å–å‰16ä½ä½œä¸ºç§å­
        }
        
        // ä¿å­˜å½“å‰ç§å­
        function saveCurrentSeed() {
            const seed = generateSeed();
            const seedName = prompt('è¯·è¾“å…¥ç§å­åç§°:', `ç§å­_${new Date().toLocaleDateString()}`);
            
            if (!seedName) return;
            
            const seedData = {
                id: Date.now(),
                name: seedName,
                seed: seed,
                date: new Date().toISOString(),
                params: {
                    mapSizeX: document.getElementById('mapSizeX').value,
                    mapSizeY: document.getElementById('mapSizeY').value,
                    floorCount: document.getElementById('floorCount').value,
                    roomCount: document.getElementById('roomCount').value,
                    roomSize: document.getElementById('roomSize').value,
                    roomPosition: document.getElementById('roomPosition').value,
                    corridorWidth: document.getElementById('corridorWidth').value,
                    pathComplexity: document.getElementById('pathComplexity').value,
                    corridorRandom: document.getElementById('corridorRandom').value,
                    coverDensity: document.getElementById('coverDensity').value,
                    waterAmount: document.getElementById('waterAmount').value,
                    stairsCount: document.getElementById('stairsCount').value,
                    windowDensity: document.getElementById('windowDensity').value,
                    elevation: document.getElementById('elevation').value,
                    longLanes: document.getElementById('longLanes').value,
                    midControl: document.getElementById('midControl').value,
                    rotateTime: document.getElementById('rotateTime').value,
                    verticality: document.getElementById('verticality').value,
                    breakables: document.getElementById('breakables').value,
                    fieldLayout: document.getElementById('fieldLayout').value,
                    gameMode: document.getElementById('gameMode').value,
                    mapStyle: document.getElementById('mapStyle').value,
                    outdoorRatio: document.getElementById('outdoorRatio').value,
                    outdoorWall: document.getElementById('outdoorWall').checked,
                    generateLobby: document.getElementById('generateLobby').value,
                    nadeSpots: document.getElementById('nadeSpots').value,
                    longLane: document.getElementById('longLane').value,
                    shortLane: document.getElementById('shortLane').value,
                    midLane: document.getElementById('midLane').value,
                    platform: document.getElementById('platform').value,
                    underpass: document.getElementById('underpass').value,
                    connector: document.getElementById('connector').value,
                    ramp: document.getElementById('ramp').value,
                    rotation: document.getElementById('rotation').value,
                    bombSiteCount: document.getElementById('bombSiteCount').value,
                    shadowPoint: document.getElementById('shadowPoint').value,
                    roomFill: document.getElementById('roomFill').value
                }
            };
            
            savedSeeds.push(seedData);
            saveSeedsToStorage();
            renderSeedsList();
        }
        
        // åº”ç”¨ç§å­å‚æ•°
        function applySeed(seedData) {
            const params = seedData.params;
            
            // åº”ç”¨æ‰€æœ‰å‚æ•°
            Object.keys(params).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = params[key];
                    
                    // è§¦å‘oninputäº‹ä»¶ä»¥æ›´æ–°æ˜¾ç¤ºå€¼
                    if (element.oninput) {
                        element.oninput();
                    }
                }
            });
            
            // ç‰¹æ®Šå¤„ç†ä¸‹æ‹‰èœå•
            if (params.gameMode) {
                document.getElementById('gameMode').value = params.gameMode;
                applyGameMode(params.gameMode);
            }
            
            if (params.mapStyle) {
                document.getElementById('mapStyle').value = params.mapStyle;
                applyMapStyle(params.mapStyle);
            }
            
            // é‡æ–°ç”Ÿæˆåœ°å›¾
            generateMap();
        }
        
        // åˆ é™¤ç§å­
        function deleteSeed(seedId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç§å­å—ï¼Ÿ')) {
                savedSeeds = savedSeeds.filter(seed => seed.id !== seedId);
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // æ¸…ç©ºæ‰€æœ‰ç§å­
        function clearAllSeeds() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç§å­å—ï¼Ÿ')) {
                savedSeeds = [];
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // åˆ‡æ¢ç§å­é¢æ¿æ˜¾ç¤º/éšè—
        function toggleSeedsPanel() {
            const panel = document.querySelector('.seeds-panel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }
        
        // éšè—ç§å­é¢æ¿
        function hideSeedsPanel() {
            const panel = document.querySelector('.seeds-panel');
            panel.style.display = 'none';
        }
        
        // æ˜¾ç¤ºç§å­é¢æ¿
        function showSeedsPanel() {
            const panel = document.querySelector('.seeds-panel');
            panel.style.display = 'block';
        }
        
        // æ¸²æŸ“ç§å­åˆ—è¡¨
        function renderSeedsList() {
            const seedsList = document.getElementById('seedsList');
            seedsList.innerHTML = '';
            
            if (savedSeeds.length === 0) {
                seedsList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">æš‚æ— æ”¶è—çš„ç§å­</div>';
                return;
            }
            
            savedSeeds.forEach(seed => {
                const seedItem = document.createElement('div');
                seedItem.className = 'seed-item';
                
                const date = new Date(seed.date);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString().substring(0, 5);
                
                // åˆ›å»ºå‚æ•°æ‘˜è¦
                const paramSummary = [
                    `å°ºå¯¸: ${seed.params.mapSizeX || seed.params.mapSize || '60'} x ${seed.params.mapSizeY || seed.params.mapSize || '60'}`,
                    `å±‚æ•°: ${seed.params.floorCount}`,
                    `æˆ¿é—´: ${seed.params.roomCount}`,
                    `æ©ä½“: ${seed.params.coverDensity}%`,
                    `æ°´åŸŸ: ${seed.params.waterAmount}%`
                ].join(' | ');
                
                seedItem.innerHTML = `
                    <div class="seed-header">
                        <div class="seed-name">${seed.name}</div>
                        <div class="seed-date">${dateStr}</div>
                    </div>
                    <div class="seed-params">${paramSummary}</div>
                    <div class="seed-actions">
                        <button onclick="applySeed(${JSON.stringify(seed).replace(/"/g, '&quot;')})">åº”ç”¨</button>
                        <button class="delete" onclick="deleteSeed(${seed.id})">åˆ é™¤</button>
                    </div>
                `;
                
                seedsList.appendChild(seedItem);
            });
        }
        
        // ä¿å­˜ç§å­åˆ°æœ¬åœ°å­˜å‚¨
        function saveSeedsToStorage() {
            localStorage.setItem('mapGeneratorSeeds', JSON.stringify(savedSeeds));
        }
        
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½ç§å­
        function loadSeedsFromStorage() {
            const stored = localStorage.getItem('mapGeneratorSeeds');
            if (stored) {
                savedSeeds = JSON.parse(stored);
            }
        }
        
        // æ·»åŠ æˆ¿é—´å¡«å……ï¼ˆä½¿ç”¨è¿·å®«ç®—æ³•å¡«å……æˆ¿é—´ï¼‰
        function addRoomFilling(rooms, floor) {
            const roomFillDensity = parseInt(document.getElementById('roomFill').value);
            if (roomFillDensity === 0) return; // æ— å¡«å……
            
            const densityMultiplier = [0, 0.3, 0.6, 1.0, 1.5][roomFillDensity]; // å¯†åº¦å€æ•°
            console.log(`æ¥¼å±‚${floor}æˆ¿é—´å¡«å……å¯†åº¦: ${roomFillDensity}, å€æ•°: ${densityMultiplier}`);
            
            let totalFilledRooms = 0;
            const maxFillRooms = Math.min(20, rooms.length); // é™åˆ¶æœ€å¤§å¡«å……æˆ¿é—´æ•°
            let processedRooms = 0;
            
            for (let room of rooms) {
                if (processedRooms >= maxFillRooms) break; // é™åˆ¶å¤„ç†æ•°é‡
                
                // è·³è¿‡å¤ªå°çš„æˆ¿é—´æˆ–è¿‡å¤§çš„æˆ¿é—´ï¼ˆé¿å…æ€§èƒ½é—®é¢˜ï¼‰
                if (room.width < 8 || room.height < 8 || room.width > 50 || room.height > 50) continue;
                
                // æ ¹æ®å¯†åº¦å†³å®šæ˜¯å¦å¡«å……è¿™ä¸ªæˆ¿é—´
                if (Math.random() < densityMultiplier) {
                    console.log(`æˆ¿é—´(${room.x},${room.y},${room.width}x${room.height}) ä½¿ç”¨è¿·å®«å¡«å……ï¼Œå¯†åº¦: ${roomFillDensity}`);
                    
                    if (createMazeInRoom(room, floor, roomFillDensity)) {
                        totalFilledRooms++;
                    }
                }
                processedRooms++;
            }
            
            console.log(`æ¥¼å±‚${floor}æ€»å…±å¡«å……äº†${totalFilledRooms}ä¸ªè¿·å®«æˆ¿é—´`);
        }
        
        // åœ¨æˆ¿é—´å†…éƒ¨åˆ›å»ºè¿·å®«
        function createMazeInRoom(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2; // ç•™å‡ºè¾¹è·
            const roomHeight = parentRoom.height - 2;
            
            if (roomWidth < 4 || roomHeight < 4) return false;
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´è¿·å®«ç½‘æ ¼å¤§å°
            const densityFactors = [0, 1.5, 1.2, 1.0, 0.8]; // å¯†åº¦è¶Šé«˜ï¼Œç½‘æ ¼è¶Šå°ï¼ˆæ›´å¯†é›†ï¼‰
            const gridSizeFactor = densityFactors[density];
            
            // è®¡ç®—è¿·å®«ç½‘æ ¼å¤§å°ï¼ˆæ ¹æ®å¯†åº¦è°ƒæ•´ï¼‰
            const baseMazeWidth = Math.floor(roomWidth / 2);
            const baseMazeHeight = Math.floor(roomHeight / 2);
            const mazeWidth = Math.max(2, Math.floor(baseMazeWidth * gridSizeFactor));
            const mazeHeight = Math.max(2, Math.floor(baseMazeHeight * gridSizeFactor));
            
            console.log(`è¿·å®«ç½‘æ ¼: ${mazeWidth}x${mazeHeight}, å¯†åº¦: ${density}, ç½‘æ ¼å› å­: ${gridSizeFactor}`);
            
            // åˆ›å»ºè¿·å®«ç½‘æ ¼
            const maze = createMazeGrid(mazeWidth, mazeHeight, density);
            
            // å°†è¿·å®«åº”ç”¨åˆ°æˆ¿é—´ä¸­
            applyMazeToRoom(maze, parentRoom, floor, density);
            
            // åˆ›å»ºå…¥å£å’Œå‡ºå£
            createMazeEntrances(parentRoom, floor, density);
            
            return true;
        }
        
        // åˆ›å»ºè¿·å®«ç½‘æ ¼ï¼ˆä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼‰
        function createMazeGrid(width, height, density) {
            // åˆå§‹åŒ–è¿·å®«ç½‘æ ¼ï¼Œæ‰€æœ‰å¢™éƒ½æ˜¯å°é—­çš„
            const maze = [];
            for (let y = 0; y < height * 2 + 1; y++) {
                maze[y] = [];
                for (let x = 0; x < width * 2 + 1; x++) {
                    maze[y][x] = 1; // 1è¡¨ç¤ºå¢™ï¼Œ0è¡¨ç¤ºé€šé“
                }
            }
            
            // ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆè¿·å®«
            const stack = [];
            const visited = new Set();
            
            // ä»å·¦ä¸Šè§’å¼€å§‹
            const startX = 1;
            const startY = 1;
            stack.push([startX, startY]);
            visited.add(`${startX},${startY}`);
            maze[startY][startX] = 0;
            
            const directions = [
                [0, -2], // ä¸Š
                [2, 0],  // å³
                [0, 2],  // ä¸‹
                [-2, 0]  // å·¦
            ];
            
            while (stack.length > 0) {
                const [currentX, currentY] = stack[stack.length - 1];
                
                // éšæœºæ‰“ä¹±æ–¹å‘
                const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                
                let moved = false;
                for (const [dx, dy] of shuffledDirections) {
                    const newX = currentX + dx;
                    const newY = currentY + dy;
                    
                    if (newX >= 1 && newX < width * 2 && newY >= 1 && newY < height * 2) {
                        const key = `${newX},${newY}`;
                        if (!visited.has(key)) {
                            // æ‰“é€šå¢™å£
                            maze[currentY + dy/2][currentX + dx/2] = 0;
                            maze[newY][newX] = 0;
                            
                            visited.add(key);
                            stack.push([newX, newY]);
                            moved = true;
                            break;
                        }
                    }
                }
                
                if (!moved) {
                    stack.pop();
                }
            }
            
            // æ ¹æ®å¯†åº¦æ·»åŠ é¢å¤–çš„å¢™å£ï¼ˆå¢åŠ è¿·å®«å¤æ‚åº¦ï¼‰
            addDensityWalls(maze, width, height, density);
            
            return maze;
        }
        
        // æ ¹æ®å¯†åº¦æ·»åŠ é¢å¤–çš„å¢™å£
        function addDensityWalls(maze, width, height, density) {
            const densityFactors = [0, 0.1, 0.2, 0.3, 0.5]; // å¯†åº¦è¶Šé«˜ï¼Œé¢å¤–å¢™å£è¶Šå¤š
            const extraWallChance = densityFactors[density];
            
            if (extraWallChance === 0) return;
            
            const totalCells = width * height;
            const extraWalls = Math.floor(totalCells * extraWallChance);
            
            console.log(`æ·»åŠ ${extraWalls}ä¸ªé¢å¤–å¢™å£ï¼Œå¯†åº¦: ${density}, æ¦‚ç‡: ${extraWallChance}`);
            
            for (let i = 0; i < extraWalls; i++) {
                // éšæœºé€‰æ‹©ä½ç½®æ·»åŠ å¢™å£
                const x = 1 + Math.floor(Math.random() * (width - 1)) * 2;
                const y = 1 + Math.floor(Math.random() * (height - 1)) * 2;
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ·»åŠ å¢™å£ï¼ˆä¸ä¼šå®Œå…¨å°é—­åŒºåŸŸï¼‰
                if (canAddWall(maze, x, y)) {
                    maze[y][x] = 1;
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ·»åŠ å¢™å£
        function canAddWall(maze, x, y) {
            // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰è¶³å¤Ÿçš„é€šé“
            let channelCount = 0;
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length) {
                    if (maze[ny][nx] === 0) {
                        channelCount++;
                    }
                }
            }
            
            // ç¡®ä¿è‡³å°‘æœ‰ä¸¤ä¸ªé€šé“è¿æ¥
            return channelCount >= 2;
        }
        
        // å°†è¿·å®«åº”ç”¨åˆ°æˆ¿é—´ä¸­
        function applyMazeToRoom(maze, parentRoom, floor, density) {
            const startX = parentRoom.x + 1;
            const startY = parentRoom.y + 1;
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´å¢™å£åšåº¦
            const wallThickness = Math.max(1, Math.floor(density / 2)); // å¯†åº¦è¶Šé«˜ï¼Œå¢™å£è¶Šåš
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    const worldX = startX + x;
                    const worldY = startY + y;
                    
                    if (worldX >= 0 && worldX < mapFloors[floor][0].length && 
                        worldY >= 0 && worldY < mapFloors[floor].length) {
                        if (mapFloors[floor][worldY] && mapFloors[floor][worldY][worldX] !== undefined) {
                            if (maze[y][x] === 1) {
                                // å¢™å£ï¼ˆæ ¹æ®å¯†åº¦è°ƒæ•´åšåº¦ï¼‰
                                for (let wy = 0; wy < wallThickness; wy++) {
                                    for (let wx = 0; wx < wallThickness; wx++) {
                                        const thickX = worldX + wx;
                                        const thickY = worldY + wy;
                                        if (thickX >= 0 && thickX < mapFloors[floor][0].length && 
                                            thickY >= 0 && thickY < mapFloors[floor].length) {
                                            if (mapFloors[floor][thickY] && mapFloors[floor][thickY][thickX] !== undefined) {
                                                mapFloors[floor][thickY][thickX] = TileType.WALL;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // é€šé“
                                mapFloors[floor][worldY][worldX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
            
            console.log(`è¿·å®«å¢™å£åšåº¦: ${wallThickness}, å¯†åº¦: ${density}`);
        }
        
        // åˆ›å»ºè¿·å®«å…¥å£å’Œå‡ºå£
        function createMazeEntrances(parentRoom, floor, density) {
            const roomWidth = parentRoom.width;
            const roomHeight = parentRoom.height;
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´å…¥å£æ•°é‡
            const entranceCount = Math.min(4, Math.max(1, Math.floor(density / 2) + 1));
            
            // åˆ›å»ºå¤šä¸ªå…¥å£ï¼ˆæ ¹æ®å¯†åº¦ï¼‰
            for (let e = 0; e < entranceCount; e++) {
                // éšæœºé€‰æ‹©å…¥å£ä½ç½®ï¼ˆæˆ¿é—´è¾¹ç¼˜ï¼‰
                const entranceSide = Math.floor(Math.random() * 4);
                let entranceX, entranceY;
                
                switch (entranceSide) {
                    case 0: // ä¸Šè¾¹
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y;
                        break;
                    case 1: // å³è¾¹
                        entranceX = parentRoom.x + roomWidth - 1;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                    case 2: // ä¸‹è¾¹
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y + roomHeight - 1;
                        break;
                    case 3: // å·¦è¾¹
                        entranceX = parentRoom.x;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                }
                
                // åˆ›å»ºå…¥å£é—¨
                if (entranceX >= 0 && entranceX < mapFloors[floor][0].length && 
                    entranceY >= 0 && entranceY < mapFloors[floor].length) {
                    if (mapFloors[floor][entranceY] && mapFloors[floor][entranceY][entranceX] !== undefined) {
                        mapFloors[floor][entranceY][entranceX] = TileType.DOOR;
                    }
                }
            }
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´å†…éƒ¨é—¨æ•°é‡
            const internalDoorCount = Math.min(5, Math.max(1, density + 1));
            for (let i = 0; i < internalDoorCount; i++) {
                createRandomInternalDoor(parentRoom, floor, density);
            }
            
            console.log(`è¿·å®«å…¥å£æ•°é‡: ${entranceCount}, å†…éƒ¨é—¨æ•°é‡: ${internalDoorCount}, å¯†åº¦: ${density}`);
        }
        
        // åˆ›å»ºéšæœºå†…éƒ¨é—¨
        function createRandomInternalDoor(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2;
            const roomHeight = parentRoom.height - 2;
            
            let attempts = 0;
            const maxAttempts = 30; // å¢åŠ å°è¯•æ¬¡æ•°
            
            while (attempts < maxAttempts) {
                const x = parentRoom.x + 1 + Math.floor(Math.random() * roomWidth);
                const y = parentRoom.y + 1 + Math.floor(Math.random() * roomHeight);
                
                if (x >= 0 && x < mapFloors[floor][0].length && 
                    y >= 0 && y < mapFloors[floor].length) {
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        if (mapFloors[floor][y][x] === TileType.WALL) {
                            // æ ¹æ®å¯†åº¦å†³å®šæ˜¯å¦åˆ›å»ºé—¨ï¼ˆå¯†åº¦è¶Šé«˜ï¼Œè¶Šå®¹æ˜“åˆ›å»ºé—¨ï¼‰
                            const doorChance = 0.3 + (density * 0.15); // 30% + å¯†åº¦*15%
                            if (Math.random() < doorChance) {
                                mapFloors[floor][y][x] = TileType.DOOR;
                                return;
                            }
                        }
                    }
                }
                attempts++;
            }
        }
        
        // æ·»åŠ æš—é“
        function addUnderpass(rooms, density) {
            if (!rooms || rooms.length === 0) return;
            
            const densityMultiplier = [0, 0.5, 1.0, 1.8, 3.0][density];
            const totalFloors = mapFloors.length;
            
            // ä¸ºæ¯å±‚ç”Ÿæˆæš—é“
            for (let floor = 0; floor < totalFloors; floor++) {
                const floorRooms = rooms.filter(room => room.floor === floor);
                if (floorRooms.length < 2) continue; // è‡³å°‘éœ€è¦2ä¸ªæˆ¿é—´æ‰èƒ½è¿æ¥
                
                const mapSize = mapFloors[floor].length;
                const underpassCount = Math.max(1, Math.floor(floorRooms.length * densityMultiplier / 2));
                
                console.log(`æ¥¼å±‚${floor}æš—é“å¯†åº¦: ${density}, å€æ•°: ${densityMultiplier}, ç›®æ ‡æ•°é‡: ${underpassCount}`);
                
                let createdCount = 0;
                let attempts = 0;
                const maxAttempts = underpassCount * 5;
                
                // è·å–å¯è¿æ¥çš„æˆ¿é—´å¯¹
                const connectableRoomPairs = findConnectableRoomPairs(floorRooms, floor);
                
                while (createdCount < underpassCount && attempts < maxAttempts && connectableRoomPairs.length > 0) {
                    attempts++;
                    
                    // éšæœºé€‰æ‹©ä¸€å¯¹æˆ¿é—´è¿›è¡Œè¿æ¥
                    const pairIndex = Math.floor(Math.random() * connectableRoomPairs.length);
                    const roomPair = connectableRoomPairs[pairIndex];
                    
                    if (createUnderpassBetweenRooms(roomPair.room1, roomPair.room2, floor)) {
                        createdCount++;
                        // ç§»é™¤å·²è¿æ¥çš„æˆ¿é—´å¯¹ï¼Œé¿å…é‡å¤è¿æ¥
                        connectableRoomPairs.splice(pairIndex, 1);
                    }
                }
                
                console.log(`æ¥¼å±‚${floor}å®é™…åˆ›å»ºæš—é“æ•°é‡: ${createdCount}`);
            }
        }
        
        // æ‰¾åˆ°å¯è¿æ¥çš„æˆ¿é—´å¯¹
        function findConnectableRoomPairs(rooms, floor) {
            const pairs = [];
            
            for (let i = 0; i < rooms.length; i++) {
                for (let j = i + 1; j < rooms.length; j++) {
                    const room1 = rooms[i];
                    const room2 = rooms[j];
                    
                    // è®¡ç®—æˆ¿é—´é—´è·ç¦»
                    const distance = Math.sqrt(
                        Math.pow(room1.x + room1.width/2 - room2.x - room2.width/2, 2) +
                        Math.pow(room1.y + room1.height/2 - room2.y - room2.height/2, 2)
                    );
                    
                    // åªè¿æ¥è·ç¦»é€‚ä¸­çš„æˆ¿é—´ï¼ˆä¸å¤ªè¿‘ä¹Ÿä¸å¤ªè¿œï¼‰
                    if (distance > 8 && distance < 25) {
                        // æ£€æŸ¥ä¸¤ä¸ªæˆ¿é—´ä¹‹é—´æ˜¯å¦å·²ç»æœ‰ç›´æ¥é€šé“è¿æ¥
                        if (!hasDirectPath(room1, room2, floor)) {
                            pairs.push({
                                room1: room1,
                                room2: room2,
                                distance: distance
                            });
                        }
                    }
                }
            }
            
            // æŒ‰è·ç¦»æ’åºï¼Œä¼˜å…ˆè¿æ¥è·ç¦»é€‚ä¸­çš„æˆ¿é—´
            pairs.sort((a, b) => a.distance - b.distance);
            
            return pairs;
        }
        
        // æ£€æŸ¥ä¸¤ä¸ªæˆ¿é—´æ˜¯å¦å·²æœ‰ç›´æ¥è·¯å¾„è¿æ¥
        function hasDirectPath(room1, room2, floor) {
            // ç®€åŒ–æ£€æŸ¥ï¼šå¦‚æœä¸¤ä¸ªæˆ¿é—´çš„è¾¹ç•Œç›¸é‚»æˆ–æ¥è¿‘ï¼Œè®¤ä¸ºå·²æœ‰è¿æ¥
            const room1Center = {x: room1.x + room1.width/2, y: room1.y + room1.height/2};
            const room2Center = {x: room2.x + room2.width/2, y: room2.y + room2.height/2};
            
            // æ£€æŸ¥ä¸¤ä¸ªæˆ¿é—´ä¸­å¿ƒç‚¹ä¹‹é—´çš„ç›´çº¿è·¯å¾„ä¸Šæ˜¯å¦éƒ½æ˜¯å¯é€šè¡ŒåŒºåŸŸ
            const dx = Math.abs(room2Center.x - room1Center.x);
            const dy = Math.abs(room2Center.y - room1Center.y);
            
            if (dx <= 3 && dy <= 3) {
                return true; // æˆ¿é—´å¾ˆè¿‘ï¼Œå¯èƒ½å·²ç»è¿æ¥
            }
            
            return false;
        }
        
        // åœ¨ä¸¤ä¸ªæˆ¿é—´ä¹‹é—´åˆ›å»ºæš—é“
        function createUnderpassBetweenRooms(room1, room2, floor) {
            // æ‰¾åˆ°æˆ¿é—´çš„æœ€ä½³è¿æ¥ç‚¹
            const connection = findBestConnectionPoints(room1, room2, floor);
            if (!connection) return false;
            
            // åˆ›å»ºæš—é“è·¯å¾„
            const path = createUnderpassPath(connection.start, connection.end, floor);
            if (path.length === 0) return false;
            
            // åœ¨è·¯å¾„ä¸Šåˆ›å»ºæš—é“
            for (const point of path) {
                if (point.x >= 0 && point.x < mapFloors[floor][0].length && 
                    point.y >= 0 && point.y < mapFloors[floor].length) {
                    const currentTile = mapFloors[floor][point.y][point.x];
                    
                    // åªåœ¨å¢™å£æˆ–ç©ºåœ°ä¸­åˆ›å»ºæš—é“
                    if (currentTile === TileType.WALL || currentTile === TileType.VOID) {
                        mapFloors[floor][point.y][point.x] = TileType.UNDERPASS;
                    }
                }
            }
            
            // åœ¨ä¸¤ç«¯åˆ›å»ºä¸æˆ¿é—´çš„è¿æ¥ç‚¹
            createRoomConnection(connection.start, room1, floor);
            createRoomConnection(connection.end, room2, floor);
            
            return true;
        }
        
        // æ‰¾åˆ°ä¸¤ä¸ªæˆ¿é—´çš„æœ€ä½³è¿æ¥ç‚¹
        function findBestConnectionPoints(room1, room2, floor) {
            const room1Center = {x: room1.x + room1.width/2, y: room1.y + room1.height/2};
            const room2Center = {x: room2.x + room2.width/2, y: room2.y + room2.height/2};
            
            // æ‰¾åˆ°æˆ¿é—´è¾¹ç¼˜çš„è¿æ¥ç‚¹
            let bestStart = null;
            let bestEnd = null;
            let minDistance = Infinity;
            
            // æ£€æŸ¥æˆ¿é—´1çš„è¾¹ç¼˜ç‚¹
            const room1Points = getRoomEdgePoints(room1);
            const room2Points = getRoomEdgePoints(room2);
            
            for (const p1 of room1Points) {
                for (const p2 of room2Points) {
                    const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestStart = p1;
                        bestEnd = p2;
                    }
                }
            }
            
            if (bestStart && bestEnd && minDistance > 5) { // ç¡®ä¿æœ‰è¶³å¤Ÿè·ç¦»åˆ›å»ºæš—é“
                return {start: bestStart, end: bestEnd};
            }
            
            return null;
        }
        
        // è·å–æˆ¿é—´è¾¹ç¼˜ç‚¹
        function getRoomEdgePoints(room) {
            const points = [];
            
            // æˆ¿é—´å››ä¸ªè¾¹çš„ä¸­ç‚¹
            points.push({x: room.x + room.width/2, y: room.y}); // ä¸Š
            points.push({x: room.x + room.width/2, y: room.y + room.height}); // ä¸‹
            points.push({x: room.x, y: room.y + room.height/2}); // å·¦
            points.push({x: room.x + room.width, y: room.y + room.height/2}); // å³
            
            // å››ä¸ªè§’ç‚¹
            points.push({x: room.x, y: room.y}); // å·¦ä¸Š
            points.push({x: room.x + room.width, y: room.y}); // å³ä¸Š
            points.push({x: room.x, y: room.y + room.height}); // å·¦ä¸‹
            points.push({x: room.x + room.width, y: room.y + room.height}); // å³ä¸‹
            
            return points.map(p => ({x: Math.floor(p.x), y: Math.floor(p.y)}));
        }
        
        // åˆ›å»ºæš—é“è·¯å¾„
        function createUnderpassPath(start, end, floor) {
            const path = [];
            
            // ä½¿ç”¨Lå½¢è·¯å¾„ï¼ˆå…ˆæ°´å¹³åå‚ç›´ï¼Œæˆ–å…ˆå‚ç›´åæ°´å¹³ï¼‰
            const useHorizontalFirst = Math.random() > 0.5;
            
            if (useHorizontalFirst) {
                // å…ˆæ°´å¹³ç§»åŠ¨
                const startX = Math.min(start.x, end.x);
                const endX = Math.max(start.x, end.x);
                for (let x = startX; x <= endX; x++) {
                    path.push({x: x, y: start.y});
                }
                
                // å†å‚ç›´ç§»åŠ¨
                const startY = Math.min(start.y, end.y);
                const endY = Math.max(start.y, end.y);
                for (let y = startY; y <= endY; y++) {
                    path.push({x: end.x, y: y});
                }
            } else {
                // å…ˆå‚ç›´ç§»åŠ¨
                const startY = Math.min(start.y, end.y);
                const endY = Math.max(start.y, end.y);
                for (let y = startY; y <= endY; y++) {
                    path.push({x: start.x, y: y});
                }
                
                // å†æ°´å¹³ç§»åŠ¨
                const startX = Math.min(start.x, end.x);
                const endX = Math.max(start.x, end.x);
                for (let x = startX; x <= endX; x++) {
                    path.push({x: x, y: end.y});
                }
            }
            
            return path;
        }
        
        // åˆ›å»ºæš—é“ä¸æˆ¿é—´çš„è¿æ¥
        function createRoomConnection(connectionPoint, room, floor) {
            // åœ¨è¿æ¥ç‚¹é™„è¿‘çš„æˆ¿é—´å†…åˆ›å»ºæš—é“å…¥å£
            const roomMinX = Math.max(0, room.x + 1);
            const roomMaxX = Math.min(mapFloors[floor][0].length - 1, room.x + room.width - 1);
            const roomMinY = Math.max(0, room.y + 1);
            const roomMaxY = Math.min(mapFloors[floor].length - 1, room.y + room.height - 1);
            
            // æ‰¾åˆ°æœ€æ¥è¿‘è¿æ¥ç‚¹çš„æˆ¿é—´å†…ä½ç½®
            let bestRoomPoint = null;
            let minDistance = Infinity;
            
            for (let y = roomMinY; y <= roomMaxY; y++) {
                for (let x = roomMinX; x <= roomMaxX; x++) {
                    const currentTile = mapFloors[floor][y][x];
                    if (currentTile === TileType.FLOOR || 
                        currentTile === TileType.MEDIUM_GROUND ||
                        currentTile === TileType.HIGH_GROUND ||
                        currentTile === TileType.LOW_GROUND) {
                        
                        const distance = Math.sqrt(
                            Math.pow(x - connectionPoint.x, 2) + 
                            Math.pow(y - connectionPoint.y, 2)
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestRoomPoint = {x: x, y: y};
                        }
                    }
                }
            }
            
            // åˆ›å»ºä»æš—é“åˆ°æˆ¿é—´çš„è¿æ¥é€šé“
            if (bestRoomPoint) {
                const dx = Math.abs(bestRoomPoint.x - connectionPoint.x);
                const dy = Math.abs(bestRoomPoint.y - connectionPoint.y);
                
                if (dx <= 2 && dy <= 2) {
                    // ç›´æ¥è¿æ¥
                    const connectX = Math.floor((bestRoomPoint.x + connectionPoint.x) / 2);
                    const connectY = Math.floor((bestRoomPoint.y + connectionPoint.y) / 2);
                    
                    if (connectX >= 0 && connectX < mapFloors[floor][0].length && 
                        connectY >= 0 && connectY < mapFloors[floor].length) {
                        mapFloors[floor][connectY][connectX] = TileType.UNDERPASS;
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”¾ç½®æš—é“
        function canPlaceUnderpass(x1, y1, x2, y2, floor) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            // æ£€æŸ¥æš—é“è·¯å¾„ä¸Šçš„æ¯ä¸ªä½ç½®
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (x < 0 || x >= mapFloors[floor][0].length || 
                        y < 0 || y >= mapFloors[floor].length) {
                        return false;
                    }
                    
                    const currentTile = mapFloors[floor][y][x];
                    // åªèƒ½åœ¨å¢™å£æˆ–ç©ºåœ°ä¸­åˆ›å»ºæš—é“
                    if (currentTile !== TileType.WALL && currentTile !== TileType.VOID) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // åˆ›å»ºæš—é“éš§é“
        function createUnderpassTunnel(x1, y1, x2, y2, floor) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            // åˆ›å»ºæš—é“é€šé“
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (x >= 0 && x < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length) {
                        mapFloors[floor][y][x] = TileType.UNDERPASS;
                    }
                }
            }
            
            // åœ¨æš—é“ä¸¤ç«¯åˆ›å»ºå…¥å£ï¼ˆè¿æ¥åˆ°é‚»è¿‘çš„å¯é€šè¡ŒåŒºåŸŸï¼‰
            const endpoints = [
                {x: x1, y: y1},
                {x: x2, y: y2}
            ];
            
            for (const endpoint of endpoints) {
                createUnderpassEntrance(endpoint.x, endpoint.y, floor);
            }
        }
        
        // åˆ›å»ºæš—é“å…¥å£
        function createUnderpassEntrance(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length) {
                    
                    const neighborTile = mapFloors[floor][ny][nx];
                    
                    // å¦‚æœé‚»è¿‘ä½ç½®æ˜¯å¯é€šè¡ŒåŒºåŸŸï¼Œåˆ›å»ºè¿æ¥
                    if (neighborTile === TileType.FLOOR || 
                        neighborTile === TileType.MEDIUM_GROUND ||
                        neighborTile === TileType.HIGH_GROUND ||
                        neighborTile === TileType.LOW_GROUND) {
                        
                        // åœ¨æš—é“å’Œå¯é€šè¡ŒåŒºåŸŸä¹‹é—´åˆ›å»ºè¿æ¥ç‚¹
                        const midX = Math.floor((x + nx) / 2);
                        const midY = Math.floor((y + ny) / 2);
                        
                        if (midX >= 0 && midX < mapFloors[floor][0].length && 
                            midY >= 0 && midY < mapFloors[floor].length) {
                            mapFloors[floor][midY][midX] = TileType.UNDERPASS;
                        }
                    }
                }
            }
        }
        
        // æ·»åŠ ç‹™å‡»é•¿é“
        function addLongLanes(rooms, count) {
            if (!rooms || rooms.length === 0 || count <= 0) return;
            
            console.log(`å¼€å§‹ç”Ÿæˆ${count}æ¡ç‹™å‡»é•¿é“`);
            
            let createdLanes = 0;
            const maxAttempts = count * 10;
            let attempts = 0;
            
            // ä¸ºæ¯å±‚å°è¯•ç”Ÿæˆé•¿é“
            for (let floor = 0; floor < totalFloors && createdLanes < count; floor++) {
                const floorRooms = rooms.filter(room => room.floor === floor);
                if (floorRooms.length < 2) continue;
                
                attempts = 0;
                while (createdLanes < count && attempts < maxAttempts) {
                    attempts++;
                    
                    // éšæœºé€‰æ‹©é•¿é“æ–¹å‘ï¼šæ°´å¹³æˆ–å‚ç›´
                    const isHorizontal = Math.random() > 0.5;
                    
                    if (createLongLane(floor, isHorizontal)) {
                        createdLanes++;
                        console.log(`æˆåŠŸåˆ›å»ºç¬¬${createdLanes}æ¡é•¿é“ (æ¥¼å±‚${floor}, ${isHorizontal ? 'æ°´å¹³' : 'å‚ç›´'})`);
                    }
                }
            }
            
            console.log(`æ€»å…±åˆ›å»ºäº†${createdLanes}æ¡ç‹™å‡»é•¿é“`);
        }
        
        // åˆ›å»ºå•æ¡ç‹™å‡»é•¿é“
        function createLongLane(floor, isHorizontal) {
            if (!mapFloors[floor]) return false;
            
            const mapHeight = mapFloors[floor].length;
            const mapWidth = mapFloors[floor][0] ? mapFloors[floor][0].length : 0;
            
            if (mapWidth === 0 || mapHeight === 0) return false;
            
            const minLength = 15; // æœ€å°é•¿é“é•¿åº¦
            const maxLength = Math.min(isHorizontal ? mapWidth - 10 : mapHeight - 10, 40); // æœ€å¤§é•¿åº¦
            
            if (maxLength < minLength) return false;
            
            const length = minLength + Math.floor(Math.random() * (maxLength - minLength));
            const width = 3; // é•¿é“å®½åº¦
            
            let startX, startY;
            
            if (isHorizontal) {
                // æ°´å¹³é•¿é“
                startX = Math.floor(Math.random() * (mapWidth - length - 5)) + 3;
                startY = Math.floor(Math.random() * (mapHeight - width - 5)) + 3;
                
                // æ£€æŸ¥åŒºåŸŸæ˜¯å¦å¯ç”¨
                if (!isAreaClearForLongLane(startX, startY, length, width, floor)) {
                    return false;
                }
                
                // åˆ›å»ºæ°´å¹³é•¿é“
                for (let x = startX; x < startX + length; x++) {
                    for (let y = startY; y < startY + width; y++) {
                        if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight && 
                            mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                            mapFloors[floor][y][x] = TileType.LONG_LANE;
                        }
                    }
                }
            } else {
                // å‚ç›´é•¿é“
                startX = Math.floor(Math.random() * (mapWidth - width - 5)) + 3;
                startY = Math.floor(Math.random() * (mapHeight - length - 5)) + 3;
                
                // æ£€æŸ¥åŒºåŸŸæ˜¯å¦å¯ç”¨
                if (!isAreaClearForLongLane(startX, startY, width, length, floor)) {
                    return false;
                }
                
                // åˆ›å»ºå‚ç›´é•¿é“
                for (let x = startX; x < startX + width; x++) {
                    for (let y = startY; y < startY + length; y++) {
                        if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight && 
                            mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                            mapFloors[floor][y][x] = TileType.LONG_LANE;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // æ£€æŸ¥åŒºåŸŸæ˜¯å¦å¯ä»¥æ”¾ç½®é•¿é“
        function isAreaClearForLongLane(startX, startY, width, height, floor) {
            if (!mapFloors[floor]) return false;
            
            const mapHeight = mapFloors[floor].length;
            const mapWidth = mapFloors[floor][0] ? mapFloors[floor][0].length : 0;
            
            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height; y++) {
                    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) {
                        return false;
                    }
                    
                    if (!mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                        return false;
                    }
                    
                    const currentTile = mapFloors[floor][y][x];
                    
                    // åªèƒ½åœ¨ç©ºåœ°ã€å¢™å£æˆ–åœ°æ¿ä¸Šå»ºé€ é•¿é“
                    if (currentTile !== TileType.VOID && 
                        currentTile !== TileType.WALL && 
                        currentTile !== TileType.FLOOR &&
                        currentTile !== TileType.MEDIUM_GROUND) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        
        // æ·»åŠ é˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
        function addShadowPoints(density, floor = 0) {
            const mapSize = mapFloors[floor].length;
            const densityMultiplier = [0, 0.3, 0.8, 1.5, 2.5][density]; // è°ƒæ•´å¯†åº¦å€æ•°ï¼Œä½¿é»˜è®¤å€¼æ›´æ˜æ˜¾
            const shadowPointCount = Math.max(1, Math.floor(mapSize * mapSize * densityMultiplier / 150)); // å¢åŠ åŸºç¡€æ•°é‡
            
            console.log(`æ¥¼å±‚${floor}é˜´ç‚¹å¯†åº¦: ${density}, å€æ•°: ${densityMultiplier}, ç›®æ ‡æ•°é‡: ${shadowPointCount}`);
            
            let createdCount = 0;
            for (let i = 0; i < shadowPointCount * 2; i++) { // å¢åŠ å°è¯•æ¬¡æ•°
                // éšæœºé€‰æ‹©ä½ç½®
                let x, y;
                let attempts = 0;
                const maxAttempts = 30;
                
                do {
                    x = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    y = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    !isValidShadowPointPosition(x, y, floor)
                );
                
                if (attempts >= maxAttempts) continue;
                
                // åˆ›å»ºé˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
                createShadowPoint(x, y, floor);
                createdCount++;
                
                if (createdCount >= shadowPointCount) break;
            }
            
            console.log(`æ¥¼å±‚${floor}å®é™…åˆ›å»ºé˜´ç‚¹æ•°é‡: ${createdCount}`);
        }
        
        // æ£€æŸ¥é˜´ç‚¹ä½ç½®æ˜¯å¦æœ‰æ•ˆ
        function isValidShadowPointPosition(x, y, floor = 0) {
            // æ£€æŸ¥è¾¹ç•Œå’Œæ•°ç»„æœ‰æ•ˆæ€§
            if (x < 0 || x >= mapFloors[floor][0].length || 
                y < 0 || y >= mapFloors[floor].length ||
                !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦åœ¨åœ°æ¿æˆ–é“è·¯ä¸Š
            if (mapFloors[floor][y][x] !== TileType.FLOOR &&
                mapFloors[floor][y][x] !== TileType.MEDIUM_GROUND &&
                mapFloors[floor][y][x] !== TileType.HIGH_GROUND &&
                mapFloors[floor][y][x] !== TileType.LOW_GROUND) {
                return false;
            }
            
            // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆæ”¾å®½æ¡ä»¶ï¼‰
            let floorCount = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                            (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                             mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                            floorCount++;
                        }
                    }
                }
            }
            
            // ç¡®ä¿å‘¨å›´æœ‰è¶³å¤Ÿçš„åœ°æ¿ç©ºé—´ï¼ˆé™ä½è¦æ±‚ï¼‰
            return floorCount >= 5;
        }
        
        // åˆ›å»ºå•ä¸ªé˜´ç‚¹
        function createShadowPoint(x, y, floor = 0) {
            const mapSize = mapFloors[floor].length;
            
            // éšæœºå†³å®šé˜´ç‚¹çš„æ–¹å‘ï¼ˆå‚ç›´æˆ–æ°´å¹³ï¼‰
            const isVertical = Math.random() < 0.7; // 70%æ¦‚ç‡ä¸ºå‚ç›´
            const length = Math.floor(Math.random() * 3) + 2; // 2-4æ ¼é•¿åº¦
            
            if (isVertical) {
                // åˆ›å»ºå‚ç›´é˜´ç‚¹
                for (let i = 0; i < length; i++) {
                    const ny = y + i;
                    if (ny >= 0 && ny < mapSize && mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                        if (mapFloors[floor][ny][x] === TileType.FLOOR ||
                            mapFloors[floor][ny][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][ny][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][ny][x] === TileType.LOW_GROUND) {
                            mapFloors[floor][ny][x] = TileType.SHADOW_POINT;
                        }
                    }
                }
            } else {
                // åˆ›å»ºæ°´å¹³é˜´ç‚¹
                for (let i = 0; i < length; i++) {
                    const nx = x + i;
                    if (nx >= 0 && nx < mapSize && mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                        if (mapFloors[floor][y][nx] === TileType.FLOOR ||
                            mapFloors[floor][y][nx] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][nx] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][nx] === TileType.LOW_GROUND) {
                            mapFloors[floor][y][nx] = TileType.SHADOW_POINT;
                        }
                    }
                }
            }
        }
        
        // ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
        function toggleTheme() {
            const body = document.body;
            const themeToggle = document.querySelector('.theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');
            
            if (body.getAttribute('data-theme') === 'light') {
                // åˆ‡æ¢åˆ°æ·±è‰²ä¸»é¢˜
                body.removeAttribute('data-theme');
                themeIcon.textContent = 'ğŸŒ™';
                themeText.textContent = 'æ·±è‰²';
                localStorage.setItem('theme', 'dark');
            } else {
                // åˆ‡æ¢åˆ°æµ…è‰²ä¸»é¢˜
                body.setAttribute('data-theme', 'light');
                themeIcon.textContent = 'â˜€ï¸';
                themeText.textContent = 'æµ…è‰²';
                localStorage.setItem('theme', 'light');
            }
            
            // é‡æ–°ç»˜åˆ¶åœ°å›¾ä»¥é€‚åº”æ–°ä¸»é¢˜
            if (typeof drawMap === 'function') {
                if (overlayMode) {
                    drawOverlayMap();
                } else {
                    drawMap();
                }
            }
            
            // æ›´æ–°3Dåœºæ™¯èƒŒæ™¯è‰²ï¼ˆå¦‚æœ3Dé¢„è§ˆæ­£åœ¨è¿è¡Œï¼‰
            if (scene3D) {
                const isLightTheme = body.getAttribute('data-theme') === 'light';
                scene3D.background = new THREE.Color(isLightTheme ? 0xf5f5f5 : 0x0a0a0a);
            }
        }
        
        // åˆå§‹åŒ–ä¸»é¢˜
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeToggle = document.querySelector('.theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');
            
            if (savedTheme === 'light') {
                document.body.setAttribute('data-theme', 'light');
                themeIcon.textContent = 'â˜€ï¸';
                themeText.textContent = 'æµ…è‰²';
            } else {
                // é»˜è®¤æ·±è‰²ä¸»é¢˜
                themeIcon.textContent = 'ğŸŒ™';
                themeText.textContent = 'æ·±è‰²';
            }
        }
        
        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–ä¸»é¢˜
            initializeTheme();
            
            document.getElementById('generateBtn').addEventListener('click', generateMap);
            document.getElementById('randomBtn').addEventListener('click', function() {
                randomizeParameters();
                generateMap();
            });
            document.getElementById('exportBtn').addEventListener('click', exportMap);
            document.getElementById('exportUCCBtn').addEventListener('click', exportUCC);
            
            // ç§å­ç³»ç»Ÿäº‹ä»¶ç›‘å¬å™¨
            document.getElementById('saveSeedBtn').addEventListener('click', saveCurrentSeed);
            document.getElementById('clearSeedsBtn').addEventListener('click', clearAllSeeds);
            document.getElementById('seedsPanelCloseBtn').addEventListener('click', hideSeedsPanel);
            
            // åŠ è½½ä¿å­˜çš„ç§å­
            loadSeedsFromStorage();
            renderSeedsList();
        });

        // ==================== 3Dé¢„è§ˆåŠŸèƒ½ ====================
        
        // æ‰“å¼€3Dé¢„è§ˆ
        function open3DPreview() {
            if (!mapFloors.length) {
                alert('è¯·å…ˆç”Ÿæˆåœ°å›¾ï¼');
                return;
            }
            
            // æ£€æŸ¥Three.jsæ˜¯å¦åŠ è½½
            if (typeof THREE === 'undefined') {
                alert('Three.jsåº“æœªèƒ½æ­£ç¡®åŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ï¼');
                return;
            }
            
            const container = document.getElementById('preview3DContainer');
            container.style.display = 'block';
            preview3DActive = true;
            
            try {
                // æ›´æ–°çŠ¶æ€
                document.getElementById('debug3DStatus').textContent = 'æ­£åœ¨åˆå§‹åŒ–åœºæ™¯...';
                document.getElementById('controlStatus').textContent = 'ğŸ”§ æ­£åœ¨åŠ è½½æ§åˆ¶å™¨...';
                
                // åˆå§‹åŒ–3Dåœºæ™¯
                init3DScene();
                render3DMap();
                
                // æ›´æ–°æˆåŠŸçŠ¶æ€
                document.getElementById('debug3DStatus').textContent = 'åœºæ™¯åŠ è½½å®Œæˆ';
                console.log('3Dé¢„è§ˆåˆå§‹åŒ–æˆåŠŸ');
            } catch (error) {
                console.error('3Dé¢„è§ˆåˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('debug3DStatus').textContent = 'åˆå§‹åŒ–å¤±è´¥: ' + error.message;
                alert('3Dé¢„è§ˆåˆå§‹åŒ–å¤±è´¥: ' + error.message);
                close3DPreview();
            }
        }
        
        // å…³é—­3Dé¢„è§ˆ
        function close3DPreview() {
            const container = document.getElementById('preview3DContainer');
            container.style.display = 'none';
            preview3DActive = false;
            
            // æ¸…ç†3Dèµ„æº
            if (renderer3D) {
                renderer3D.dispose();
                renderer3D = null;
            }
            if (scene3D) {
                // æ¸…ç†åœºæ™¯ä¸­çš„æ‰€æœ‰å¯¹è±¡
                while(scene3D.children.length > 0) {
                    const child = scene3D.children[0];
                    scene3D.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
                scene3D = null;
            }
            camera3D = null;
            controls3D = null;
        }
        
        // åˆå§‹åŒ–3Dåœºæ™¯
        function init3DScene() {
            const canvas3D = document.getElementById('preview3DCanvas');
            canvas3D.innerHTML = ''; // æ¸…ç©ºå®¹å™¨
            
            // åˆ›å»ºåœºæ™¯
            scene3D = new THREE.Scene();
            
            // æ ¹æ®å½“å‰ä¸»é¢˜è®¾ç½®èƒŒæ™¯é¢œè‰²
            const isLightTheme = document.body.getAttribute('data-theme') === 'light';
            scene3D.background = new THREE.Color(isLightTheme ? 0xf5f5f5 : 0x0a0a0a);
            
            // åˆ›å»ºç›¸æœº
            const mapSize = mapFloors[0].length;
            camera3D = new THREE.PerspectiveCamera(
                75, 
                canvas3D.clientWidth / canvas3D.clientHeight, 
                0.1, 
                1000
            );
            
            // è®¾ç½®ç›¸æœºä½ç½® - ä»æ–œä¸Šæ–¹è§‚å¯Ÿ
            const cameraDistance = mapSize * 1.5;
            camera3D.position.set(cameraDistance, cameraDistance * 0.8, cameraDistance);
            mapCenter.set(mapSize / 2, 0, mapSize / 2);
            camera3D.lookAt(mapCenter);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(canvas3D.clientWidth, canvas3D.clientHeight);
            renderer3D.shadowMap.enabled = true;
            renderer3D.shadowMap.type = THREE.PCFSoftShadowMap;
            canvas3D.appendChild(renderer3D.domElement);
            
            // æ·»åŠ è½¨é“æ§åˆ¶å™¨
            try {
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
                    controls3D.enableDamping = true;
                    controls3D.dampingFactor = 0.1;
                    controls3D.target.set(mapSize / 2, 0, mapSize / 2);
                    controls3D.maxDistance = mapSize * 5;
                    controls3D.minDistance = 5;
                    
                    // åŒå‡»é‡ç½®è§†è§’
                    renderer3D.domElement.addEventListener('dblclick', () => {
                        camera3D.position.set(cameraDistance, cameraDistance * 0.8, cameraDistance);
                        controls3D.target.set(mapSize / 2, 0, mapSize / 2);
                        controls3D.update();
                    });
                    
                    console.log('OrbitControlsåŠ è½½æˆåŠŸ');
                    document.getElementById('controlStatus').textContent = 'âœ… OrbitControlså·²å°±ç»ª';
                } else {
                    console.warn('OrbitControlsæœªåŠ è½½ï¼Œä½¿ç”¨åŸºç¡€æ§åˆ¶');
                    addBasicControls();
                    document.getElementById('controlStatus').textContent = 'âš ï¸ ä½¿ç”¨åŸºç¡€æ§åˆ¶';
                }
            } catch (error) {
                console.error('OrbitControlsåˆå§‹åŒ–å¤±è´¥:', error);
                addBasicControls();
                document.getElementById('controlStatus').textContent = 'âš ï¸ ä½¿ç”¨åŸºç¡€æ§åˆ¶';
            }
            
            // æ·»åŠ å…‰ç…§
            add3DLighting();
            
            // å¤„ç†çª—å£å¤§å°å˜åŒ–
            const resizeHandler = () => {
                if (preview3DActive && renderer3D && camera3D) {
                    camera3D.aspect = canvas3D.clientWidth / canvas3D.clientHeight;
                    camera3D.updateProjectionMatrix();
                    renderer3D.setSize(canvas3D.clientWidth, canvas3D.clientHeight);
                }
            };
            window.addEventListener('resize', resizeHandler);
            
            // æ·»åŠ é”®ç›˜å’Œé¢„è®¾è§†è§’æ”¯æŒ
            addKeyboardControls();
            addPresetViewControls();
            addTouchControls();
            
            // åŠ¨ç”»å¾ªç¯
            function animate() {
                if (preview3DActive && renderer3D && scene3D && camera3D) {
                    requestAnimationFrame(animate);
                    
                    // æ›´æ–°ç›¸æœºåŠ¨ç”»
                    updateCameraAnimation();
                    
                    // æ›´æ–°å¸§ç‡è®¡æ•°
                    updateFPSCounter();
                    
                    if (controls3D && controls3D.update) {
                        controls3D.update();
                    }
                    renderer3D.render(scene3D, camera3D);
                }
            }
            animate();
        }
        
        // æ·»åŠ åŸºç¡€æ§åˆ¶ï¼ˆOrbitControlsçš„å¤‡ç”¨æ–¹æ¡ˆï¼‰
        function addBasicControls() {
            const canvas = renderer3D.domElement;
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            // é¼ æ ‡æ§åˆ¶å˜é‡
            let rotationSpeed = 0.01;
            let zoomSpeed = 0.1;
            
            // é¼ æ ‡æŒ‰ä¸‹
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            // é¼ æ ‡ç§»åŠ¨
            canvas.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                // æ—‹è½¬ç›¸æœº
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera3D.position);
                
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi += deltaY * rotationSpeed;
                
                // é™åˆ¶å‚ç›´æ—‹è½¬è§’åº¦
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera3D.position.setFromSpherical(spherical);
                camera3D.lookAt(mapFloors[0].length / 2, 0, mapFloors[0].length / 2);
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            // é¼ æ ‡æŠ¬èµ·
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                
                const direction = event.deltaY > 0 ? 1 : -1;
                const distance = camera3D.position.length();
                const newDistance = Math.max(5, Math.min(mapFloors[0].length * 5, distance + direction * zoomSpeed * distance));
                
                camera3D.position.normalize().multiplyScalar(newDistance);
            });
            
            // åŒå‡»é‡ç½®
            canvas.addEventListener('dblclick', () => {
                const mapSize = mapFloors[0].length;
                const cameraDistance = mapSize * 1.5;
                camera3D.position.set(cameraDistance, cameraDistance * 0.8, cameraDistance);
                camera3D.lookAt(mapSize / 2, 0, mapSize / 2);
            });
        }
        
        // ==================== å¢å¼ºæ§åˆ¶åŠŸèƒ½ ====================
        
        // æ·»åŠ é”®ç›˜æ§åˆ¶
        function addKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                if (!preview3DActive) return;
                
                const moveSpeed = 5;
                const rotateSpeed = 0.1;
                
                switch(event.code) {
                    case 'KeyR':
                        animateToView('perspective');
                        break;
                    case 'KeyF':
                        focusOnMap();
                        break;
                    case 'Digit1':
                        animateToView('top');
                        break;
                    case 'Digit2':
                        animateToView('isometric');
                        break;
                    case 'Digit3':
                        animateToView('perspective');
                        break;
                    case 'Digit4':
                        animateToView('walk');
                        break;
                    case 'Equal':
                    case 'NumpadAdd':
                        zoomCamera(-0.1);
                        break;
                    case 'Minus':
                    case 'NumpadSubtract':
                        zoomCamera(0.1);
                        break;
                    case 'ArrowUp':
                        moveCamera(0, 0, -moveSpeed);
                        break;
                    case 'ArrowDown':
                        moveCamera(0, 0, moveSpeed);
                        break;
                    case 'ArrowLeft':
                        moveCamera(-moveSpeed, 0, 0);
                        break;
                    case 'ArrowRight':
                        moveCamera(moveSpeed, 0, 0);
                        break;
                    case 'Escape':
                        close3DPreview();
                        break;
                }
                
                event.preventDefault();
            });
        }
        
        // æ·»åŠ é¢„è®¾è§†è§’æ§åˆ¶
        function addPresetViewControls() {
            document.getElementById('topViewBtn').addEventListener('click', () => animateToView('top'));
            document.getElementById('isometricViewBtn').addEventListener('click', () => animateToView('isometric'));
            document.getElementById('perspectiveViewBtn').addEventListener('click', () => animateToView('perspective'));
            document.getElementById('walkViewBtn').addEventListener('click', () => animateToView('walk'));
        }
        
        // æ·»åŠ è§¦æ‘¸æ§åˆ¶
        function addTouchControls() {
            const canvas = renderer3D.domElement;
            
            // è§¦æ‘¸å¼€å§‹
            canvas.addEventListener('touchstart', (event) => {
                event.preventDefault();
                touches = {};
                
                for (let i = 0; i < event.touches.length; i++) {
                    const touch = event.touches[i];
                    touches[touch.identifier] = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                }
                
                // åŒæŒ‡è§¦æ‘¸
                if (event.touches.length === 2) {
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    
                    touchStartDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    
                    touchStartCenter = {
                        x: (touch1.clientX + touch2.clientX) / 2,
                        y: (touch1.clientY + touch2.clientY) / 2
                    };
                }
            });
            
            // è§¦æ‘¸ç§»åŠ¨
            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    // å•æŒ‡æ—‹è½¬
                    const touch = event.touches[0];
                    const prevTouch = touches[touch.identifier];
                    
                    if (prevTouch) {
                        const deltaX = touch.clientX - prevTouch.x;
                        const deltaY = touch.clientY - prevTouch.y;
                        
                        rotateCamera(deltaX * 0.01, deltaY * 0.01);
                        
                        touches[touch.identifier] = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                    }
                } else if (event.touches.length === 2) {
                    // åŒæŒ‡ç¼©æ”¾å’Œå¹³ç§»
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    
                    const currentCenter = {
                        x: (touch1.clientX + touch2.clientX) / 2,
                        y: (touch1.clientY + touch2.clientY) / 2
                    };
                    
                    // ç¼©æ”¾
                    if (touchStartDistance > 0) {
                        const scale = currentDistance / touchStartDistance;
                        const zoomDelta = (1 - scale) * 0.5;
                        zoomCamera(zoomDelta);
                    }
                    
                    // å¹³ç§»
                    const panDeltaX = currentCenter.x - touchStartCenter.x;
                    const panDeltaY = currentCenter.y - touchStartCenter.y;
                    panCamera(panDeltaX * 0.01, panDeltaY * 0.01);
                    
                    touchStartDistance = currentDistance;
                    touchStartCenter = currentCenter;
                }
            });
            
            // è§¦æ‘¸ç»“æŸ
            canvas.addEventListener('touchend', (event) => {
                event.preventDefault();
                
                // æ¸…ç†ç»“æŸçš„è§¦æ‘¸ç‚¹
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    delete touches[touch.identifier];
                }
            });
        }
        
        // åŠ¨ç”»åˆ°æŒ‡å®šè§†è§’
        function animateToView(viewType) {
            if (!mapFloors.length || cameraAnimating) return;
            
            const mapSize = mapFloors[0].length;
            const distance = mapSize * 1.5;
            let newPosition = new THREE.Vector3();
            let newLookAt = mapCenter.clone();
            
            // æ›´æ–°é¢„è®¾è§†è§’æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.preset-view-btn').forEach(btn => btn.classList.remove('active'));
            
            switch(viewType) {
                case 'top':
                    newPosition.set(mapSize / 2, distance, mapSize / 2);
                    document.getElementById('topViewBtn').classList.add('active');
                    break;
                case 'isometric':
                    newPosition.set(distance, distance * 0.6, distance);
                    document.getElementById('isometricViewBtn').classList.add('active');
                    break;
                case 'perspective':
                    newPosition.set(distance, distance * 0.8, distance);
                    document.getElementById('perspectiveViewBtn').classList.add('active');
                    break;
                case 'walk':
                    newPosition.set(mapSize / 2, 3, mapSize / 4);
                    newLookAt.set(mapSize / 2, 0, mapSize * 0.75);
                    document.getElementById('walkViewBtn').classList.add('active');
                    break;
            }
            
            currentPresetView = viewType;
            smoothCameraTransition(newPosition, newLookAt);
        }
        
        // å¹³æ»‘ç›¸æœºè¿‡æ¸¡
        function smoothCameraTransition(targetPos, targetLook, duration = 1000) {
            if (cameraAnimating) return;
            
            cameraAnimating = true;
            const startPos = camera3D.position.clone();
            const startLook = new THREE.Vector3();
            camera3D.getWorldDirection(startLook);
            startLook.add(camera3D.position);
            
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                const easeProgress = easeInOutCubic(progress);
                
                // æ’å€¼ä½ç½®
                camera3D.position.lerpVectors(startPos, targetPos, easeProgress);
                
                // æ’å€¼æœå‘
                const currentLook = new THREE.Vector3();
                currentLook.lerpVectors(startLook, targetLook, easeProgress);
                camera3D.lookAt(currentLook);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    cameraAnimating = false;
                }
            }
            
            animateCamera();
        }
        
        // ç¼“åŠ¨å‡½æ•°
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        }
        
        // èšç„¦åˆ°åœ°å›¾ä¸­å¿ƒ
        function focusOnMap() {
            smoothCameraTransition(camera3D.position, mapCenter);
        }
        
        // ç¼©æ”¾ç›¸æœº
        function zoomCamera(delta) {
            const direction = camera3D.position.clone().sub(mapCenter).normalize();
            const distance = camera3D.position.distanceTo(mapCenter);
            const newDistance = Math.max(5, Math.min(mapFloors[0].length * 5, distance + delta * distance));
            
            const newPosition = mapCenter.clone().add(direction.multiplyScalar(newDistance));
            camera3D.position.copy(newPosition);
        }
        
        // ç§»åŠ¨ç›¸æœº
        function moveCamera(deltaX, deltaY, deltaZ) {
            const moveVector = new THREE.Vector3(deltaX, deltaY, deltaZ);
            camera3D.position.add(moveVector);
            mapCenter.add(moveVector);
        }
        
        // æ—‹è½¬ç›¸æœº
        function rotateCamera(deltaX, deltaY) {
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(camera3D.position.clone().sub(mapCenter));
            
            spherical.theta -= deltaX;
            spherical.phi += deltaY;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
            
            camera3D.position.setFromSpherical(spherical).add(mapCenter);
            camera3D.lookAt(mapCenter);
        }
        
        // å¹³ç§»ç›¸æœº
        function panCamera(deltaX, deltaY) {
            const panVector = new THREE.Vector3();
            camera3D.getWorldDirection(panVector);
            
            const right = new THREE.Vector3();
            right.crossVectors(panVector, camera3D.up).normalize();
            
            const up = new THREE.Vector3();
            up.crossVectors(right, panVector).normalize();
            
            const moveVector = new THREE.Vector3();
            moveVector.addScaledVector(right, -deltaX);
            moveVector.addScaledVector(up, deltaY);
            
            camera3D.position.add(moveVector);
            mapCenter.add(moveVector);
        }
        
        // æ›´æ–°ç›¸æœºåŠ¨ç”»
        function updateCameraAnimation() {
            // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šç›¸æœºåŠ¨ç”»é€»è¾‘
        }
        
        // æ›´æ–°å¸§ç‡è®¡æ•°å™¨
        function updateFPSCounter() {
            frameCount++;
            const now = Date.now();
            
            if (now - lastFPSUpdate >= 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastFPSUpdate));
                document.getElementById('fpsCounter').textContent = fps + ' FPS';
                frameCount = 0;
                lastFPSUpdate = now;
            }
        }
        
        // æ·»åŠ 3Då…‰ç…§
        function add3DLighting() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene3D.add(ambientLight);
            
            // ä¸»è¦æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene3D.add(directionalLight);
            
            // è¾…åŠ©å…‰æº
            const pointLight = new THREE.PointLight(0x6699ff, 0.3, 100);
            pointLight.position.set(-20, 30, 20);
            scene3D.add(pointLight);
        }
        
        // æ¸²æŸ“3Dåœ°å›¾ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ - åˆå¹¶ç›¸é‚»æ–¹å—ï¼‰
        function render3DMap() {
            if (!scene3D || !mapFloors.length) return;
            
            const floorHeight = 4; // æ¯å±‚çš„é«˜åº¦
            
            // ä¸ºæ¯å±‚åˆ›å»ºä¼˜åŒ–çš„3Då‡ ä½•ä½“
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const yOffset = floor * floorHeight;
                
                // åˆ›å»ºåˆå¹¶çš„å‡ ä½•ä½“
                createMergedGeometry(currentMap, yOffset, floor);
            }
            
            // è®¡ç®—æ€§èƒ½ç»Ÿè®¡
            const objectCount = scene3D.children.length;
            let totalTriangles = 0;
            
            scene3D.children.forEach(child => {
                if (child.geometry) {
                    const geometry = child.geometry;
                    if (geometry.index) {
                        totalTriangles += geometry.index.count / 3;
                    } else if (geometry.attributes.position) {
                        totalTriangles += geometry.attributes.position.count / 3;
                    }
                }
            });
            
            const perfMessage = `3Dæ¸²æŸ“å®Œæˆ - å¯¹è±¡: ${objectCount}, ä¸‰è§’å½¢: ${Math.floor(totalTriangles)}`;
            console.log(perfMessage);
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            document.getElementById('debug3DStatus').textContent = 
                `å·²æ¸²æŸ“ ${objectCount} ä¸ªå¯¹è±¡ï¼Œ${Math.floor(totalTriangles)} ä¸ªä¸‰è§’å½¢`;
        }
        
        // åˆ›å»ºåˆå¹¶å‡ ä½•ä½“ï¼ˆæ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒï¼‰
        function createMergedGeometry(mapData, yOffset, floor) {
            // æŒ‰æè´¨ç±»å‹åˆ†ç»„ç“¦ç‰‡
            const tileGroups = groupTilesByType(mapData, floor);
            
            // ä¸ºæ¯ç§ç“¦ç‰‡ç±»å‹åˆ›å»ºåˆå¹¶çš„å‡ ä½•ä½“
            Object.keys(tileGroups).forEach(tileType => {
                const tiles = tileGroups[tileType];
                if (tiles.length === 0) return;
                
                const mergedMesh = createMergedMesh(tiles, parseInt(tileType), yOffset, floor);
                if (mergedMesh) {
                    scene3D.add(mergedMesh);
                }
            });
        }
        
        // æŒ‰ç“¦ç‰‡ç±»å‹åˆ†ç»„
        function groupTilesByType(mapData, floor) {
            const groups = {};
            
            for (let z = 0; z < mapData.length; z++) {
                for (let x = 0; x < mapData[0].length; x++) {
                    const tileType = mapData[z][x];
                    
                    if (tileType !== TileType.VOID) {
                        if (!groups[tileType]) {
                            groups[tileType] = [];
                        }
                        groups[tileType].push({ x, z });
                    }
                }
            }
            
            return groups;
        }
        
        // åˆ›å»ºåˆå¹¶ç½‘æ ¼
        function createMergedMesh(tiles, tileType, yOffset, floor) {
            const { geometry: baseGeometry, material } = get3DTileProperties(tileType, floor);
            if (!baseGeometry || !material) return null;
            
            // å¯¹äºå¯ä»¥å¹³é“ºåˆå¹¶çš„ç±»å‹ï¼ˆåœ°æ¿ã€å¢™å£ç­‰ï¼‰ï¼Œä½¿ç”¨åŒºåŸŸåˆå¹¶
            if (canMergeTiles(tileType)) {
                return createMergedPlanarMesh(tiles, tileType, yOffset, floor, material);
            } else {
                // å¯¹äºç‰¹æ®Šå½¢çŠ¶çš„ç“¦ç‰‡ï¼Œä½¿ç”¨å®ä¾‹åŒ–å‡ ä½•ä½“
                return createInstancedMesh(tiles, baseGeometry, material, yOffset);
            }
        }
        
        // åˆ¤æ–­ç“¦ç‰‡æ˜¯å¦å¯ä»¥å¹³é“ºåˆå¹¶
        function canMergeTiles(tileType) {
            const mergableTiles = [
                TileType.FLOOR, 
                TileType.MEDIUM_GROUND,
                TileType.HIGH_GROUND,
                TileType.LOW_GROUND,
                TileType.ELEVATED,
                TileType.LOWERED,
                TileType.WATER,
                TileType.BOMBSITE_A,
                TileType.BOMBSITE_B,
                TileType.T_SPAWN,
                TileType.CT_SPAWN,
                TileType.WALL  // å¢™å£ä¹Ÿæ”¯æŒåˆå¹¶
            ];
            return mergableTiles.includes(tileType);
        }
        
        // åˆ›å»ºå¹³é“ºåˆå¹¶ç½‘æ ¼ï¼ˆç”¨äºåœ°æ¿ã€åŒ…ç‚¹ã€å¢™å£ç­‰ï¼‰
        function createMergedPlanarMesh(tiles, tileType, yOffset, floor, material) {
            if (tiles.length === 0) return null;
            
            // æ‰¾åˆ°è¿ç»­çš„çŸ©å½¢åŒºåŸŸ
            const rectangles = findRectangularRegions(tiles);
            
            const mergedGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            
            let vertexIndex = 0;
            
            rectangles.forEach(rect => {
                const { x, z, width, height } = rect;
                const { height: tileHeight } = getTileProperties(tileType);
                const isWall = tileType === TileType.WALL;
                
                if (isWall) {
                    // ä¸ºå¢™å£åˆ›å»ºå®Œæ•´çš„ç«‹æ–¹ä½“
                    vertexIndex = addBoxGeometry(vertices, normals, uvs, indices, 
                        x, yOffset, z, width, tileHeight, height, vertexIndex);
                } else {
                    // ä¸ºå…¶ä»–ç“¦ç‰‡åˆ›å»ºå¹³é¢
                    vertexIndex = addPlaneGeometry(vertices, normals, uvs, indices,
                        x, yOffset, z, width, tileHeight, height, vertexIndex);
                }
            });
            
            mergedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            mergedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            mergedGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            mergedGeometry.setIndex(indices);
            
            const mesh = new THREE.Mesh(mergedGeometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            return mesh;
        }
        
        // æ·»åŠ ç«‹æ–¹ä½“å‡ ä½•ä½“ï¼ˆç”¨äºå¢™å£ï¼‰
        function addBoxGeometry(vertices, normals, uvs, indices, x, y, z, width, height, depth, startVertexIndex) {
            const faces = [
                // å‰é¢
                [[x, y, z + depth], [x + width, y, z + depth], [x + width, y + height, z + depth], [x, y + height, z + depth]],
                // åé¢  
                [[x + width, y, z], [x, y, z], [x, y + height, z], [x + width, y + height, z]],
                // å³é¢
                [[x + width, y, z + depth], [x + width, y, z], [x + width, y + height, z], [x + width, y + height, z + depth]],
                // å·¦é¢
                [[x, y, z], [x, y, z + depth], [x, y + height, z + depth], [x, y + height, z]],
                // é¡¶é¢
                [[x, y + height, z + depth], [x + width, y + height, z + depth], [x + width, y + height, z], [x, y + height, z]],
                // åº•é¢
                [[x, y, z], [x + width, y, z], [x + width, y, z + depth], [x, y, z + depth]]
            ];
            
            const faceNormals = [
                [0, 0, 1],   // å‰é¢
                [0, 0, -1],  // åé¢
                [1, 0, 0],   // å³é¢
                [-1, 0, 0],  // å·¦é¢
                [0, 1, 0],   // é¡¶é¢
                [0, -1, 0]   // åº•é¢
            ];
            
            faces.forEach((face, faceIndex) => {
                const startVertex = startVertexIndex;
                
                // æ·»åŠ é¢çš„é¡¶ç‚¹
                face.forEach(vertex => {
                    vertices.push(...vertex);
                    normals.push(...faceNormals[faceIndex]);
                    uvs.push(0, 0); // ç®€åŒ–UV
                });
                
                // æ·»åŠ é¢çš„ç´¢å¼•ï¼ˆä¸¤ä¸ªä¸‰è§’å½¢ï¼‰
                indices.push(
                    startVertex, startVertex + 1, startVertex + 2,
                    startVertex, startVertex + 2, startVertex + 3
                );
                
                startVertexIndex += 4;
            });
            
            return startVertexIndex;
        }
        
        // æ·»åŠ å¹³é¢å‡ ä½•ä½“ï¼ˆç”¨äºåœ°æ¿ç­‰ï¼‰
        function addPlaneGeometry(vertices, normals, uvs, indices, x, y, z, width, height, depth, startVertexIndex) {
            // åº•é¢é¡¶ç‚¹
            vertices.push(
                x, y, z,
                x + width, y, z,
                x + width, y, z + depth,
                x, y, z + depth
            );
            
            // é¡¶é¢é¡¶ç‚¹  
            vertices.push(
                x, y + height, z,
                x + width, y + height, z,
                x + width, y + height, z + depth,
                x, y + height, z + depth
            );
            
            // æ³•çº¿
            for (let i = 0; i < 4; i++) {
                normals.push(0, -1, 0); // åº•é¢
            }
            for (let i = 0; i < 4; i++) {
                normals.push(0, 1, 0); // é¡¶é¢
            }
            
            // UVåæ ‡
            uvs.push(0, 0, width, 0, width, depth, 0, depth);
            uvs.push(0, 0, width, 0, width, depth, 0, depth);
            
            // ç´¢å¼•
            // åº•é¢
            indices.push(
                startVertexIndex, startVertexIndex + 1, startVertexIndex + 2,
                startVertexIndex, startVertexIndex + 2, startVertexIndex + 3
            );
            // é¡¶é¢
            indices.push(
                startVertexIndex + 4, startVertexIndex + 6, startVertexIndex + 5,
                startVertexIndex + 4, startVertexIndex + 7, startVertexIndex + 6
            );
            
            return startVertexIndex + 8;
        }
        
        // æŸ¥æ‰¾çŸ©å½¢åŒºåŸŸï¼ˆè´ªå¿ƒç®—æ³•åˆå¹¶ç›¸é‚»ç“¦ç‰‡ï¼‰
        function findRectangularRegions(tiles) {
            const rectangles = [];
            const used = new Set();
            
            // åˆ›å»ºä½ç½®æŸ¥æ‰¾è¡¨
            const positionMap = new Map();
            tiles.forEach(tile => {
                positionMap.set(`${tile.x},${tile.z}`, tile);
            });
            
            tiles.forEach(tile => {
                const key = `${tile.x},${tile.z}`;
                if (used.has(key)) return;
                
                // æ‰¾åˆ°ä»¥å½“å‰ç“¦ç‰‡ä¸ºèµ·ç‚¹çš„æœ€å¤§çŸ©å½¢
                const rect = findMaxRectangle(tile, positionMap, used);
                if (rect) {
                    rectangles.push(rect);
                }
            });
            
            return rectangles;
        }
        
        // æŸ¥æ‰¾æœ€å¤§çŸ©å½¢ï¼ˆä»ç»™å®šèµ·ç‚¹å¼€å§‹ï¼‰
        function findMaxRectangle(startTile, positionMap, used) {
            let maxWidth = 1;
            let maxHeight = 1;
            
            // å‘å³æ‰©å±•æ‰¾æœ€å¤§å®½åº¦
            while (positionMap.has(`${startTile.x + maxWidth},${startTile.z}`) && 
                   !used.has(`${startTile.x + maxWidth},${startTile.z}`)) {
                maxWidth++;
            }
            
            // å‘ä¸‹æ‰©å±•ï¼Œæ£€æŸ¥æ¯ä¸€è¡Œæ˜¯å¦èƒ½ä¿æŒç›¸åŒå®½åº¦
            let canExpand = true;
            while (canExpand) {
                for (let x = 0; x < maxWidth; x++) {
                    const checkKey = `${startTile.x + x},${startTile.z + maxHeight}`;
                    if (!positionMap.has(checkKey) || used.has(checkKey)) {
                        canExpand = false;
                        break;
                    }
                }
                if (canExpand) {
                    maxHeight++;
                }
            }
            
            // æ ‡è®°æ‰€æœ‰ä½¿ç”¨çš„ç“¦ç‰‡
            for (let x = 0; x < maxWidth; x++) {
                for (let z = 0; z < maxHeight; z++) {
                    used.add(`${startTile.x + x},${startTile.z + z}`);
                }
            }
            
            return {
                x: startTile.x,
                z: startTile.z,
                width: maxWidth,
                height: maxHeight
            };
        }
        
        // åˆ›å»ºå®ä¾‹åŒ–ç½‘æ ¼ï¼ˆç”¨äºæ©ä½“ã€æ¥¼æ¢¯ç­‰ç‰¹æ®Šå½¢çŠ¶ï¼‰
        function createInstancedMesh(tiles, baseGeometry, material, yOffset) {
            if (tiles.length === 0) return null;
            
            const instancedMesh = new THREE.InstancedMesh(baseGeometry, material, tiles.length);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            
            const matrix = new THREE.Matrix4();
            
            tiles.forEach((tile, index) => {
                matrix.setPosition(tile.x, yOffset, tile.z);
                instancedMesh.setMatrixAt(index, matrix);
            });
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            
            return instancedMesh;
        }
        
        // è·å–ç“¦ç‰‡å±æ€§
        function getTileProperties(tileType) {
            switch(tileType) {
                case TileType.FLOOR:
                case TileType.MEDIUM_GROUND:
                    return { height: 0.1 };
                case TileType.WALL:
                    return { height: 3 };
                case TileType.HIGH_GROUND:
                case TileType.ELEVATED:
                    return { height: 1.5 };
                case TileType.LOW_GROUND:
                case TileType.LOWERED:
                    return { height: 0.05 };
                case TileType.WATER:
                    return { height: 0.3 };
                case TileType.BOMBSITE_A:
                case TileType.BOMBSITE_B:
                case TileType.T_SPAWN:
                case TileType.CT_SPAWN:
                    return { height: 0.2 };
                default:
                    return { height: 0.1 };
            }
        }
        
        // åˆ›å»º3Dç“¦ç‰‡
        function create3DTile(tileType, x, y, z, floor) {
            const { geometry, material } = get3DTileProperties(tileType, floor);
            
            if (!geometry || !material) return null;
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            return mesh;
        }
        
        // è·å–3Dç“¦ç‰‡çš„å‡ ä½•ä½“å’Œæè´¨
        function get3DTileProperties(tileType, floor) {
            let geometry, material;
            
            switch(tileType) {
                case TileType.FLOOR:
                case TileType.MEDIUM_GROUND:
                    geometry = new THREE.BoxGeometry(1, 0.1, 1);
                    material = new THREE.MeshLambertMaterial({ 
                        color: floor === 0 ? 0x4a4a4a : floor === 1 ? 0x5a5a5a : 0x6a6a6a 
                    });
                    break;
                    
                case TileType.WALL:
                    geometry = new THREE.BoxGeometry(1, 3, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0xb0b0b0 });
                    break;
                    
                case TileType.HIGH_GROUND:
                case TileType.ELEVATED:
                    geometry = new THREE.BoxGeometry(1, 1.5, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x6a6a4a });
                    break;
                    
                case TileType.LOW_GROUND:
                case TileType.LOWERED:
                    geometry = new THREE.BoxGeometry(1, 0.05, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x2a2a4a });
                    break;
                    
                case TileType.COVER:
                    geometry = new THREE.BoxGeometry(0.8, 1.2, 0.8);
                    material = new THREE.MeshLambertMaterial({ color: 0x303030 });
                    break;
                    
                case TileType.WATER:
                    geometry = new THREE.BoxGeometry(1, 0.3, 1);
                    material = new THREE.MeshLambertMaterial({ 
                        color: 0x2a4d69, 
                        transparent: true, 
                        opacity: 0.7 
                    });
                    break;
                    
                case TileType.STAIRS_UP:
                    geometry = new THREE.BoxGeometry(1, 0.8, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
                    break;
                    
                case TileType.STAIRS_DOWN:
                    geometry = new THREE.BoxGeometry(1, 0.6, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x6B5345 });
                    break;
                    
                case TileType.WINDOW:
                    geometry = new THREE.BoxGeometry(1, 2, 0.1);
                    material = new THREE.MeshLambertMaterial({ 
                        color: 0x6a8caf, 
                        transparent: true, 
                        opacity: 0.6 
                    });
                    break;
                    
                case TileType.BOMBSITE_A:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x5a5a00 });
                    break;
                    
                case TileType.BOMBSITE_B:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x5a3a00 });
                    break;
                    
                case TileType.T_SPAWN:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x3a2020 });
                    break;
                    
                case TileType.CT_SPAWN:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x203a20 });
                    break;
                    
                case TileType.DOOR:
                    geometry = new THREE.BoxGeometry(1, 2.5, 0.2);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    break;
                    
                default:
                    geometry = new THREE.BoxGeometry(1, 0.1, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x404040 });
                    break;
            }
            
            return { geometry, material };
        }

        // æ£€æŸ¥3Dæ”¯æŒ
        function check3DSupport() {
            const results = [];
            
            // æ£€æŸ¥Three.js
            if (typeof THREE !== 'undefined') {
                results.push('âœ… Three.jså·²åŠ è½½');
            } else {
                results.push('âŒ Three.jsæœªåŠ è½½');
            }
            
            // æ£€æŸ¥WebGLæ”¯æŒ
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    results.push('âœ… WebGLæ”¯æŒ');
                } else {
                    results.push('âŒ WebGLä¸æ”¯æŒ');
                }
            } catch (e) {
                results.push('âŒ WebGLæ£€æŸ¥å¤±è´¥');
            }
            
            // æ£€æŸ¥OrbitControls
            setTimeout(() => {
                if (typeof THREE !== 'undefined' && THREE.OrbitControls) {
                    results.push('âœ… OrbitControlså·²åŠ è½½');
                } else {
                    results.push('âš ï¸ OrbitControlsæœªåŠ è½½ï¼ˆå°†ä½¿ç”¨åŸºç¡€æ§åˆ¶ï¼‰');
                }
                console.log('3Dæ”¯æŒæ£€æŸ¥ç»“æœ:', results.join(', '));
            }, 1000);
            
            return results;
        }

        // å½“DOMåŠ è½½å®Œæˆæ—¶ï¼Œåˆå§‹åŒ–æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function() {
            
            // æ£€æŸ¥3Dæ”¯æŒ
            check3DSupport();
            
            // 3Dé¢„è§ˆæŒ‰é’®äº‹ä»¶
            document.getElementById('preview3DBtn').addEventListener('click', open3DPreview);
            document.getElementById('close3DBtn').addEventListener('click', close3DPreview);
            
            // ç”Ÿæˆåˆå§‹åœ°å›¾
            generateMap();
        });
    </script>

    <!-- UCCå¯¼å‡ºä½¿ç”¨è¯´æ˜å¼¹çª— -->
    <div id="uccTutorialModal" class="ucc-tutorial-modal" style="display: none;">
        <div class="ucc-tutorial-modal-content">
            <div class="ucc-tutorial-modal-header">
                <h2>ğŸ® UCCå¯¼å‡ºä½¿ç”¨è¯´æ˜</h2>
                <button class="ucc-tutorial-close" onclick="closeUccTutorial()">&times;</button>
            </div>
            <div class="ucc-tutorial-modal-body">
                <div class="ucc-tutorial-step">
                    <div class="ucc-tutorial-step-number">1</div>
                    <div class="ucc-tutorial-step-content">
                        <h3>åˆ›å»ºUCCæ¨¡æ¿æ–‡ä»¶</h3>
                        <p>é¦–å…ˆåœ¨æ¸¸æˆä¸­åˆ›å»ºä¸€ä¸ªUCCæ–‡ä»¶ï¼Œå‘½åä¸º <strong>mf5.ucc</strong></p>
                        <p>åœ¨æ–‡ä»¶ä¸­æ”¾ç½®çº¦ <strong>4000ä¸ªæ–¹å—</strong> ä½œä¸ºæ¨¡æ¿</p>
                    </div>
                </div>
                <div class="ucc-tutorial-step">
                    <div class="ucc-tutorial-step-number">2</div>
                    <div class="ucc-tutorial-step-content">
                        <h3>é€‰æ‹©æ¨¡æ¿æ–‡ä»¶</h3>
                        <p>åœ¨ç½‘é¡µä¸­ç‚¹å‡»"å¯¼å‡ºUCC"æŒ‰é’®</p>
                        <p>ç³»ç»Ÿä¼šè‡ªåŠ¨å¼¹å‡ºæ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†</p>
                        <p>é€‰æ‹©æ‚¨åˆ›å»ºçš„ <strong>mf5.ucc</strong> æ–‡ä»¶</p>
                    </div>
                </div>
                <div class="ucc-tutorial-step">
                    <div class="ucc-tutorial-step-number">3</div>
                    <div class="ucc-tutorial-step-content">
                        <h3>å¯¼å‡ºåœ°å›¾</h3>
                        <p>é€‰æ‹©æ¨¡æ¿æ–‡ä»¶åï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å¤„ç†åœ°å›¾æ•°æ®</p>
                        <p>ç”ŸæˆåŒ…å«æ‚¨åœ°å›¾çš„UCCæ–‡ä»¶å¹¶è‡ªåŠ¨ä¸‹è½½</p>
                    </div>
                </div>
                <div class="ucc-tutorial-tips">
                    <h4>ğŸ’¡ æç¤º</h4>
                    <ul>
                        <li>æ¨¡æ¿æ–‡ä»¶åªéœ€è¦å¯¼å…¥ä¸€æ¬¡ï¼Œåç»­å¯¼å‡ºä¼šé‡å¤ä½¿ç”¨</li>
                        <li>ç¡®ä¿æ¨¡æ¿æ–‡ä»¶åŒ…å«è¶³å¤Ÿçš„æ–¹å—æ•°é‡ï¼ˆçº¦4000ä¸ªï¼‰</li>
                        <li>å¯¼å‡ºçš„UCCæ–‡ä»¶å¯ä»¥ç›´æ¥åœ¨æ¸¸æˆä¸­ä½¿ç”¨</li>
                    </ul>
                </div>
            </div>
            <div class="ucc-tutorial-modal-footer">
                <button class="btn btn--primary" onclick="closeUccTutorial()">æˆ‘çŸ¥é“äº†</button>
                <button class="btn btn--secondary" onclick="closeUccTutorial(true)">ä¸å†æ˜¾ç¤º</button>
            </div>
        </div>
    </div>
</body>
</html>
