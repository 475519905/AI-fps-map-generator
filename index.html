<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CF风格多层竞技地图生成器</title>
    <!-- Three.js库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 尝试加载OrbitControls
        const orbitScript = document.createElement('script');
        orbitScript.src = 'https://threejs.org/examples/js/controls/OrbitControls.js';
        orbitScript.onerror = function() {
            console.warn('OrbitControls加载失败，将使用基础控制');
        };
        document.head.appendChild(orbitScript);
    </script>
    <style>
        :root {
            /* 深色主题变量 */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #222;
            --border-color: #333;
            --text-primary: #f0f0f0;
            --text-secondary: #ccc;
            --text-muted: #999;
            --text-darker: #888;
            --accent-color: #4CAF50;
            --accent-hover: #45a049;
            --button-secondary: #2196F3;
            --button-secondary-hover: #1976D2;
            --shadow-light: rgba(0, 0, 0, 0.8);
            --shadow-heavy: rgba(0, 0, 0, 0.8);
            --canvas-bg: #000;
        }

        [data-theme="light"] {
            /* 浅色主题变量 */
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8f8f8;
            --border-color: #ddd;
            --text-primary: #333;
            --text-secondary: #555;
            --text-muted: #666;
            --text-darker: #888;
            --accent-color: #4CAF50;
            --accent-hover: #45a049;
            --button-secondary: #2196F3;
            --button-secondary-hover: #1976D2;
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-heavy: rgba(0, 0, 0, 0.15);
            --canvas-bg: #fff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: background-color 0.3s ease;
        }

        .container {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 20px 60px var(--shadow-heavy);
            max-width: 1600px;
            width: 100%;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .header-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            position: relative;
        }

        h1 {
            color: var(--text-primary);
            font-size: 2em;
            text-shadow: 2px 2px 4px var(--shadow-light);
            transition: color 0.3s ease;
            margin: 0;
        }

        .theme-toggle {
            position: absolute;
            right: 0;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 25px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        .theme-toggle:hover {
            border-color: var(--accent-color);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--shadow-light);
        }

        .theme-icon {
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .theme-toggle:hover .theme-icon {
            transform: rotate(180deg);
        }

        .subtitle {
            text-align: center;
            color: var(--text-darker);
            margin-bottom: 25px;
            font-size: 1em;
            transition: color 0.3s ease;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: bold;
            color: var(--text-muted);
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.3s ease;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--border-color);
            outline: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            transition: background 0.3s ease;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover {
            border-color: var(--accent-color);
        }

        .value-display {
            color: var(--accent-color);
            font-weight: bold;
            margin-left: 5px;
            transition: color 0.3s ease;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        /* 统一四按钮布局：桌面端单行四列，居中 */
        .button-group.unified-actions {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin-top: 30px;
            margin-bottom: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .button-group.unified-actions .btn {
            flex: 0 0 auto;
            min-width: 110px;
            height: 44px;
        }
        
        /* 主要操作按钮组 */
        .button-group.primary-actions {
            margin-bottom: 10px;
            display: flex !important;
            justify-content: center;
            align-items: center;
            gap: 20px;
            grid-template-columns: none; /* 覆盖grid布局 */
        }
        
        .primary-actions button {
            background: var(--accent-color);
            font-weight: bold;
            font-size: 15px;
            min-width: 120px;
            padding: 12px 24px;
        }
        
        .primary-actions button:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        /* 辅助功能按钮组 */
        .secondary-actions {
            margin-top: 0;
        }

        /* 统一按钮组件样式 */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid transparent;
            background: #2a2a2a;
            color: #eaeaea;
            font-size: 14px;
            font-weight: 600;
            line-height: 1;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            min-width: 110px;
            height: 44px;
            text-transform: none;
            letter-spacing: normal;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn:focus-visible {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        .btn--lg {
            padding: 12px 20px;
            font-size: 14px;
            min-width: 110px;
            height: 44px;
        }

        .btn--primary {
            background: var(--accent-color);
            color: #101010;
            font-weight: bold;
        }

        .btn--primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn--secondary {
            background: #3a3a3a;
            color: #f0f0f0;
            font-weight: bold;
        }

        .btn--secondary:hover {
            background: #4a4a4a;
            transform: translateY(-1px);
        }

        .btn--outline {
            background: transparent;
            color: var(--accent-color);
            border-color: var(--accent-color);
            font-weight: bold;
        }

        .btn--outline:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: var(--accent-hover);
            color: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn--ghost {
            background: rgba(255, 255, 255, 0.04);
            color: #eaeaea;
            font-weight: bold;
        }

        .btn--ghost:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
        }
        
        .secondary-actions button {
            background: var(--button-secondary);
            font-size: 14px;
        }
        
        .secondary-actions button:hover {
            background: var(--button-secondary-hover);
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            /* 移动端：统一四按钮采用两列布局 */
            .button-group.unified-actions {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                justify-content: center;
                gap: 10px;
                margin-top: 25px;
                margin-bottom: 15px;
                padding-top: 15px;
            }

            .button-group.unified-actions .btn {
                min-width: 100%;
                height: 44px;
            }
            
            /* 移动端整体布局优化 */
            .container {
                padding: 10px;
                min-height: 100vh;
            }
            
            .header-container {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
            
            .header-container h1 {
                font-size: 20px;
                line-height: 1.3;
            }
            
            .subtitle {
                font-size: 12px;
                margin-bottom: 15px;
            }
            
            /* 控制面板移动端优化 */
            .controls-panel {
                margin-bottom: 15px;
            }
            
            .control-group {
                margin-bottom: 15px;
            }
            
            .control-group label {
                font-size: 13px;
                margin-bottom: 5px;
                display: block;
            }
            
            .control-group input[type="range"] {
                width: 100%;
                height: 35px;
            }
            
            .control-group select {
                width: 100%;
                padding: 8px;
                font-size: 14px;
            }
            
            /* 按钮移动端优化 */
            button {
                padding: 12px 16px;
                font-size: 13px;
                min-height: 44px; /* iOS建议的最小触摸目标 */
            }
            
            /* 移动端按钮组优化 */
            .button-group.primary-actions {
                margin-bottom: 8px;
                gap: 15px;
                flex-direction: column;
            }
            
            .primary-actions button {
                font-size: 14px;
                font-weight: bold;
                padding: 14px 16px;
                min-width: 180px;
                width: 100%;
                max-width: 250px;
            }
            
            .secondary-actions button {
                font-size: 13px;
                padding: 12px 16px;
            }
            
            .theme-toggle {
                padding: 8px 12px;
                font-size: 12px;
                min-height: 40px;
            }
            
            /* Canvas移动端优化 */
            #canvas {
                max-width: 100%;
                height: auto;
                margin: 10px auto;
            }
            
            /* 楼层选择器移动端优化 */
            .floor-selector {
                margin: 10px 0;
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .floor-selector button {
                flex: 1;
                min-width: 60px;
                padding: 8px 12px;
                font-size: 12px;
            }
            
            /* 种子面板移动端优化 */
            .seeds-panel {
                margin-top: 15px;
                right: 10px;
                width: calc(100vw - 20px);
                max-width: 280px;
            }
            
            .seeds-panel-close {
                font-size: 16px;
                padding: 6px 10px;
            }
            
            .seeds-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
            }
            
            .seed-item {
                padding: 8px;
                font-size: 11px;
            }
            
            /* 图例移动端优化 */
            .legend {
                margin-top: 15px;
            }
            
            .legend-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 8px;
            }
            
            .legend-item {
                font-size: 11px;
                padding: 6px;
            }
            
            .legend-color {
                width: 12px;
                height: 12px;
            }
            
            /* 3D预览移动端优化 */
            .preview-3d-header {
                padding: 12px 10px;
                flex-direction: column;
                gap: 10px;
            }
            
            .preview-3d-title {
                font-size: 16px;
                text-align: center;
            }
            
            .preview-3d-controls {
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }
            
            .preset-view-btn {
                padding: 8px 12px;
                font-size: 11px;
                min-width: 60px;
            }
            
            .preview-3d-close {
                padding: 8px 16px;
                font-size: 12px;
                order: -1; /* 放到最前面 */
                width: 100%;
                margin-bottom: 5px;
            }
            
            .preview-3d-canvas {
                height: calc(100vh - 120px);
            }
            
            .preview-3d-instructions {
                top: 120px;
                left: 10px;
                right: 10px;
                max-width: none;
                width: auto;
                font-size: 11px;
                padding: 8px;
            }
            
            .preview-3d-instructions h4 {
                font-size: 12px;
                margin-bottom: 8px;
            }
            
            .preview-3d-instructions h5 {
                font-size: 10px;
                margin: 8px 0 4px 0;
            }
            
            .preview-3d-instructions li {
                font-size: 10px;
                margin-bottom: 2px;
            }
        }
        
        @media (max-width: 480px) {
            /* 小屏手机进一步优化 */
            .container {
                padding: 8px;
            }
            
            .header-container h1 {
                font-size: 18px;
            }
            
            .control-group {
                margin-bottom: 12px;
            }
            
            /* 小屏主要按钮优化 */
            .primary-actions button {
                font-size: 13px;
                padding: 12px 14px;
                min-width: 160px;
            }
            
            .seeds-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                gap: 6px;
            }
            
            .legend-grid {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            
            .floor-selector button {
                min-width: 50px;
                padding: 6px 8px;
                font-size: 11px;
            }
            
            /* 小屏手机3D预览进一步优化 */
            .preview-3d-header {
                padding: 10px 8px;
            }
            
            .preview-3d-title {
                font-size: 14px;
            }
            
            .preset-view-btn {
                padding: 6px 8px;
                font-size: 10px;
                min-width: 50px;
            }
            
            .preview-3d-close {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .preview-3d-canvas {
                height: calc(100vh - 110px);
            }
            
            .preview-3d-instructions {
                top: 110px;
                left: 8px;
                right: 8px;
                padding: 6px;
                font-size: 10px;
            }
            
            .preview-3d-instructions h4 {
                font-size: 11px;
                margin-bottom: 6px;
            }
        }

        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex: 1;
        }

        button:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .export-btn {
            background: var(--button-secondary);
        }

        .export-btn:hover {
            background: var(--button-secondary-hover);
        }

        .floor-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            transition: all 0.3s ease;
        }
        
        .overlay-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            margin-left: 20px;
        }
        
        .overlay-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .overlay-btn.active {
            background: linear-gradient(135deg, #764ba2, #667eea);
            border-color: #8a5ec7;
        }

        .floor-btn {
            padding: 10px 20px;
            background: var(--border-color);
            color: var(--text-muted);
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            min-width: 80px;
        }

        .floor-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .floor-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-hover);
        }

        #canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            background: var(--canvas-bg);
            transition: all 0.3s ease;
        }

        .map-header {
            background: linear-gradient(to right, #2c5f2d, #1a3d1a);
            color: white;
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            transition: background 0.3s ease;
        }

        [data-theme="light"] .map-header {
            background: linear-gradient(to right, #4CAF50, #388E3C);
            color: white;
        }

        .map-name {
            font-weight: bold;
            font-size: 16px;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            transition: all 0.3s ease;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            font-size: 0.85em;
            transition: color 0.3s ease;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            transition: border 0.3s ease;
        }
        
        /* 种子面板样式 */
        .seeds-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            width: 300px;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-primary);
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .seeds-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            position: relative;
        }
        
        .seeds-panel h3 {
            margin: 0;
            color: var(--accent-color);
            font-size: 18px;
            transition: color 0.3s ease;
            flex: 1;
            text-align: center;
        }
        
        .seeds-panel-close {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
            line-height: 1;
            min-height: auto;
        }
        
        .seeds-panel-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }
        
        .seeds-panel-close:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .seed-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .seed-controls button {
            flex: 1;
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .seed-controls button:hover {
            background: #45a049;
        }
        
        .seeds-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .seed-item {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .seed-item:hover {
            background: #4a4a4a;
            border-color: #4CAF50;
        }
        
        .seed-item.selected {
            background: #4CAF50;
            border-color: #45a049;
        }
        
        .seed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
                .seed-name {
            font-weight: bold;
            color: var(--accent-color);
            transition: color 0.3s ease;
        }

        .seed-date {
            font-size: 11px;
            color: var(--text-darker);
            transition: color 0.3s ease;
        }

        .seed-params {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.3;
            transition: color 0.3s ease;
        }
        
        .seed-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
                .seed-actions button {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .seed-actions button:hover {
            background: var(--border-color);
            color: var(--text-primary);
        }
        
        .seed-actions button.delete {
            background: #d32f2f;
        }
        
        .seed-actions button.delete:hover {
            background: #b71c1c;
        }

        /* 3D预览相关样式 */
        .preview-3d-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(5px);
            transition: background 0.3s ease;
        }

        [data-theme="light"] .preview-3d-container {
            background: rgba(255, 255, 255, 0.95);
        }

        .preview-3d-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .preview-3d-header {
            background: rgba(26, 26, 26, 0.9);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        [data-theme="light"] .preview-3d-header {
            background: rgba(248, 248, 248, 0.95);
            border-bottom: 1px solid var(--border-color);
        }

        .preview-3d-title {
            color: var(--text-primary);
            font-size: 1.2em;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        .preview-3d-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .preview-3d-close {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
        }

        .preview-3d-close:hover {
            background: #b71c1c;
        }

        .preview-3d-canvas {
            flex: 1;
            width: 100%;
            height: calc(100vh - 60px);
            background: var(--canvas-bg);
            transition: background 0.3s ease;
        }

        .preview-3d-instructions {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-secondary);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.3;
            width: 280px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px var(--shadow-light);
            transition: all 0.3s ease;
        }

        [data-theme="light"] .preview-3d-instructions {
            background: rgba(255, 255, 255, 0.9);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .preview-3d-instructions h4 {
            color: var(--accent-color);
            margin-bottom: 12px;
            font-size: 14px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            transition: all 0.3s ease;
        }

        .preview-3d-instructions h5 {
            color: var(--button-secondary);
            margin: 10px 0 6px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.3s ease;
        }

        .preview-3d-instructions ul {
            list-style: none;
            padding: 0;
            margin: 0 0 10px 0;
        }

        .preview-3d-instructions li {
            margin-bottom: 3px;
            padding: 2px 0;
            font-size: 11px;
        }

        .control-section {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
            transition: border-bottom 0.3s ease;
        }

        .control-section:last-of-type {
            border-bottom: none;
            margin-bottom: 8px;
        }

        .status-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            transition: background 0.3s ease;
        }

        [data-theme="light"] .status-section {
            background: rgba(0, 0, 0, 0.05);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 10px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .preset-view-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 5px;
            transition: all 0.2s ease;
        }

        .preset-view-btn:hover {
            background: var(--border-color);
            color: var(--text-primary);
            transform: translateY(-1px);
        }

        .preset-view-btn:active,
        .preset-view-btn.active {
            background: var(--button-secondary);
            color: white;
            border-color: var(--button-secondary);
        }

        /* UCC导出使用说明弹窗样式 */
        .ucc-tutorial-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
        }

        .ucc-tutorial-modal-content {
            background: var(--bg-primary);
            border: 2px solid var(--accent-color);
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }

        .ucc-tutorial-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
        }

        .ucc-tutorial-modal-header h2 {
            margin: 0;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
        }

        .ucc-tutorial-close {
            background: none;
            border: none;
            color: white;
            font-size: 2em;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .ucc-tutorial-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .ucc-tutorial-modal-body {
            padding: 25px;
        }

        .ucc-tutorial-step {
            display: flex;
            margin-bottom: 25px;
            align-items: flex-start;
            gap: 15px;
        }

        .ucc-tutorial-step-number {
            background: var(--accent-color);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1em;
            flex-shrink: 0;
        }

        .ucc-tutorial-step-content h3 {
            margin: 0 0 10px 0;
            color: var(--accent-color);
            font-size: 1.2em;
        }

        .ucc-tutorial-step-content p {
            margin: 5px 0;
            color: var(--text-primary);
            line-height: 1.5;
        }

        .ucc-tutorial-step-content strong {
            color: var(--accent-color);
            font-weight: bold;
        }

        .ucc-tutorial-tips {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .ucc-tutorial-tips h4 {
            margin: 0 0 15px 0;
            color: var(--accent-color);
            font-size: 1.1em;
        }

        .ucc-tutorial-tips ul {
            margin: 0;
            padding-left: 20px;
        }

        .ucc-tutorial-tips li {
            margin-bottom: 8px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .ucc-tutorial-modal-footer {
            padding: 20px 25px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            background: var(--bg-secondary);
            border-radius: 0 0 15px 15px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to { 
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .ucc-tutorial-modal-content {
                width: 95%;
                margin: 20px;
            }
            
            .ucc-tutorial-modal-header {
                padding: 15px 20px;
            }
            
            .ucc-tutorial-modal-header h2 {
                font-size: 1.3em;
            }
            
            .ucc-tutorial-modal-body {
                padding: 20px;
            }
            
            .ucc-tutorial-step {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }
            
            .ucc-tutorial-modal-footer {
                flex-direction: column;
                gap: 10px;
            }
        }


    </style>
</head>
<body>
    <div class="container">
        <div class="header-container">
            <h1>🎮 CF风格多层竞技地图生成器</h1>
            <div class="theme-toggle" onclick="toggleTheme()">
                <span class="theme-icon">🌙</span>
                <span class="theme-text">深色</span>
            </div>
        </div>
        <div class="subtitle">生成多层爆破模式竞技地图</div>
        
        <div class="controls">
            <div class="control-group">
                <label>地图X尺寸: <span class="value-display" id="sizeXValue">200</span></label>
                <input type="range" id="mapSizeX" min="20" max="800" value="200" step="10">
            </div>
            
            <div class="control-group">
                <label>地图Y尺寸: <span class="value-display" id="sizeYValue">200</span></label>
                <input type="range" id="mapSizeY" min="20" max="800" value="200" step="10">
            </div>
            
            <div class="control-group">
                <label>地图层数: <span class="value-display" id="floorsValue">1</span></label>
                <input type="range" id="floorCount" min="1" max="10" value="1" step="1">
            </div>
            
            <div class="control-group">
                <label>房间数量: <span class="value-display" id="roomValue">12</span></label>
                <input type="range" id="roomCount" min="0" max="100" value="12">
            </div>
            
            <div class="control-group">
                <label>房间大小: <span class="value-display" id="roomSizeValue">中</span></label>
                <input type="range" id="roomSize" min="0" max="4" value="2">
            </div>
            
            <div class="control-group">
                <label>房间位置: </label>
                <select id="roomPosition">
                    <option value="random" selected>随机位置</option>
                    <option value="inner">道路内侧</option>
                    <option value="outer">道路外侧</option>
                    <option value="mixed">混合位置</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>走廊宽度: <span class="value-display" id="corridorValue">2-4</span></label>
                <input type="range" id="corridorWidth" min="0" max="10" value="2">
            </div>
            
            <div class="control-group">
                <label>道路曲折度: <span class="value-display" id="pathValue">中</span></label>
                <input type="range" id="pathComplexity" min="0" max="4" value="2">
            </div>
            

            
            <div class="control-group">
                <label>走廊模式: </label>
                <select id="corridorRandom">
                    <option value="fixed">固定宽度</option>
                    <option value="random" selected>随机宽度</option>
                    <option value="varied">变化宽度</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>掩体密度: <span class="value-display" id="coverValue">0</span>%</label>
                <input type="range" id="coverDensity" min="0" max="100" value="0" step="5">
            </div>
            
            <div class="control-group">
                <label>水域: <span class="value-display" id="waterValue">0</span>%</label>
                <input type="range" id="waterAmount" min="0" max="50" value="0" step="5">
            </div>
            
            <div class="control-group">
                <label>楼梯数: <span class="value-display" id="stairsValue">0</span></label>
                <input type="range" id="stairsCount" min="0" max="20" value="0">
            </div>
            
            <div class="control-group">
                <label>窗户密度: <span class="value-display" id="windowValue">0</span>%</label>
                <input type="range" id="windowDensity" min="0" max="100" value="0" step="10">
            </div>
            
            <div class="control-group">
                <label>高低差: <span class="value-display" id="elevationValue">中</span></label>
                <input type="range" id="elevation" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>狙击长道: <span class="value-display" id="longValue">0</span></label>
                <input type="range" id="longLanes" min="0" max="20" value="0">
            </div>
            
            <div class="control-group">
                <label>中路控制: </label>
                <select id="midControl">
                    <option value="none">无中路</option>
                    <option value="single" selected>单中路</option>
                    <option value="double">双中路</option>
                    <option value="complex">复杂中路</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>旋转时间: <span class="value-display" id="rotateValue">中</span></label>
                <input type="range" id="rotateTime" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>垂直度: <span class="value-display" id="verticalValue">20</span>%</label>
                <input type="range" id="verticality" min="0" max="100" value="20" step="10">
            </div>
            
            <div class="control-group">
                <label>可破坏物: <span class="value-display" id="breakValue">10</span>%</label>
                <input type="range" id="breakables" min="0" max="100" value="10" step="5">
            </div>
            
            <div class="control-group">
                <label>场地布局: </label>
                <select id="fieldLayout">
                    <option value="indoor" selected>纯内场</option>
                    <option value="outdoor">纯外场</option>
                    <option value="mixed">混合场地</option>
                    <option value="central_outdoor">中央外场</option>
                    <option value="peripheral_outdoor">边缘外场</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>游戏模式: </label>
                <select id="gameMode">
                    <option value="team" selected>团队竞技</option>
                    <option value="bomb">爆破模式</option>
                    <option value="zombie">生化模式</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>地图风格: </label>
                <select id="mapStyle">
                    <option value="balanced" selected>平衡型</option>
                    <option value="ct_sided">CT优势</option>
                    <option value="t_sided">T优势</option>
                    <option value="aim_heavy">枪法型</option>
                    <option value="tactical">战术型</option>
                    <option value="rush">快攻型</option>
                    <option value="black_town">黑色城镇</option>
                    <option value="desert_gray">沙漠灰</option>
                    <option value="new_year_plaza">新年广场</option>
                    <option value="white_house">白房</option>
                    <option value="transport_ship">运输船</option>
                    <option value="satellite_base">卫星基地</option>
                    <option value="harbor_dock">港口码头</option>
                    <option value="subway_station">地铁站</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>外场比例: <span class="value-display" id="outdoorValue">20</span>%</label>
                <input type="range" id="outdoorRatio" min="0" max="100" value="20" step="5">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="outdoorWall" style="margin-right:8px;vertical-align:middle;"> 外场围墙
                </label>
            </div>
            
            
            
            <div class="control-group">
                <label>大道生成: <span class="value-display" id="longLaneValue">中</span></label>
                <input type="range" id="longLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>小道生成: <span class="value-display" id="shortLaneValue">中</span></label>
                <input type="range" id="shortLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>中路生成: <span class="value-display" id="midLaneValue">中</span></label>
                <input type="range" id="midLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>高台生成: <span class="value-display" id="platformValue">中</span></label>
                <input type="range" id="platform" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>暗道生成: <span class="value-display" id="underpassValue">中</span></label>
                <input type="range" id="underpass" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>连接路生成: <span class="value-display" id="connectorValue">中</span></label>
                <input type="range" id="connector" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>斜坡生成: <span class="value-display" id="rampValue">中</span></label>
                <input type="range" id="ramp" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>转点路线: <span class="value-display" id="rotationValue">中</span></label>
                <input type="range" id="rotation" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>包点数量: <span class="value-display" id="bombSiteValue">2</span></label>
                <input type="range" id="bombSiteCount" min="1" max="5" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>阴点密度: <span class="value-display" id="shadowPointValue">无</span></label>
                <input type="range" id="shadowPoint" min="0" max="4" value="0" step="1">
            </div>
            
            <div class="control-group">
                <label>房间填充: <span class="value-display" id="roomFillValue">无</span></label>
                <input type="range" id="roomFill" min="0" max="4" value="0" step="1">
            </div>
            
            <div class="control-group">
                <label>生成大厅: </label>
                <select id="generateLobby">
                    <option value="none">无大厅</option>
                    <option value="small" selected>小型大厅</option>
                    <option value="medium">中型大厅</option>
                    <option value="large">大型大厅</option>
                    <option value="central">中央大厅</option>
                    <option value="circle">圆形大厅</option>
                    <option value="cross">十字大厅</option>
                    <option value="square">方形大厅</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>投掷物点: <span class="value-display" id="nadeValue">15</span></label>
                <input type="range" id="nadeSpots" min="5" max="100" value="15" step="5">
            </div>
            
            <!-- UCC导出设置 -->
            <div class="control-group">
                <label style="color: var(--accent-color); font-weight: bold; border-bottom: 1px solid var(--accent-color); margin-bottom: 10px; padding-bottom: 5px;">UCC导出设置</label>
            </div>
            
            <div class="control-group">
                <label>Z轴旋转角度: <span class="value-display" id="uccZRotationValue">180</span>°</label>
                <input type="range" id="uccZRotation" min="-360" max="360" value="180" step="1">
            </div>
            
            <div class="control-group">
                <label>位置倍增器: <span class="value-display" id="uccPositionMultiplierValue">1.00</span></label>
                <input type="range" id="uccPositionMultiplier" min="0.1" max="10" value="1" step="0.1">
            </div>
            
            <div class="control-group">
                <label>缩放倍增器: <span class="value-display" id="uccScaleMultiplierValue">1.00</span></label>
                <input type="range" id="uccScaleMultiplier" min="0.1" max="10" value="1" step="0.1">
            </div>
            
            <div class="control-group">
                <label>墙体高度: <span class="value-display" id="uccWallHeightValue">1.00</span></label>
                <input type="range" id="uccWallHeight" min="0.1" max="10" value="1" step="0.1">
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="uccAutoConvertNegative" style="margin-right:8px;vertical-align:middle;"> 负值转正
                </label>
            </div>
            
            <div class="control-group">
                <label></label>
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
                    <input type="file" id="templateFileInput" accept=".ucc" style="display:none;" />
                </div>
            </div>
            
            <div class="control-group">
                <div class="button-group unified-actions">
                    <button class="btn btn--primary btn--lg" id="generateBtn">生成地图</button>
                    <button class="btn btn--secondary btn--lg" id="randomBtn">随机生成</button>
                    <button class="btn btn--outline btn--lg" id="preview3DBtn">3D预览</button>
                    <button class="btn btn--ghost btn--lg export-btn" id="exportBtn">导出</button>
                    <button class="btn btn--ghost btn--lg export-btn" id="exportUCCBtn">导出UCC</button>
                </div>
                
                <!-- UCC导出日志 -->
                <div class="control-group">
                    <label></label>
                    <div id="uccExportLog" style="background: var(--bg-tertiary); padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; color: var(--text-secondary);"></div>
                </div>
            </div>
        </div>
        
        <div class="map-header">
            <div class="map-name" id="mapName">竞技地图</div>
            <div>多层爆破模式</div>
        </div>
        
        <div class="floor-selector" id="floorSelector"></div>
        
        <canvas id="canvas"></canvas>
        
        <div class="seeds-panel">
            <div class="seeds-panel-header">
                <h3>种子收藏</h3>
                <button class="seeds-panel-close" id="seedsPanelCloseBtn">✕</button>
            </div>
            <div class="seed-controls">
                <button id="saveSeedBtn">💾 保存当前种子</button>
                <button id="clearSeedsBtn">🗑️ 清空收藏</button>
            </div>
            <div class="seeds-list" id="seedsList">
                <!-- 种子列表将在这里动态生成 -->
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a4a4a;"></div>
                <span>中等地</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a6a4a;"></div>
                <span>高地</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a2a4a;"></div>
                <span>低地</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #b0b0b0;"></div>
                <span>墙壁</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #303030;"></div>
                <span>掩体</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a4d69;"></div>
                <span>水域</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8B7355;"></div>
                <span>楼梯(上)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6B5345;"></div>
                <span>楼梯(下)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a8caf;"></div>
                <span>窗户</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a5a00;"></div>
                <span>A包点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a3a00;"></div>
                <span>B包点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a1a00;"></div>
                <span>C包点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3a5a00;"></div>
                <span>D包点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #1a5a00;"></div>
                <span>E包点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a4a4a;"></div>
                <span>狙击长道</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3a2020;"></div>
                <span>T出生点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #202030;"></div>
                <span>CT出生点</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a8a6a;"></div>
                <span>外场地面</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a8a7a;"></div>
                <span>外场围墙</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a7a8a;"></div>
                <span>大厅</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a6a7a;"></div>
                <span>大厅入口</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a6a8a;"></div>
                <span>大厅中心</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                <span>叠加视图</span>
            </div>
        </div>
    </div>

    <!-- 3D预览容器 -->
    <div class="preview-3d-container" id="preview3DContainer">
        <div class="preview-3d-content">
            <div class="preview-3d-header">
                <div class="preview-3d-title">🎮 3D地图预览</div>
                <div class="preview-3d-controls">
                    <button class="preset-view-btn" id="topViewBtn" title="俯视角度">🔝 俯视</button>
                    <button class="preset-view-btn" id="isometricViewBtn" title="等轴视角">📐 等轴</button>
                    <button class="preset-view-btn" id="perspectiveViewBtn" title="透视角度">👁️ 透视</button>
                    <button class="preset-view-btn" id="walkViewBtn" title="行走视角">🚶 行走</button>
                    <button class="preview-3d-close" id="close3DBtn">关闭</button>
                </div>
            </div>
            <div class="preview-3d-canvas" id="preview3DCanvas"></div>
            <div class="preview-3d-instructions">
                <h4>🎮 操作说明</h4>
                <div class="control-section">
                    <h5>🖱️ 鼠标控制</h5>
                    <ul>
                        <li>左键拖拽：旋转视角</li>
                        <li>右键拖拽：平移视角</li>
                        <li>滚轮：缩放视角</li>
                        <li>双击：聚焦到地图中心</li>
                    </ul>
                </div>
                <div class="control-section">
                    <h5>⌨️ 键盘快捷键</h5>
                    <ul>
                        <li>R：重置视角</li>
                        <li>F：聚焦地图</li>
                        <li>1-4：切换预设视角</li>
                        <li>+/-：缩放</li>
                        <li>方向键：移动视角</li>
                        <li>ESC：关闭预览</li>
                    </ul>
                </div>
                <div class="control-section">
                    <h5>📱 触屏支持</h5>
                    <ul>
                        <li>单指拖拽：旋转</li>
                        <li>双指捏合：缩放</li>
                        <li>双指拖拽：平移</li>
                    </ul>
                </div>
                <div class="status-section">
                    <div class="status-item">
                        控制器：<span id="controlStatus">🔧 加载中...</span>
                    </div>
                    <div class="status-item">
                        状态：<span id="debug3DStatus">初始化中...</span>
                    </div>
                    <div class="status-item">
                        帧率：<span id="fpsCounter">-- FPS</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let mapFloors = [];
        let currentFloor = 0;
        let totalFloors = 2;
        let overlayMode = false;
        
        // 3D预览相关变量
        let scene3D, camera3D, renderer3D, controls3D;
        let preview3DActive = false;
        
        // 增强控制变量
        let cameraAnimating = false;
        let targetPosition = new THREE.Vector3();
        let targetLookAt = new THREE.Vector3();
        let cameraVelocity = new THREE.Vector3();
        let lastCameraUpdate = 0;
        let mapCenter = new THREE.Vector3();
        let currentPresetView = 'perspective';
        
        // 帧率监控
        let frameCount = 0;
        let lastFPSUpdate = 0;
        
        // 触摸控制变量
        let touches = {};
        let touchStartDistance = 0;
        let touchStartCenter = { x: 0, y: 0 };
        
        // 地图元素类型
        const TileType = {
            VOID: 0,
            FLOOR: 1,
            WALL: 2,
            DOOR: 3,
            WINDOW: 4,
            COVER: 5,
            BOMBSITE_A: 6,
            BOMBSITE_B: 7,
            BOMBSITE_C: 40, // 新增包点C
            BOMBSITE_D: 41, // 新增包点D
            BOMBSITE_E: 42, // 新增包点E
            T_SPAWN: 8,
            CT_SPAWN: 9,
            STAIRS_UP: 10,
            STAIRS_DOWN: 11,
            WATER: 12,
            BRIDGE: 13,
            ELEVATED: 14,      // 高台
            LOWERED: 15,       // 低地
            BREAKABLE: 16,     // 可破坏墙
            HIGH_GROUND: 29,   // 高地
            LOW_GROUND: 30,    // 低地
            MEDIUM_GROUND: 31, // 中等地
            MID_AREA: 18,      // 中路区域
            NADE_SPOT: 19,     // 投掷物点
            BOOST_SPOT: 20,    // 跳点位置
            ONE_WAY: 21,       // 单向位置
            OUTDOOR: 22,       // 外场地面
            OUTDOOR_WALL: 23,  // 外场墙壁/围墙
            OUTDOOR_COVER: 24, // 外场掩体（集装箱、车辆等）
            SKYBOX: 25,       // 天空盒区域
            LOBBY: 26,        // 大厅
            LOBBY_ENTRANCE: 27, // 大厅入口
            LOBBY_CENTER: 28,  // 大厅中心
            // 常见地形/模块
            LONG_LANE: 32,     // 大道（长直通道）
            SHORT_LANE: 33,    // 小道（窄通道）
            MID_LANE: 34,      // 中路（交汇区）
            PLATFORM: 35,      // 高台/平台
            UNDERPASS: 36,     // 暗道/下水道
            CONNECTOR: 37,     // 连接路
            RAMP: 38,          // 斜坡
            ROTATION_PATH: 39, // 转点/轮转路线
            SHADOW_POINT: 43   // 阴点（垂直小墙体）
        };
        
        // 更新滑块显示
        document.getElementById('mapSizeX').oninput = function() {
            document.getElementById('sizeXValue').textContent = this.value;
        };
        
        document.getElementById('mapSizeY').oninput = function() {
            document.getElementById('sizeYValue').textContent = this.value;
        };
        
        document.getElementById('floorCount').oninput = function() {
            document.getElementById('floorsValue').textContent = this.value;
        };
        
        document.getElementById('roomCount').oninput = function() {
            document.getElementById('roomValue').textContent = this.value;
        };
        
        document.getElementById('corridorWidth').oninput = function() {
            const val = parseInt(this.value);
            const mode = document.getElementById('corridorRandom').value;
            if (mode === 'fixed') {
                document.getElementById('corridorValue').textContent = val + 1;
            } else if (mode === 'random') {
                document.getElementById('corridorValue').textContent = val + '-' + (val + 2);
            } else {
                document.getElementById('corridorValue').textContent = '1-' + (val + 2);
            }
        };
        
        document.getElementById('coverDensity').oninput = function() {
            document.getElementById('coverValue').textContent = this.value;
        };
        
        document.getElementById('waterAmount').oninput = function() {
            document.getElementById('waterValue').textContent = this.value;
        };
        
        document.getElementById('stairsCount').oninput = function() {
            document.getElementById('stairsValue').textContent = this.value;
        };
        
        document.getElementById('outdoorRatio').oninput = function() {
            document.getElementById('outdoorValue').textContent = this.value;
        };
        
        // 外场围墙参数
        document.getElementById('outdoorWall').onchange = function() {
            // 可选择在此触发预览刷新
        };
        
        // 常见地形/模块参数事件监听器
        document.getElementById('longLane').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('longLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('shortLane').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('shortLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('midLane').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('midLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('platform').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('platformValue').textContent = values[this.value];
        };
        
        document.getElementById('underpass').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('underpassValue').textContent = values[this.value];
        };
        
        document.getElementById('connector').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('connectorValue').textContent = values[this.value];
        };
        
        document.getElementById('ramp').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('rampValue').textContent = values[this.value];
        };
        
        document.getElementById('rotation').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('rotationValue').textContent = values[this.value];
        };
        
        document.getElementById('bombSiteCount').oninput = function() {
            document.getElementById('bombSiteValue').textContent = this.value;
        };
        
        document.getElementById('shadowPoint').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('shadowPointValue').textContent = values[this.value];
        };
        
        document.getElementById('pathComplexity').oninput = function() {
            const values = ['直线', '微弯', '中等', '曲折', '迷宫'];
            document.getElementById('pathValue').textContent = values[this.value];
        };
        

        
        document.getElementById('elevation').oninput = function() {
            const values = ['低', '中', '高'];
            document.getElementById('elevationValue').textContent = values[this.value];
        };
        
        document.getElementById('roomSize').oninput = function() {
            const values = ['极小', '小', '中', '大', '极大'];
            document.getElementById('roomSizeValue').textContent = values[this.value];
        };
        
        document.getElementById('roomFill').oninput = function() {
            const values = ['无', '少', '中', '多', '极多'];
            document.getElementById('roomFillValue').textContent = values[this.value];
        };
        
        document.getElementById('longLanes').oninput = function() {
            document.getElementById('longValue').textContent = this.value;
        };
        
        document.getElementById('rotateTime').oninput = function() {
            const values = ['短', '中', '长'];
            document.getElementById('rotateValue').textContent = values[this.value];
        };
        
        document.getElementById('verticality').oninput = function() {
            document.getElementById('verticalValue').textContent = this.value;
        };
        
        document.getElementById('breakables').oninput = function() {
            document.getElementById('breakValue').textContent = this.value;
        };
        
        document.getElementById('nadeSpots').oninput = function() {
            document.getElementById('nadeValue').textContent = this.value;
        };
        
        // UCC导出控制器
        document.getElementById('uccZRotation').oninput = function() {
            document.getElementById('uccZRotationValue').textContent = this.value;
        };
        
        document.getElementById('uccPositionMultiplier').oninput = function() {
            document.getElementById('uccPositionMultiplierValue').textContent = parseFloat(this.value).toFixed(2);
        };
        
        document.getElementById('uccScaleMultiplier').oninput = function() {
            document.getElementById('uccScaleMultiplierValue').textContent = parseFloat(this.value).toFixed(2);
        };
        
        document.getElementById('uccWallHeight').oninput = function() {
            document.getElementById('uccWallHeightValue').textContent = parseFloat(this.value).toFixed(2);
        };
        
        // 游戏模式选择事件
        document.getElementById('gameMode').onchange = function() {
            const gameMode = this.value;
            applyGameMode(gameMode);
        };
        
        // 地图风格选择事件
        document.getElementById('mapStyle').onchange = function() {
            const mapStyle = this.value;
            applyMapStyle(mapStyle);
        };
        
        // 安全设置元素值的辅助函数
        function safeSetValue(elementId, value) {
            try {
                const element = document.getElementById(elementId);
                if (element) {
                    element.value = value;
                    return true;
                }
            } catch (error) {
                console.warn(`无法设置元素 ${elementId} 的值:`, error);
            }
            return false;
        }
        
        // 安全设置元素文本的辅助函数
        function safeSetText(elementId, text) {
            try {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = text;
                    return true;
                }
            } catch (error) {
                console.warn(`无法设置元素 ${elementId} 的文本:`, error);
            }
            return false;
        }
        
        // 安全设置复选框状态的辅助函数
        function safeSetChecked(elementId, checked) {
            try {
                const element = document.getElementById(elementId);
                if (element) {
                    element.checked = checked;
                    return true;
                }
            } catch (error) {
                console.warn(`无法设置元素 ${elementId} 的选中状态:`, error);
            }
            return false;
        }

        // 随机生成参数
        function randomizeParameters() {
            // 地图尺寸和楼层数保持不变，不随机化
            
            // 随机房间数量 (3-100)
            const roomCount = Math.floor(Math.random() * 98) + 3;
            safeSetValue('roomCount', roomCount);
            safeSetText('roomValue', roomCount);
            
            // 随机房间大小 (0-4)
            const roomSize = Math.floor(Math.random() * 5);
            safeSetValue('roomSize', roomSize);
            const roomSizeTexts = ['极小', '小', '中', '大', '极大'];
            safeSetText('roomSizeValue', roomSizeTexts[roomSize]);
            
            // 随机房间位置
            const roomPositions = ['random', 'inner', 'outer', 'mixed'];
            const roomPosition = roomPositions[Math.floor(Math.random() * roomPositions.length)];
            safeSetValue('roomPosition', roomPosition);
            
            // 随机走廊宽度 (1-10)
            const corridorWidth = Math.floor(Math.random() * 10) + 1;
            safeSetValue('corridorWidth', corridorWidth);
            const corridorMode = document.getElementById('corridorRandom')?.value || 'fixed';
            let corridorValueText;
            if (corridorMode === 'fixed') {
                corridorValueText = corridorWidth + 1;
            } else if (corridorMode === 'random') {
                corridorValueText = corridorWidth + '-' + (corridorWidth + 2);
            } else {
                corridorValueText = '1-' + (corridorWidth + 2);
            }
            safeSetText('corridorValue', corridorValueText);
            
            // 随机道路曲折度 (0-4)
            const pathComplexity = Math.floor(Math.random() * 5);
            safeSetValue('pathComplexity', pathComplexity);
            const complexityTexts = ['简单', '较简单', '中', '较复杂', '复杂'];
            safeSetText('pathValue', complexityTexts[pathComplexity]);
            

            
            // 随机走廊模式
            const corridorModes = ['fixed', 'random', 'varied'];
            const corridorModeRandom = corridorModes[Math.floor(Math.random() * corridorModes.length)];
            safeSetValue('corridorRandom', corridorModeRandom);
            
            // 随机掩体密度 (10-100)
            const coverDensity = Math.floor(Math.random() * 91) + 10;
            safeSetValue('coverDensity', coverDensity);
            safeSetText('coverValue', coverDensity);
            
            // 随机水域 (0-50)
            const waterAmount = Math.floor(Math.random() * 51);
            safeSetValue('waterAmount', waterAmount);
            safeSetText('waterValue', waterAmount);
            
            // 随机楼梯数 (0-20)
            const stairsCount = Math.floor(Math.random() * 21);
            safeSetValue('stairsCount', stairsCount);
            safeSetText('stairsValue', stairsCount);
            
            // 随机窗户密度 (0-100)
            const windowDensity = Math.floor(Math.random() * 101);
            safeSetValue('windowDensity', windowDensity);
            safeSetText('windowValue', windowDensity);
            
            // 随机高低差 (0-2)
            const elevation = Math.floor(Math.random() * 3);
            safeSetValue('elevation', elevation);
            const elevationTexts = ['无', '中', '高'];
            safeSetText('elevationValue', elevationTexts[elevation]);
            
            // 狙击长道保持用户设置，不随机化
            
            // 随机中路控制
            const midControls = ['none', 'single', 'double', 'complex'];
            const midControl = midControls[Math.floor(Math.random() * midControls.length)];
            safeSetValue('midControl', midControl);
            
            // 随机旋转时间 (0-2)
            const rotateTime = Math.floor(Math.random() * 3);
            safeSetValue('rotateTime', rotateTime);
            const rotateTexts = ['短', '中', '长'];
            safeSetText('rotateValue', rotateTexts[rotateTime]);
            
            // 随机垂直度 (0-100)
            const verticality = Math.floor(Math.random() * 101);
            safeSetValue('verticality', verticality);
            safeSetText('verticalValue', verticality);
            
            // 随机可破坏物 (0-100)
            const breakables = Math.floor(Math.random() * 101);
            safeSetValue('breakables', breakables);
            safeSetText('breakValue', breakables);
            
            // 随机场地布局
            const fieldLayouts = ['indoor', 'outdoor', 'mixed', 'central_outdoor', 'peripheral_outdoor'];
            const fieldLayout = fieldLayouts[Math.floor(Math.random() * fieldLayouts.length)];
            safeSetValue('fieldLayout', fieldLayout);
            
            // 随机游戏模式
            const gameModes = ['team', 'bomb', 'zombie'];
            const gameMode = gameModes[Math.floor(Math.random() * gameModes.length)];
            safeSetValue('gameMode', gameMode);
            try {
                applyGameMode(gameMode);
            } catch (error) {
                console.warn('应用游戏模式失败:', error);
            }
            
            // 随机地图风格
            const mapStyles = ['balanced', 'ct_sided', 't_sided', 'aim_heavy', 'tactical', 'rush', 
                              'black_town', 'desert_gray', 'new_year_plaza', 'white_house', 
                              'transport_ship', 'satellite_base', 'harbor_dock', 'subway_station'];
            const mapStyle = mapStyles[Math.floor(Math.random() * mapStyles.length)];
            safeSetValue('mapStyle', mapStyle);
            try {
                applyMapStyle(mapStyle);
            } catch (error) {
                console.warn('应用地图风格失败:', error);
            }
            
            // 随机外场比例 (0-100)
            const outdoorRatio = Math.floor(Math.random() * 101);
            safeSetValue('outdoorRatio', outdoorRatio);
            safeSetText('outdoorValue', outdoorRatio);
            
            // 外场围墙：50% 概率启用
            const outdoorWall = Math.random() < 0.5;
            safeSetChecked('outdoorWall', outdoorWall);
            
            // 随机生成大厅
            const lobbyTypes = ['none', 'small', 'medium', 'large', 'central', 'circle', 'cross', 'square'];
            const lobbyType = lobbyTypes[Math.floor(Math.random() * lobbyTypes.length)];
            safeSetValue('generateLobby', lobbyType);
            
            // 随机常见地形/模块参数
            const longLane = Math.floor(Math.random() * 5);
            safeSetValue('longLane', longLane);
            const longLaneTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('longLaneValue', longLaneTexts[longLane]);
            
            const shortLane = Math.floor(Math.random() * 5);
            safeSetValue('shortLane', shortLane);
            const shortLaneTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('shortLaneValue', shortLaneTexts[shortLane]);
            
            const midLane = Math.floor(Math.random() * 5);
            safeSetValue('midLane', midLane);
            const midLaneTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('midLaneValue', midLaneTexts[midLane]);
            
            const platform = Math.floor(Math.random() * 5);
            safeSetValue('platform', platform);
            const platformTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('platformValue', platformTexts[platform]);
            
            const underpass = Math.floor(Math.random() * 5);
            safeSetValue('underpass', underpass);
            const underpassTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('underpassValue', underpassTexts[underpass]);
            
            const connector = Math.floor(Math.random() * 5);
            safeSetValue('connector', connector);
            const connectorTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('connectorValue', connectorTexts[connector]);
            
            const ramp = Math.floor(Math.random() * 5);
            safeSetValue('ramp', ramp);
            const rampTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('rampValue', rampTexts[ramp]);
            
            const rotation = Math.floor(Math.random() * 5);
            safeSetValue('rotation', rotation);
            const rotationTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('rotationValue', rotationTexts[rotation]);
            
            // 随机包点数量 (1-5)
            const bombSiteCount = Math.floor(Math.random() * 5) + 1;
            safeSetValue('bombSiteCount', bombSiteCount);
            safeSetText('bombSiteValue', bombSiteCount);
            
            // 随机阴点密度 (0-4)
            const shadowPoint = Math.floor(Math.random() * 5);
            safeSetValue('shadowPoint', shadowPoint);
            const shadowPointTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('shadowPointValue', shadowPointTexts[shadowPoint]);
            
            // 随机房间填充 (0-4)
            const roomFill = Math.floor(Math.random() * 5);
            safeSetValue('roomFill', roomFill);
            const roomFillTexts = ['无', '少', '中', '多', '极多'];
            safeSetText('roomFillValue', roomFillTexts[roomFill]);
            
            // 随机投掷物点 (5-100)
            const nadeSpots = Math.floor(Math.random() * 96) + 5;
            safeSetValue('nadeSpots', nadeSpots);
            safeSetText('nadeValue', nadeSpots);
        }
        
        // 安全的边界检查函数
        function isValidPosition(x, y, floor = 0) {
            if (!mapFloors || !mapFloors[floor]) return false;
            if (y < 0 || y >= mapFloors[floor].length) return false;
            if (!mapFloors[floor][y]) return false;
            if (x < 0 || x >= mapFloors[floor][y].length) return false;
            return true;
        }
        
        // 安全的数组访问函数
        function getTile(x, y, floor = 0, defaultValue = TileType.VOID) {
            if (!isValidPosition(x, y, floor)) return defaultValue;
            return mapFloors[floor][y][x];
        }
        
        // 安全的数组设置函数
        function setTile(x, y, value, floor = 0) {
            if (!isValidPosition(x, y, floor)) return false;
            mapFloors[floor][y][x] = value;
            return true;
        }

        // 初始化地图
        function initMap(sizeX, sizeY, floors) {
            mapFloors = [];
            totalFloors = floors;
            
            for (let f = 0; f < floors; f++) {
                mapFloors[f] = [];
                for (let y = 0; y < sizeY; y++) {
                    mapFloors[f][y] = [];
                    for (let x = 0; x < sizeX; x++) {
                        mapFloors[f][y][x] = TileType.VOID;
                    }
                }
            }
        }
        
        // 生成房间（支持内外场）
        function generateRooms(sizeX, sizeY, roomCount, floor) {
            const size = Math.max(sizeX, sizeY); // 向后兼容
            const rooms = [];
            // 根据房间大小参数调整房间尺寸
            const roomSizeParam = parseInt(document.getElementById('roomSize').value);
            const roomSizeMultipliers = [0.2, 0.4, 0.8, 1.5, 2.5]; // 极小、小、中、大、极大 - 增加差异
            const roomSizeMultiplier = roomSizeMultipliers[roomSizeParam];
            
            const minRoomSize = Math.max(2, Math.floor(size / 25 * roomSizeMultiplier)); // 最小房间尺寸
            const maxRoomSize = Math.max(minRoomSize + 1, Math.floor(size / 4 * roomSizeMultiplier)); // 最大房间尺寸，移除硬编码限制
            const fieldLayout = document.getElementById('fieldLayout').value;
            const outdoorRatio = parseInt(document.getElementById('outdoorRatio').value) / 100;
            const roomPosition = document.getElementById('roomPosition').value; // 房间生成位置
            
            // 先创建外场区域
            if (floor === 0 && fieldLayout !== 'indoor') {
                createOutdoorAreas(Math.max(sizeX, sizeY), fieldLayout, outdoorRatio);
            }
            
            // 计算房间间距（确保房间独立）
            const minSpacing = Math.max(1, Math.floor(size / 50)); // 进一步减小间距
            
            // 根据地图大小动态调整尝试次数，避免无限循环
            const mapSize = Math.max(sizeX, sizeY);
            const maxAttempts = Math.min(roomCount * 100, mapSize * 5, 10000); // 限制最大尝试次数
            for (let i = 0; i < maxAttempts; i++) {
                const width = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                const height = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                
                // 根据房间生成位置参数决定房间位置
                let x, y;
                const centerX = Math.floor(sizeX / 2);
                const centerY = Math.floor(sizeY / 2);
                const roadRadius = Math.floor(size / 3); // 假设道路在中心区域
                
                switch(roomPosition) {
                    case 'inner':
                        // 道路内侧（靠近中心）
                        const innerRadius = Math.floor(size / 4);
                        const angle = Math.random() * 2 * Math.PI;
                        const distance = Math.random() * innerRadius;
                        x = Math.floor(centerX + Math.cos(angle) * distance);
                        y = Math.floor(centerY + Math.sin(angle) * distance);
                        break;
                    case 'outer':
                        // 道路外侧（远离中心）
                        const outerRadius = Math.floor(size / 2.5);
                        const outerAngle = Math.random() * 2 * Math.PI;
                        const outerDistance = outerRadius + Math.random() * (size / 2 - outerRadius);
                        x = Math.floor(centerX + Math.cos(outerAngle) * outerDistance);
                        y = Math.floor(centerY + Math.sin(outerAngle) * outerDistance);
                        break;
                    case 'mixed':
                        // 混合位置
                        if (Math.random() > 0.5) {
                            // 内侧
                            const mixedAngle = Math.random() * 2 * Math.PI;
                            const mixedDistance = Math.random() * (size / 3);
                            x = Math.floor(centerX + Math.cos(mixedAngle) * mixedDistance);
                            y = Math.floor(centerY + Math.sin(mixedAngle) * mixedDistance);
                        } else {
                            // 外侧
                            const mixedOuterAngle = Math.random() * 2 * Math.PI;
                            const mixedOuterDistance = (size / 3) + Math.random() * (size / 2 - size / 3);
                            x = Math.floor(centerX + Math.cos(mixedOuterAngle) * mixedOuterDistance);
                            y = Math.floor(centerY + Math.sin(mixedOuterAngle) * mixedOuterDistance);
                        }
                        break;
                    default: // 'random'
                        // 随机位置
                        x = Math.floor(Math.random() * (sizeX - width - minSpacing * 2)) + minSpacing;
                        y = Math.floor(Math.random() * (sizeY - height - minSpacing * 2)) + minSpacing;
                        break;
                }
                
                // 确保房间在边界内
                x = Math.max(minSpacing, Math.min(x, sizeX - width - minSpacing));
                y = Math.max(minSpacing, Math.min(y, sizeY - height - minSpacing));
                
                // 额外检查：确保房间完全在地图范围内
                if (x < 0 || y < 0 || x + width > sizeX || y + height > sizeY) {
                    continue; // 跳过这个房间，尝试下一个
                }
                
                // 调试：显示房间位置信息
                if (rooms.length < 3) {
                    console.log(`房间${rooms.length + 1}: 位置(${x},${y}), 尺寸(${width}x${height}), 位置类型: ${roomPosition}`);
                }
                
                // 检查与现有房间的重叠和间距
                let canPlace = true;
                for (let room of rooms) {
                    // 检查重叠（减少间距要求）
                    const expandedX = room.x - Math.floor(minSpacing / 2);
                    const expandedY = room.y - Math.floor(minSpacing / 2);
                    const expandedWidth = room.width + Math.floor(minSpacing / 2) * 2;
                    const expandedHeight = room.height + Math.floor(minSpacing / 2) * 2;
                    
                    if (x < expandedX + expandedWidth && x + width > expandedX &&
                        y < expandedY + expandedHeight && y + height > expandedY) {
                        canPlace = false;
                        break;
                    }
                }
                
                // 检查是否与外场重叠（外场优先）
                if (canPlace && floor === 0) {
                    for (let cy = y - 1; cy < y + height + 1; cy++) {
                        for (let cx = x - 1; cx < x + width + 1; cx++) {
                            if (cy >= 0 && cy < size && cx >= 0 && cx < size) {
                            if (getTile(cx, cy, floor) === TileType.OUTDOOR) {
                                    canPlace = false;
                                break;
                            }
                        }
                        }
                        if (!canPlace) break;
                    }
                }
                
                if (canPlace) {
                    rooms.push({ x, y, width, height, floor, isIndoor: true });
                    
                    // 绘制房间（内场）- 确保墙壁完整
                    for (let ry = y; ry < y + height; ry++) {
                        for (let rx = x; rx < x + width; rx++) {
                            if (ry === y || ry === y + height - 1 || rx === x || rx === x + width - 1) {
                                // 房间边界墙壁
                                setTile(rx, ry, TileType.WALL, floor);
                                } else {
                                // 房间内部地板
                                setTile(rx, ry, TileType.FLOOR, floor);
                            }
                        }
                    }
                    
                    // 在房间周围添加缓冲区（减少缓冲区大小）
                    addRoomBuffer(x, y, width, height, floor, size, Math.floor(minSpacing / 2));
                    
                    if (rooms.length >= roomCount) break;
                }
            }
            
            // 调试信息：显示实际生成的房间数量
            console.log(`目标房间数量: ${roomCount}, 实际生成房间数量: ${rooms.length}`);
            console.log(`房间尺寸范围: ${minRoomSize}-${maxRoomSize}, 间距: ${minSpacing}`);
            console.log(`地图大小: ${size}x${size}, 房间大小倍数: ${roomSizeMultiplier}`);
            console.log(`房间大小参数: ${roomSizeParam} (${['极小', '小', '中', '大', '极大'][roomSizeParam]})`);
            console.log(`尝试次数: ${roomCount * 100}, 成功率: ${(rooms.length / roomCount * 100).toFixed(1)}%`);
            
            return rooms;
        }
        
        // 创建外场区域
        function createOutdoorAreas(size, layout, ratio) {
            // 外场尺寸/面积参数已移除，使用中性系数
            const sizeMultiplier = 1.0;
            const areaMultiplier = 1.0;
            const outdoorTiles = Math.floor(size * size * ratio * sizeMultiplier * areaMultiplier);
            
            // 获取实际的地图尺寸
            const actualSizeY = mapFloors[0] ? mapFloors[0].length : size;
            const actualSizeX = mapFloors[0] && mapFloors[0][0] ? mapFloors[0][0].length : size;
            
            switch(layout) {
                case 'outdoor':
                    // 全外场
                    for (let y = 0; y < actualSizeY; y++) {
                        for (let x = 0; x < actualSizeX; x++) {
                            setTile(x, y, TileType.OUTDOOR, 0);
                        }
                    }
                    break;
                    
                case 'central_outdoor':
                    // 中央外场（规则矩形）
                    const centerX = Math.floor(actualSizeX / 2);
                    const centerY = Math.floor(actualSizeY / 2);
                    const areaWidth = Math.floor(actualSizeX * Math.sqrt(ratio));
                    const areaHeight = Math.floor(actualSizeY * Math.sqrt(ratio));
                    
                    const startX = Math.max(0, centerX - Math.floor(areaWidth / 2));
                    const endX = Math.min(actualSizeX - 1, centerX + Math.floor(areaWidth / 2));
                    const startY = Math.max(0, centerY - Math.floor(areaHeight / 2));
                    const endY = Math.min(actualSizeY - 1, centerY + Math.floor(areaHeight / 2));
                    
                    for (let y = startY; y <= endY; y++) {
                        for (let x = startX; x <= endX; x++) {
                            setTile(x, y, TileType.OUTDOOR, 0);
                        }
                    }
                    break;
                    
                case 'peripheral_outdoor':
                    // 边缘外场（规则边框）
                    const marginX = Math.floor((1 - Math.sqrt(1 - ratio)) * actualSizeX / 2);
                    const marginY = Math.floor((1 - Math.sqrt(1 - ratio)) * actualSizeY / 2);
                    
                    for (let y = 0; y < actualSizeY; y++) {
                        for (let x = 0; x < actualSizeX; x++) {
                            if (x < marginX || x >= actualSizeX - marginX || 
                                y < marginY || y >= actualSizeY - marginY) {
                                setTile(x, y, TileType.OUTDOOR, 0);
                            }
                        }
                    }
                    break;
                    
                case 'mixed':
                default:
                    // 混合场地（规则矩形区域）
                    const numOutdoorAreas = 2 + Math.floor(Math.random() * 2); // 2-3个区域
                    const areaSize = Math.floor(Math.sqrt(outdoorTiles / numOutdoorAreas));
                    
                    for (let i = 0; i < numOutdoorAreas; i++) {
                        // 确保区域不重叠
                        let attempts = 0;
                        let placed = false;
                        
                        // 限制区域大小，避免超出边界
                        const maxAreaSize = Math.min(areaSize, Math.floor(Math.min(actualSizeX, actualSizeY) / 4));
                        
                        while (!placed && attempts < 50) {
                            const cx = Math.floor(Math.random() * (actualSizeX - maxAreaSize * 2)) + maxAreaSize;
                            const cy = Math.floor(Math.random() * (actualSizeY - maxAreaSize * 2)) + maxAreaSize;
                        
                            // 检查是否与现有外场区域重叠
                            let overlaps = false;
                            for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                    if (isValidPosition(x, y, 0)) {
                                        if (getTile(x, y, 0) === TileType.OUTDOOR) {
                                            overlaps = true;
                                            break;
                                        }
                                    }
                                }
                                if (overlaps) break;
                            }
                            
                            if (!overlaps) {
                                // 创建规则矩形外场区域
                                for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                    for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                        setTile(x, y, TileType.OUTDOOR, 0);
                                    }
                                }
                                placed = true;
                            }
                            attempts++;
                        }
                        
                        // 如果无法放置，在角落创建小区域
                        if (!placed) {
                            const cornerSize = Math.min(maxAreaSize, 10); // 限制角落区域大小
                            const cornerX = (i % 2 === 0) ? cornerSize : actualSizeX - cornerSize - 1;
                            const cornerY = (i < 2) ? cornerSize : actualSizeY - cornerSize - 1;
                            
                            for (let y = cornerY - cornerSize; y <= cornerY + cornerSize; y++) {
                                for (let x = cornerX - cornerSize; x <= cornerX + cornerSize; x++) {
                                    setTile(x, y, TileType.OUTDOOR, 0);
                                }
                            }
                        }
                    }
                    break;
            }
            
            // 在外场添加一些掩体和特征
            addOutdoorFeatures(size);
            
            // 可选：外场围墙，将外场边缘包围为墙
            const withOutdoorWall = document.getElementById('outdoorWall') && document.getElementById('outdoorWall').checked;
            if (withOutdoorWall) {
                addOutdoorWalls();
            }
        }

        // 为所有外场区域的边缘添加墙体
        function addOutdoorWalls() {
            if (!mapFloors || !mapFloors[0]) return;
            const height = mapFloors[0].length;
            const width = mapFloors[0][0].length;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (getTile(x, y, 0) === TileType.OUTDOOR) {
                        const neighbors = [
                            [x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]
                        ];
                        for (const [nx, ny] of neighbors) {
                            if (isValidPosition(nx, ny, 0)) {
                                const t = getTile(nx, ny, 0);
                                if (t !== TileType.OUTDOOR && t !== TileType.WALL) {
                                    setTile(nx, ny, TileType.WALL, 0);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // 生成大厅
        function generateLobby(size, floor) {
            const lobbyType = document.getElementById('generateLobby').value;
            
            if (lobbyType === 'none') return;
            
            let lobbyWidth, lobbyHeight, lobbyX, lobbyY;
            
            switch(lobbyType) {
                case 'small':
                    lobbyWidth = 8;
                    lobbyHeight = 6;
                    break;
                case 'medium':
                    lobbyWidth = 12;
                    lobbyHeight = 8;
                    break;
                case 'large':
                    lobbyWidth = 16;
                    lobbyHeight = 10;
                    break;
                case 'central':
                    lobbyWidth = 14;
                    lobbyHeight = 12;
                    break;
                case 'circle':
                    lobbyWidth = 12;
                    lobbyHeight = 12;
                    break;
                case 'cross':
                    lobbyWidth = 15;
                    lobbyHeight = 15;
                    break;
                case 'square':
                    lobbyWidth = 14;
                    lobbyHeight = 14;
                    break;
                default:
                    return;
            }
            
            // 确定大厅位置
            if (lobbyType === 'central') {
                // 中央大厅
                lobbyX = Math.floor((size - lobbyWidth) / 2);
                lobbyY = Math.floor((size - lobbyHeight) / 2);
            } else {
                // 随机位置，但避免与外场重叠
                let attempts = 0;
                do {
                    lobbyX = Math.floor(Math.random() * (size - lobbyWidth - 4)) + 2;
                    lobbyY = Math.floor(Math.random() * (size - lobbyHeight - 4)) + 2;
                    attempts++;
                } while (hasOutdoorOverlap(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) && attempts < 50);
                
                if (attempts >= 50) return; // 如果找不到合适位置，跳过
            }
            
            // 确保大厅完全在地图范围内
            if (lobbyX < 0 || lobbyY < 0 || lobbyX + lobbyWidth > size || lobbyY + lobbyHeight > size) {
                return; // 如果大厅超出边界，跳过
            }
            
            // 根据大厅类型创建不同形状
            switch(lobbyType) {
                case 'circle':
                    createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'cross':
                    createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'square':
                    createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                default:
                    createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
            }
            
            // 添加大厅入口
            addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
            
            // 连接大厅到其他区域
            connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
        }
        
        // 创建矩形大厅
        function createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // 墙壁
                        setTile(x, y, TileType.WALL, floor);
                    } else {
                        // 大厅内部
                        if (x === Math.floor(lobbyX + lobbyWidth / 2) && 
                            y === Math.floor(lobbyY + lobbyHeight / 2)) {
                            setTile(x, y, TileType.LOBBY_CENTER, floor);
                        } else {
                            setTile(x, y, TileType.LOBBY, floor);
                        }
                    }
                }
            }
        }
        
        // 创建圆形大厅
        function createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const radius = Math.min(lobbyWidth, lobbyHeight) / 2 - 1;
            
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    
                    if (distance <= radius) {
                        // 大厅内部
                        if (distance <= 1) {
                            setTile(x, y, TileType.LOBBY_CENTER, floor);
                        } else {
                            setTile(x, y, TileType.LOBBY, floor);
                        }
                    } else if (distance <= radius + 1) {
                        // 墙壁
                        setTile(x, y, TileType.WALL, floor);
                    }
                }
            }
        }
        
        // 创建十字大厅
        function createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const armWidth = 3;
            const armLength = Math.min(lobbyWidth, lobbyHeight) / 2 - 2;
            
            // 清空区域
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    setTile(x, y, TileType.VOID, floor);
                }
            }
            
            // 创建十字形状
            // 水平臂
            for (let y = centerY - armWidth; y <= centerY + armWidth; y++) {
                for (let x = centerX - armLength; x <= centerX + armLength; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (x === centerX - armLength || x === centerX + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // 垂直臂
            for (let y = centerY - armLength; y <= centerY + armLength; y++) {
                for (let x = centerX - armWidth; x <= centerX + armWidth; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (y === centerY - armLength || y === centerY + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // 中心点
            mapFloors[floor][centerY][centerX] = TileType.LOBBY_CENTER;
            
            // 添加外部墙壁
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (getTile(x, y, floor) === TileType.VOID) {
                        // 检查是否与大厅内部相邻
                        let adjacentToLobby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= lobbyX && nx < lobbyX + lobbyWidth && 
                                    ny >= lobbyY && ny < lobbyY + lobbyHeight) {
                                    if (getTile(nx, ny, floor) === TileType.LOBBY || 
                                        getTile(nx, ny, floor) === TileType.LOBBY_CENTER) {
                                        adjacentToLobby = true;
                                        break;
                                    }
                                }
                            }
                            if (adjacentToLobby) break;
                        }
                        if (adjacentToLobby) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        }
                    }
                }
            }
        }
        
        // 创建方形大厅
        function createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const innerSize = Math.min(lobbyWidth, lobbyHeight) - 4;
            
            // 创建外部方形
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // 外部墙壁
                        mapFloors[floor][y][x] = TileType.WALL;
                    } else {
                        // 内部区域
                        const innerX = Math.floor((lobbyWidth - innerSize) / 2);
                        const innerY = Math.floor((lobbyHeight - innerSize) / 2);
                        
                        if (x >= lobbyX + innerX && x < lobbyX + innerX + innerSize &&
                            y >= lobbyY + innerY && y < lobbyY + innerY + innerSize) {
                            // 内部方形
                            if (x === lobbyX + innerX || x === lobbyX + innerX + innerSize - 1 ||
                                y === lobbyY + innerY || y === lobbyY + innerY + innerSize - 1) {
                                // 内部墙壁
                                mapFloors[floor][y][x] = TileType.WALL;
                            } else {
                                // 内部空间
                                if (x === centerX && y === centerY) {
                                    mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                                } else {
                                    mapFloors[floor][y][x] = TileType.LOBBY;
                                }
                            }
                        } else {
                            // 中间区域（走廊）
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
        }
        
        // 检查是否与外场重叠
        function hasOutdoorOverlap(x, y, width, height, floor) {
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length &&
                        mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                        if (mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // 添加大厅入口
        function addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const entranceCount = 2 + Math.floor(Math.random() * 2); // 2-3个入口
            
            for (let i = 0; i < entranceCount; i++) {
                let entranceX, entranceY;
                
                // 随机选择入口位置（四边）
                const side = Math.floor(Math.random() * 4);
                
                switch(side) {
                    case 0: // 上边
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY;
                        break;
                    case 1: // 下边
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY + lobbyHeight - 1;
                        break;
                    case 2: // 左边
                        entranceX = lobbyX;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                    case 3: // 右边
                        entranceX = lobbyX + lobbyWidth - 1;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                }
                
                // 创建入口
                mapFloors[floor][entranceY][entranceX] = TileType.LOBBY_ENTRANCE;
                
                // 创建入口通道
                createEntrancePath(entranceX, entranceY, floor);
            }
        }
        
        // 创建入口通道
        function createEntrancePath(entranceX, entranceY, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const pathLength = 3 + Math.floor(Math.random() * 3); // 3-5格长
            
            for (let [dx, dy] of directions) {
                let canCreatePath = true;
                
                // 检查路径方向是否可行
                for (let i = 1; i <= pathLength; i++) {
                    const nx = entranceX + dx * i;
                    const ny = entranceY + dy * i;
                    
                    if (nx < 0 || nx >= mapFloors[floor][0].length || 
                        ny < 0 || ny >= mapFloors[floor].length ||
                        !mapFloors[floor][ny] || mapFloors[floor][ny][nx] === undefined) {
                        canCreatePath = false;
                        break;
                    }
                    
                    if (mapFloors[floor][ny][nx] !== TileType.VOID && 
                        mapFloors[floor][ny][nx] !== TileType.OUTDOOR) {
                        canCreatePath = false;
                        break;
                    }
                }
                
                if (canCreatePath) {
                    // 创建通道
                    for (let i = 1; i <= pathLength; i++) {
                        const nx = entranceX + dx * i;
                        const ny = entranceY + dy * i;
                        mapFloors[floor][ny][nx] = TileType.FLOOR;
                    }
                    break; // 只创建一个方向的通道
                }
            }
        }
        
        // 连接大厅到其他区域
        function connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            // 找到最近的房间或走廊
            let nearestArea = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (!mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                        continue;
                    }
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN) {
                        
                        const dist = Math.abs(x - (lobbyX + lobbyWidth/2)) + 
                                   Math.abs(y - (lobbyY + lobbyHeight/2));
                        
                        if (dist < minDist && dist > 5) { // 距离大于5才需要连接
                            minDist = dist;
                            nearestArea = {x, y};
                        }
                    }
                }
            }
            
            // 如果找到了需要连接的区域，创建走廊
            if (nearestArea && minDist < 20) {
                const lobbyCenterX = Math.floor(lobbyX + lobbyWidth / 2);
                const lobbyCenterY = Math.floor(lobbyY + lobbyHeight / 2);
                
                createSimpleCorridor(lobbyCenterX, lobbyCenterY, nearestArea.x, nearestArea.y, floor);
            }
        }
        
        // 检查位置是否靠墙或靠门
        function isNearWallOrDoor(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 上下左右四个方向
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const adjacentTile = mapFloors[floor][ny][nx];
                    
                    // 检查是否靠墙
                    if (adjacentTile === TileType.WALL) {
                        return true;
                    }
                    
                    // 检查是否靠门（门通常是地板，但连接房间）
                    if (adjacentTile === TileType.FLOOR || 
                        adjacentTile === TileType.MEDIUM_GROUND ||
                        adjacentTile === TileType.HIGH_GROUND ||
                        adjacentTile === TileType.LOW_GROUND) {
                        // 检查这个地板是否连接房间（即周围有墙壁）
                        if (isDoorway(nx, ny, floor)) {
                            return true;
                        }
                    }
                    
                    // 检查是否靠窗户
                    if (adjacentTile === TileType.WINDOW) {
                        return true;
                    }
                    
                    // 检查是否靠大厅入口
                    if (adjacentTile === TileType.LOBBY_ENTRANCE) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 检查位置是否是门口
        function isDoorway(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            let wallCount = 0;
            let voidCount = 0;
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const tile = mapFloors[floor][ny][nx];
                    if (tile === TileType.WALL) {
                        wallCount++;
                    } else if (tile === TileType.VOID) {
                        voidCount++;
                    }
                }
            }
            
            // 如果周围有墙壁和空地，说明这是门口
            return wallCount >= 1 && voidCount >= 1;
        }
        
        // 添加外场特征
        function addOutdoorFeatures(size) {
            // 添加规则的外场掩体（集装箱、车辆等）- 只生成在靠墙位置
            const coverCount = Math.floor(size * size * 0.01); // 1%的密度
            let placedCount = 0;
            let attempts = 0;
            
            while (placedCount < coverCount && attempts < coverCount * 10) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR && isOutdoorCoverPosition(x, y, size)) {
                    // 创建规则矩形掩体
                    const coverWidth = 2 + Math.floor(Math.random() * 2); // 2-3格宽
                    const coverHeight = 2; // 固定2格高
                    
                    // 检查是否有足够空间
                    let canPlace = true;
                            for (let dy = 0; dy < coverHeight; dy++) {
                                for (let dx = 0; dx < coverWidth; dx++) {
                            if (y + dy >= size - 1 || x + dx >= size - 1) {
                                canPlace = false;
                                break;
                            }
                            if (mapFloors[0][y + dy][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        if (!canPlace) break;
                    }
                    
                    if (canPlace) {
                        for (let dy = 0; dy < coverHeight; dy++) {
                            for (let dx = 0; dx < coverWidth; dx++) {
                                            mapFloors[0][y + dy][x + dx] = TileType.OUTDOOR_COVER;
                                        }
                                    }
                        placedCount++;
                    }
                }
                attempts++;
            }
            
            // 在外场边缘添加规则围墙
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // 检查是否与外场边缘相邻
                        let isEdge = false;
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                mapFloors[0][ny][nx] === TileType.VOID) {
                                        isEdge = true;
                                break;
                            }
                        }
                        
                        if (isEdge && Math.random() < 0.9) { // 提高围墙生成概率
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // 确保外场有完整的围墙边界
            createOutdoorWallBoundary(size);
            
            // 添加规则的道路连接
            addOutdoorPaths(size);
        }
        
        // 检查外场掩体位置是否合适（靠墙或边缘）
        function isOutdoorCoverPosition(x, y, size) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // 检查是否靠外场边缘
                if (nx < 0 || nx >= size || ny < 0 || ny >= size) {
                    return true;
                }
                
                // 检查边界和数组有效性
                if (nx < 0 || nx >= size || ny < 0 || ny >= size ||
                    !mapFloors[0][ny] || mapFloors[0][ny][nx] === undefined) {
                    continue;
                }
                
                // 检查是否靠外场围墙
                if (mapFloors[0][ny][nx] === TileType.OUTDOOR_WALL) {
                    return true;
                }
                
                // 检查是否靠内场边界（墙壁）
                if (mapFloors[0][ny][nx] === TileType.WALL) {
                    return true;
                }
                
                // 检查是否靠空地（外场边缘）
                if (mapFloors[0][ny][nx] === TileType.VOID) {
                    return true;
                }
                
                // 检查是否靠道路（地板）
                if (mapFloors[0][ny][nx] === TileType.FLOOR) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 创建外场围墙边界
        function createOutdoorWallBoundary(size) {
            // 扫描外场区域，确保边界完整
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // 检查四个方向
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        let needsWall = false;
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            // 如果邻接地图边界或空地，需要围墙
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                (mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined &&
                                 mapFloors[0][ny][nx] === TileType.VOID)) {
                                needsWall = true;
                                break;
                            }
                        }
                        
                        // 如果当前是外场且需要围墙，但还没有围墙，则添加围墙
                        if (needsWall && mapFloors[0][y][x] === TileType.OUTDOOR) {
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // 添加外场内部的围墙结构（如分隔墙）
            addOutdoorInternalWalls(size);
        }
        
        // 添加外场内部围墙
        function addOutdoorInternalWalls(size) {
            // 在外场区域添加一些内部围墙，创造战术掩体
            const wallCount = Math.floor(size * 0.5); // 根据地图大小决定围墙数量，支持更大地图
            
            for (let i = 0; i < wallCount; i++) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // 随机选择围墙方向（水平或垂直）
                    const isHorizontal = Math.random() > 0.5;
                    const wallLength = 3 + Math.floor(Math.random() * 4); // 3-6格长
                    
                    if (isHorizontal) {
                        // 创建水平围墙
                        let canPlace = true;
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx >= size || 
                                !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                                mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dx = 0; dx < wallLength; dx++) {
                                if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                    mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    } else {
                        // 创建垂直围墙
                        let canPlace = true;
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dy = 0; dy < wallLength; dy++) {
                                if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                    mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    }
                }
            }
            
            // 添加L形围墙（角落掩体）
            addOutdoorCornerWalls(size);
        }
        
        // 添加外场角落围墙
        function addOutdoorCornerWalls(size) {
            const cornerCount = Math.floor(size * 0.2); // 角落围墙数量，支持更大地图
            
            for (let i = 0; i < cornerCount; i++) {
                const x = Math.floor(Math.random() * (size - 6)) + 3;
                const y = Math.floor(Math.random() * (size - 6)) + 3;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // 检查周围是否有足够空间创建L形围墙
                    const wallLength = 3;
                    let canPlace = true;
                    
                    // 检查水平段
                    for (let dx = 0; dx < wallLength; dx++) {
                        if (x + dx >= size || 
                            !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                            mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    // 检查垂直段
                    if (canPlace) {
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                    }
                    
                    if (canPlace) {
                        // 创建L形围墙
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                            }
                        }
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // 生成高低差区域 - 整段道路升高或降低
        function generateElevationAreas(size, floor) {
            const elevation = parseInt(document.getElementById('elevation').value);
            if (elevation === 0) return; // 无高低差
            
            // 找到所有连续的道路段
            const roadSegments = findRoadSegments(size, floor);
            
            // 根据高低差设置决定要改变的道路段数量
            const elevationIntensity = elevation * 0.4; // 0.4 = 40%的道路段会有高低差
            const segmentsToElevate = Math.floor(roadSegments.length * elevationIntensity);
            
            // 随机选择道路段进行高低差处理
            const shuffledSegments = [...roadSegments].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < Math.min(segmentsToElevate, shuffledSegments.length); i++) {
                const segment = shuffledSegments[i];
                const isHighGround = Math.random() > 0.5; // 50%概率是高地，50%概率是低地
                
                // 将整个道路段标记为高地或低地
                for (const point of segment) {
                    if (mapFloors[floor][point.y][point.x] === TileType.FLOOR) {
                        mapFloors[floor][point.y][point.x] = isHighGround ? TileType.HIGH_GROUND : TileType.LOW_GROUND;
                    }
                }
            }
            
            // 将剩余的地板和道路区域标记为中等地
            markMediumGround(size, floor);
        }
        
        // 找到连续的道路段
        function findRoadSegments(size, floor) {
            const visited = Array(size).fill().map(() => Array(size).fill(false));
            const segments = [];
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (!visited[y][x] && 
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        const segment = [];
                        floodFillRoad(x, y, size, floor, visited, segment);
                        
                        // 只保留足够大的道路段（至少5个连续点）
                        if (segment.length >= 5) {
                            segments.push(segment);
                        }
                    }
                }
            }
            
            return segments;
        }
        
        // 洪水填充算法找到连续的道路段（使用迭代避免栈溢出）
        function floodFillRoad(startX, startY, size, floor, visited, segment) {
            const stack = [{x: startX, y: startY}];
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                
                // 检查边界和条件
                if (x < 0 || x >= size || y < 0 || y >= size || 
                    visited[y][x] || 
                    !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined ||
                    mapFloors[floor][y][x] !== TileType.FLOOR) {
                    continue;
                }
                
                visited[y][x] = true;
                segment.push({x, y});
                
                // 向四个方向扩展
                stack.push({x: x + 1, y: y});
                stack.push({x: x - 1, y: y});
                stack.push({x: x, y: y + 1});
                stack.push({x: x, y: y - 1});
            }
        }
        
        // 创建高低差区域
        function createElevationArea(centerX, centerY, size, elevationType, floor) {
            const halfSize = Math.floor(size / 2);
            
            for (let y = centerY - halfSize; y <= centerY + halfSize; y++) {
                for (let x = centerX - halfSize; x <= centerX + halfSize; x++) {
                    if (x >= 0 && x < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length &&
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        
                        // 只对地面和道路应用高低差
                        if (mapFloors[floor][y][x] === TileType.FLOOR) {
                            mapFloors[floor][y][x] = elevationType;
                        }
                    }
                }
            }
        }
        
        // 标记中等地
        function markMediumGround(size, floor) {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // 只对地面和道路标记为中等地，保持其他元素不变
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        mapFloors[floor][y][x] = TileType.MEDIUM_GROUND;
                    }
                }
            }
        }
        
        // 添加外场道路
        function addOutdoorPaths(size) {
            // 在外场区域之间创建规则的道路连接
            const pathCount = Math.floor(size / 20) + Math.floor(Math.random() * 5); // 根据地图大小调整道路数量
            
            for (let i = 0; i < pathCount; i++) {
                // 找到两个外场区域的中心点
                let outdoorAreas = [];
                
                // 扫描外场区域
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                            mapFloors[0][y][x] === TileType.OUTDOOR) {
                            // 检查是否是新区域的中心
                            let isCenter = true;
                            for (let dy = -3; dy <= 3; dy++) {
                                for (let dx = -3; dx <= 3; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < size && nx >= 0 && nx < size &&
                                        mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined) {
                                        if (mapFloors[0][ny][nx] !== TileType.OUTDOOR && 
                                            mapFloors[0][ny][nx] !== TileType.OUTDOOR_COVER) {
                                            isCenter = false;
                                        }
                                    }
                                }
                            }
                            if (isCenter) {
                                outdoorAreas.push({x, y});
                            }
                        }
                    }
                }
                
                // 连接不同的外场区域
                if (outdoorAreas.length >= 2) {
                    const area1 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    let area2;
                    do {
                        area2 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    } while (area2 === area1);
                    
                    // 创建直线道路连接
                    createStraightPath(area1.x, area1.y, area2.x, area2.y);
                }
            }
        }
        
        // 创建道路（直线）
        function createStraightPath(x1, y1, x2, y2) {
            
            // 直线道路
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // 创建道路（2格宽）
                for (let w = -1; w <= 1; w++) {
                    for (let h = -1; h <= 1; h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[0][0].length && 
                            ny >= 0 && ny < mapFloors[0].length) {
                            if (mapFloors[0][ny][nx] === TileType.OUTDOOR) {
                                mapFloors[0][ny][nx] = TileType.FLOOR; // 道路使用地板类型
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        

        
        // 在房间周围添加缓冲区（确保独立性）
        function addRoomBuffer(x, y, width, height, floor, size, minSpacing) {
            // 在房间周围创建缓冲区，确保房间之间有足够空间
            for (let by = y - minSpacing; by < y + height + minSpacing; by++) {
                for (let bx = x - minSpacing; bx < x + width + minSpacing; bx++) {
                    if (bx >= 0 && bx < size && by >= 0 && by < size) {
                        // 如果缓冲区位置是空地，保持为空地
                        if (mapFloors[floor][by][bx] === TileType.VOID) {
                            // 保持为空地，不添加任何装饰
                        }
                    }
                }
            }
        }
        
        // 检查是否邻接外场
        function isAdjacentToOutdoor(x, y, floor) {
            if (floor !== 0) return false;
            
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                    return true;
                }
            }
            return false;
        }
        
        // 连接房间（改进版：随机走廊宽度，确保所有房间连通）
        function connectRooms(rooms, floor, baseCorridorWidth) {
            if (rooms.length < 2) return;
            
            const corridorMode = document.getElementById('corridorRandom').value;
            
            // 使用最小生成树算法确保所有房间连通
            const connected = new Set([0]); // 从第一个房间开始
            const unconnected = new Set();
            for (let i = 1; i < rooms.length; i++) {
                unconnected.add(i);
            }
            
            // 连接所有房间
            while (unconnected.size > 0) {
                let minDist = Infinity;
                let bestConnected = -1;
                let bestUnconnected = -1;
                
                // 找到最近的未连接房间对
                for (let c of connected) {
                    for (let u of unconnected) {
                        const room1 = rooms[c];
                        const room2 = rooms[u];
                        const dist = Math.abs(room1.x + room1.width/2 - room2.x - room2.width/2) + 
                                   Math.abs(room1.y + room1.height/2 - room2.y - room2.height/2);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            bestConnected = c;
                            bestUnconnected = u;
                        }
                    }
                }
                
                if (bestConnected !== -1 && bestUnconnected !== -1) {
                    // 根据模式决定走廊宽度
                    let corridorWidth = baseCorridorWidth;
                    if (corridorMode === 'random') {
                        corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                    } else if (corridorMode === 'varied') {
                        corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                    } else {
                        corridorWidth = baseCorridorWidth + 1;
                    }
                    
                    // 创建走廊连接两个房间
                    createCorridorBetweenRooms(rooms[bestConnected], rooms[bestUnconnected], floor, corridorWidth);
                    
                    // 将房间标记为已连接
                    connected.add(bestUnconnected);
                    unconnected.delete(bestUnconnected);
                }
            }
            
            // 添加额外的连接增加路线多样性（20%概率，减少过度连接）
            for (let i = 0; i < rooms.length; i++) {
                for (let j = i + 1; j < rooms.length; j++) {
                    if (Math.random() < 0.2) {
                        let corridorWidth = baseCorridorWidth;
                        if (corridorMode === 'random') {
                            corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                        } else if (corridorMode === 'varied') {
                            corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                        }
                        createCorridorBetweenRooms(rooms[i], rooms[j], floor, corridorWidth);
                    }
                }
                    }
        
        // 清理孤立的房间（确保所有房间都可达）
        function cleanupIsolatedRooms(rooms, floor) {
            // 检查每个房间是否都有门或与走廊连接
            for (let room of rooms) {
                let hasAccess = false;
                
                // 检查房间边界是否有开口
                const directions = [
                    { x: room.x - 1, y: room.y + Math.floor(room.height / 2) }, // 左
                    { x: room.x + room.width, y: room.y + Math.floor(room.height / 2) }, // 右
                    { x: room.x + Math.floor(room.width / 2), y: room.y - 1 }, // 上
                    { x: room.x + Math.floor(room.width / 2), y: room.y + room.height } // 下
                ];
                
                for (let dir of directions) {
                    if (dir.x >= 0 && dir.x < mapFloors[floor][0].length && 
                        dir.y >= 0 && dir.y < mapFloors[floor].length) {
                        if (mapFloors[floor][dir.y][dir.x] === TileType.FLOOR) {
                            hasAccess = true;
                            break;
                        }
                    }
                }
                
                // 如果没有访问路径，创建一个门
                if (!hasAccess) {
                    createRoomDoor(room, floor);
                }
            }
        }
        
        // 为房间创建门
        function createRoomDoor(room, floor) {
            // 随机选择一面墙创建门
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0 }, // 左
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0 }, // 右
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1 }, // 上
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1 } // 下
            ];
            
            const side = sides[Math.floor(Math.random() * sides.length)];
            
            // 创建门
            if (side.x >= 0 && side.x < mapFloors[floor][0].length && 
                side.y >= 0 && side.y < mapFloors[floor].length) {
                mapFloors[floor][side.y][side.x] = TileType.FLOOR;
                
                // 创建门外的走廊
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        mapFloors[floor][corridorY][corridorX] = TileType.FLOOR;
                    }
                    }
                }
            }
            
            // 确保每个房间都有门
            ensureRoomDoors(rooms, floor);
            
            // 添加走廊墙壁
            addCorridorWalls(floor);
            
            // 清理孤立的房间（确保所有房间都可达）
            cleanupIsolatedRooms(rooms, floor);
        }
        
        // 创建两个房间之间的走廊（支持曲折度和弯曲度）
        function createCorridorBetweenRooms(room1, room2, floor, width) {
            const x1 = Math.floor(room1.x + room1.width / 2);
            const y1 = Math.floor(room1.y + room1.height / 2);
            const x2 = Math.floor(room2.x + room2.width / 2);
            const y2 = Math.floor(room2.y + room2.height / 2);
            
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            switch(pathComplexity) {
                case 0: // 直线
                    createStraightCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 1: // 微弯
                    createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 2: // 中等（L形）
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 3: // 曲折
                    createZigzagCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 4: // 迷宫
                    createMazeLikeCorridor(x1, y1, x2, y2, floor, width);
                    break;
                default:
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
            }
        }
        
        // 直线走廊（最短路径）
        function createStraightCorridor(x1, y1, x2, y2, floor, width) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // 绘制宽度的走廊
                for (let w = -Math.floor(width/2); w <= Math.floor(width/2); w++) {
                    for (let h = -Math.floor(width/2); h <= Math.floor(width/2); h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[floor][0].length && 
                            ny >= 0 && ny < mapFloors[floor].length) {
                            if (mapFloors[floor][ny][nx] === TileType.VOID || 
                                mapFloors[floor][ny][nx] === TileType.WALL) {
                                mapFloors[floor][ny][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        
        // 微弯走廊（带小弧度）
        function createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width) {
            
            const midX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 6) - 3;
            const midY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 6) - 3;
            
            createStraightCorridor(x1, y1, midX, midY, floor, width);
            createStraightCorridor(midX, midY, x2, y2, floor, width);
        }
        
        // L形走廊（经典90度转弯）
        function createLShapedCorridor(x1, y1, x2, y2, floor, width) {
            if (Math.random() > 0.5) {
                // 先水平后垂直
                createHorizontalCorridor(x1, x2, y1, floor, width);
                createVerticalCorridor(x2, y1, y2, floor, width);
            } else {
                // 先垂直后水平
                createVerticalCorridor(x1, y1, y2, floor, width);
                createHorizontalCorridor(x1, x2, y2, floor, width);
            }
        }
        
        // 曲折走廊（多个转弯）
        function createZigzagCorridor(x1, y1, x2, y2, floor, width) {
            // 检查曲折度设置
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // 如果曲折度为0（直线），则使用直线走廊
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // 边界检查
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            const points = [];
            points.push({x: x1, y: y1});
            
            // 添加2-3个中间点
            const numPoints = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                // 添加随机偏移（确保在边界内）
                const offsetX = Math.floor(Math.random() * 10) - 5;
                const offsetY = Math.floor(Math.random() * 10) - 5;
                
                points.push({
                    x: Math.max(1, Math.min(Math.floor(baseX + offsetX), mapWidth - 2)),
                    y: Math.max(1, Math.min(Math.floor(baseY + offsetY), mapHeight - 2))
                });
            }
            
            points.push({x: x2, y: y2});
            
            // 连接所有点
            for (let i = 0; i < points.length - 1; i++) {
                if (i % 2 === 0) {
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i].y, floor, width);
                    createVerticalCorridor(points[i+1].x, points[i].y, points[i+1].y, floor, width);
                } else {
                    createVerticalCorridor(points[i].x, points[i].y, points[i+1].y, floor, width);
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i+1].y, floor, width);
                }
            }
        }
        
        // 迷宫式走廊（复杂路径）
        function createMazeLikeCorridor(x1, y1, x2, y2, floor, width) {
            // 检查曲折度设置
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // 如果曲折度为0（直线），则使用直线走廊
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // 边界检查
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            x1 = Math.max(1, Math.min(x1, mapWidth - 2));
            y1 = Math.max(1, Math.min(y1, mapHeight - 2));
            x2 = Math.max(1, Math.min(x2, mapWidth - 2));
            y2 = Math.max(1, Math.min(y2, mapHeight - 2));
            
            // 创建主路径
            createZigzagCorridor(x1, y1, x2, y2, floor, width);
            
            // 添加1-2条额外路径
            const extraPaths = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < extraPaths; i++) {
                // 创建偏移起点和终点（确保在边界内）
                const offsetX1 = Math.max(1, Math.min(x1 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY1 = Math.max(1, Math.min(y1 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                const offsetX2 = Math.max(1, Math.min(x2 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY2 = Math.max(1, Math.min(y2 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                
                // 使用较窄的宽度
                const narrowWidth = Math.max(1, width - 1);
                
                // 随机选择路径类型
                if (Math.random() > 0.5) {
                    createLShapedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                } else {
                    createSlightlyCurvedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                }
            }
            
            // 添加一些连接横道
            const crossPaths = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < crossPaths; i++) {
                const crossX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossLength = 5 + Math.floor(Math.random() * 10);
                
                if (Math.random() > 0.5) {
                    // 水平横道
                    const startX = Math.max(0, crossX - Math.floor(crossLength/2));
                    const endX = Math.min(mapWidth - 1, crossX + Math.floor(crossLength/2));
                    
                    if (crossY >= 0 && crossY < mapHeight) {
                        for (let x = startX; x <= endX; x++) {
                            if (mapFloors[floor][crossY][x] === TileType.VOID) {
                                mapFloors[floor][crossY][x] = TileType.FLOOR;
                            }
                        }
                    }
                } else {
                    // 垂直横道
                    const startY = Math.max(0, crossY - Math.floor(crossLength/2));
                    const endY = Math.min(mapHeight - 1, crossY + Math.floor(crossLength/2));
                    
                    if (crossX >= 0 && crossX < mapWidth) {
                        for (let y = startY; y <= endY; y++) {
                            if (mapFloors[floor][y][crossX] === TileType.VOID) {
                                mapFloors[floor][y][crossX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        

        
        // 创建水平走廊
        function createHorizontalCorridor(x1, x2, y, floor, width) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const halfWidth = Math.floor(width / 2);
            
            for (let x = minX; x <= maxX; x++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const ny = y + w;
                    if (ny >= 0 && ny < mapFloors[floor].length && 
                        x >= 0 && x < mapFloors[floor][0].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                            if (mapFloors[floor][ny][x] === TileType.VOID || 
                                mapFloors[floor][ny][x] === TileType.WALL) {
                                mapFloors[floor][ny][x] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // 创建垂直走廊
        function createVerticalCorridor(x, y1, y2, floor, width) {
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            const halfWidth = Math.floor(width / 2);
            
            for (let y = minY; y <= maxY; y++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const nx = x + w;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length) {
                        if (mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                            if (mapFloors[floor][y][nx] === TileType.VOID || 
                                mapFloors[floor][y][nx] === TileType.WALL) {
                                mapFloors[floor][y][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // 确保每个房间都有至少一个门
        function ensureRoomDoors(rooms, floor) {
            for (let room of rooms) {
                let hasDoor = false;
                
                // 检查房间边界是否有开口
                // 上边
                for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                    if (mapFloors[floor][room.y][x] === TileType.FLOOR) {
                        hasDoor = true;
                        break;
                    }
                }
                
                // 下边
                if (!hasDoor) {
                    for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                        if (mapFloors[floor][room.y + room.height - 1][x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // 左边
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // 右边
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x + room.width - 1] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // 如果没有门，创建一个
                if (!hasDoor) {
                    // 随机选择一面墙创建门
                    const side = Math.floor(Math.random() * 4);
                    const doorWidth = 2; // 门的宽度
                    
                    switch(side) {
                        case 0: // 上
                            const topX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (topX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y][topX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 1: // 下
                            const bottomX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (bottomX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y + room.height - 1][bottomX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 2: // 左
                            const leftY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (leftY + i < room.y + room.height - 1) {
                                    mapFloors[floor][leftY + i][room.x] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 3: // 右
                            const rightY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (rightY + i < room.y + room.height - 1) {
                                    mapFloors[floor][rightY + i][room.x + room.width - 1] = TileType.FLOOR;
                                }
                            }
                            break;
                    }
                }
            }
        }
        
        // 添加走廊墙壁
        function addCorridorWalls(floor) {
            const tempMap = JSON.parse(JSON.stringify(mapFloors[floor]));
            
            for (let y = 1; y < mapFloors[floor].length - 1; y++) {
                for (let x = 1; x < mapFloors[floor][0].length - 1; x++) {
                    if (tempMap[y][x] === TileType.FLOOR || 
                        tempMap[y][x] === TileType.MEDIUM_GROUND ||
                        tempMap[y][x] === TileType.HIGH_GROUND ||
                        tempMap[y][x] === TileType.LOW_GROUND ||
                        tempMap[y][x] === TileType.T_SPAWN ||
                        tempMap[y][x] === TileType.CT_SPAWN ||
                        tempMap[y][x] === TileType.BOMBSITE_A ||
                        tempMap[y][x] === TileType.BOMBSITE_B) {
                        
                        // 检查四个方向
                        const directions = [[-1, 0], [0, -1], [0, 1], [1, 0]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < mapFloors[floor].length && 
                                nx >= 0 && nx < mapFloors[floor][0].length) {
                                if (tempMap[ny][nx] === TileType.VOID && 
                                    mapFloors[floor][ny][nx] === TileType.VOID) {
                                    mapFloors[floor][ny][nx] = TileType.WALL;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // 添加楼梯（改进版：确保与道路连接）
        function addStairs(rooms, stairsCount) {
            if (totalFloors <= 1 || stairsCount === 0) return;
            
            // 为每对相邻楼层创建楼梯
            for (let floor = 0; floor < totalFloors - 1; floor++) {
                let stairsPlaced = 0;
                
                // 收集所有道路位置
                const roadPositions = [];
                for (let y = 0; y < mapFloors[floor].length; y++) {
                    for (let x = 0; x < mapFloors[floor][0].length; x++) {
                        if (mapFloors[floor][y][x] === TileType.FLOOR ||
                            mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][x] === TileType.LOW_GROUND) {
                            roadPositions.push({ x, y });
                        }
                    }
                }
                
                // 如果没有道路，使用默认位置
                if (roadPositions.length === 0) {
                    roadPositions.push(
                        { x: Math.floor(mapFloors[0][0].length / 2), y: Math.floor(mapFloors[0].length / 2) }
                    );
                }
                
                // 打乱道路位置顺序
                roadPositions.sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < Math.min(stairsCount, roadPositions.length); i++) {
                    const roadPos = roadPositions[i];
                    
                    // 在道路附近寻找合适的位置
                    let found = false;
                    for (let dy = -3; dy <= 3 && !found; dy++) {
                        for (let dx = -3; dx <= 3 && !found; dx++) {
                            const x = roadPos.x + dx;
                            const y = roadPos.y + dy;
                            
                            // 检查位置是否有效（2x2区域）
                            if (x >= 1 && x < mapFloors[0][0].length - 2 &&
                                y >= 1 && y < mapFloors[0].length - 2) {
                                
                                // 检查当前层是否可以放置楼梯
                                let canPlaceLower = true;
                                let canPlaceUpper = true;
                                
                                for (let sy = 0; sy < 2; sy++) {
                                    for (let sx = 0; sx < 2; sx++) {
                                        // 检查下层
                                        if (mapFloors[floor][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceLower = false;
                                        }
                                        // 检查上层
                                        if (mapFloors[floor + 1][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceUpper = false;
                                        }
                                    }
                                }
                                
                                // 检查是否与道路相邻
                                let hasRoadAdjacent = false;
                                for (let sy = -1; sy <= 2; sy++) {
                                    for (let sx = -1; sx <= 2; sx++) {
                                        const nx = x + sx;
                                        const ny = y + sy;
                                        if (nx >= 0 && nx < mapFloors[floor][0].length &&
                                            ny >= 0 && ny < mapFloors[floor].length) {
                                            if (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                                mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.LOW_GROUND) {
                                                hasRoadAdjacent = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (hasRoadAdjacent) break;
                                }
                                
                                if ((canPlaceLower || canPlaceUpper) && hasRoadAdjacent) {
                                    // 在下层创建向上的楼梯
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // 如果是空地，先创建地板
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // 然后设置为楼梯（支持所有地面类型）
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.FLOOR ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.LOW_GROUND) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.STAIRS_UP;
                                            }
                                        }
                                    }
                                    
                                    // 在上层的相同位置创建向下的楼梯
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // 如果是空地，先创建地板
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // 然后设置为楼梯
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.FLOOR) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.STAIRS_DOWN;
                                            }
                                        }
                                    }
                                    
                                    // 确保楼梯周围有墙壁
                                    ensureStairWalls(x, y, floor);
                                    ensureStairWalls(x, y, floor + 1);
                                    
                                    stairsPlaced++;
                                    found = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // 确保楼梯周围有适当的墙壁
        function ensureStairWalls(x, y, floor) {
            // 检查楼梯周围3x3区域
            for (let dy = -1; dy <= 2; dy++) {
                for (let dx = -1; dx <= 2; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // 跳过楼梯本身（2x2中心区域）
                    if (dx >= 0 && dx <= 1 && dy >= 0 && dy <= 1) {
                        continue;
                    }
                    
                    // 如果是边界位置且是空地，添加墙壁
                    if (nx >= 0 && nx < mapFloors[floor][0].length &&
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny][nx] === TileType.VOID) {
                            // 检查是否与道路相邻，如果是则不添加墙壁
                            let hasRoadAdjacent = false;
                            for (let sy = -1; sy <= 1; sy++) {
                                for (let sx = -1; sx <= 1; sx++) {
                                    const checkX = nx + sx;
                                    const checkY = ny + sy;
                                    if (checkX >= 0 && checkX < mapFloors[floor][0].length &&
                                        checkY >= 0 && checkY < mapFloors[floor].length) {
                                        if (mapFloors[floor][checkY][checkX] === TileType.FLOOR ||
                                            mapFloors[floor][checkY][checkX] === TileType.MEDIUM_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.HIGH_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.LOW_GROUND) {
                                            hasRoadAdjacent = true;
                                            break;
                                        }
                                    }
                                }
                                if (hasRoadAdjacent) break;
                            }
                            
                            // 只在没有道路相邻的边缘添加墙壁
                            if (!hasRoadAdjacent && (Math.abs(dx) === 1 || Math.abs(dy) === 1)) {
                                mapFloors[floor][ny][nx] = TileType.WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // 连接楼梯到最近的房间或走廊
        function connectStairToRooms(stairX, stairY, floor) {
            // 查找最近的地板区域
            let nearestFloor = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_A ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_B) {
                        
                        const dist = Math.abs(x - stairX) + Math.abs(y - stairY);
                        if (dist < minDist && dist > 3) { // 距离大于3才需要连接
                            minDist = dist;
                            nearestFloor = { x, y };
                        }
                    }
                }
            }
            
            // 如果找到了需要连接的地板，创建走廊
            if (nearestFloor && minDist < 15) {
                createSimpleCorridor(stairX + 1, stairY + 1, nearestFloor.x, nearestFloor.y, floor);
            }
        }
        
        // 创建简单走廊连接两点
        function createSimpleCorridor(x1, y1, x2, y2, floor) {
            // 先水平后垂直
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            
            // 水平段
            for (let x = minX; x <= maxX; x++) {
                if (mapFloors[floor][y1][x] === TileType.VOID) {
                    mapFloors[floor][y1][x] = TileType.FLOOR;
                }
                // 添加墙壁
                if (y1 > 0 && mapFloors[floor][y1 - 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 - 1][x] = TileType.WALL;
                }
                if (y1 < mapFloors[floor].length - 1 && mapFloors[floor][y1 + 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 + 1][x] = TileType.WALL;
                }
            }
            
            // 垂直段
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            for (let y = minY; y <= maxY; y++) {
                if (mapFloors[floor][y][x2] === TileType.VOID) {
                    mapFloors[floor][y][x2] = TileType.FLOOR;
                }
                // 添加墙壁
                if (x2 > 0 && mapFloors[floor][y][x2 - 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 - 1] = TileType.WALL;
                }
                if (x2 < mapFloors[floor][0].length - 1 && mapFloors[floor][y][x2 + 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 + 1] = TileType.WALL;
                }
            }
        }
        
        // 添加特殊元素
        function addSpecialElements(rooms, coverDensity, waterAmount, windowDensity) {
            // 设置出生点和包点
            if (rooms.length >= 3) {
                const firstFloorRooms = rooms.filter(r => r.floor === 0);
                if (firstFloorRooms.length >= 3) {
                    // T出生点
                    const tRoom = firstFloorRooms[0];
                    for (let y = tRoom.y + 1; y < tRoom.y + tRoom.height - 1; y++) {
                        for (let x = tRoom.x + 1; x < tRoom.x + tRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.T_SPAWN;
                            }
                        }
                    }
                    
                    // CT出生点
                    const ctRoom = firstFloorRooms[firstFloorRooms.length - 1];
                    for (let y = ctRoom.y + 1; y < ctRoom.y + ctRoom.height - 1; y++) {
                        for (let x = ctRoom.x + 1; x < ctRoom.x + ctRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.CT_SPAWN;
                            }
                        }
                    }
                    
                    // 生成包点
                    const bombSiteCount = parseInt(document.getElementById('bombSiteCount').value);
                    const availableRooms = firstFloorRooms.slice(2); // 跳过出生点房间
                    
                    // 确保有足够的房间
                    const maxBombSites = Math.min(bombSiteCount, availableRooms.length);
                    
                    for (let i = 0; i < maxBombSites; i++) {
                        const roomIndex = Math.floor((i + 1) * availableRooms.length / (maxBombSites + 1));
                        const bombRoom = availableRooms[roomIndex];
                        
                        if (bombRoom) {
                            const centerX = Math.floor(bombRoom.x + bombRoom.width / 2);
                            const centerY = Math.floor(bombRoom.y + bombRoom.height / 2);
                            
                            // 根据包点索引选择TileType
                            const bombSiteType = i === 0 ? TileType.BOMBSITE_A : 
                                               i === 1 ? TileType.BOMBSITE_B :
                                               i === 2 ? TileType.BOMBSITE_C :
                                               i === 3 ? TileType.BOMBSITE_D :
                                               TileType.BOMBSITE_E;
                            
                            // 创建包点区域
                            for (let y = centerY - 2; y <= centerY + 2; y++) {
                                for (let x = centerX - 2; x <= centerX + 2; x++) {
                                    if (y > bombRoom.y && y < bombRoom.y + bombRoom.height - 1 &&
                                        x > bombRoom.x && x < bombRoom.x + bombRoom.width - 1) {
                                        if (mapFloors[0][y][x] === TileType.FLOOR || 
                                            mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                                            mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                                            mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                            mapFloors[0][y][x] = bombSiteType;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // 添加掩体（只生成在靠墙或靠门位置，每段道路最多3个）
            for (let floor = 0; floor < totalFloors; floor++) {
                // 找到所有道路段
                const roadSegments = findRoadSegments(mapFloors[floor][0].length, floor);
                
                // 为每个道路段添加掩体
                for (const segment of roadSegments) {
                    const maxCoversPerSegment = 3; // 每段道路最多3个掩体
                    const segmentCoverCount = Math.min(
                        Math.floor(segment.length * coverDensity / 1000), 
                        maxCoversPerSegment
                    );
                    
                    let placedCount = 0;
                    let attempts = 0;
                    const maxAttempts = segment.length * 2; // 限制尝试次数
                    
                    // 随机打乱道路段中的点
                    const shuffledPoints = [...segment].sort(() => Math.random() - 0.5);
                    
                    for (const point of shuffledPoints) {
                        if (placedCount >= segmentCoverCount || attempts >= maxAttempts) break;
                        
                        const x = point.x;
                        const y = point.y;
                        
                        if ((mapFloors[floor][y][x] === TileType.FLOOR || 
                             mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                             mapFloors[floor][y][x] === TileType.LOW_GROUND) && 
                            isNearWallOrDoor(x, y, floor)) {
                        mapFloors[floor][y][x] = TileType.COVER;
                            placedCount++;
                        }
                        attempts++;
                    }
                }
            }
            
            // 添加水域（只在第一层）- 使用洪水填充创建连续水域
            if (waterAmount > 0) {
                createWaterAreas(waterAmount);
            }
            
            // 添加阴点（垂直小墙体）
            const shadowPointDensity = parseInt(document.getElementById('shadowPoint').value);
            if (shadowPointDensity > 0) {
                // 在所有楼层添加阴点
                for (let floor = 0; floor < totalFloors; floor++) {
                    addShadowPoints(shadowPointDensity, floor);
                }
            }
            
            // 添加窗户
            for (let floor = 0; floor < totalFloors; floor++) {
                const windowCount = Math.floor(mapFloors[floor].length * mapFloors[floor][0].length * windowDensity / 1000);
                for (let i = 0; i < windowCount; i++) {
                    const x = Math.floor(Math.random() * (mapFloors[floor][0].length - 2)) + 1;
                    const y = Math.floor(Math.random() * (mapFloors[floor].length - 2)) + 1;
                    if (mapFloors[floor][y][x] === TileType.WALL) {
                        // 检查是否合适放窗户
                        let hasFloorNearby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                if (ny >= 0 && ny < mapFloors[floor].length && 
                                    nx >= 0 && nx < mapFloors[floor][0].length &&
                                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                                    (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                     mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                                    hasFloorNearby = true;
                                }
                            }
                        }
                        if (hasFloorNearby) {
                            mapFloors[floor][y][x] = TileType.WINDOW;
                        }
                    }
                }
            }
        }
        
        // 游戏模式配置
        const gameModes = {
            team: {
                name: "团队竞技",
                description: "团队竞技模式",
                spawnPoints: { t: 2, ct: 2 },
                objectives: ["elimination"],
                features: ["cover", "water", "stairs", "windows"]
            },
            bomb: {
                name: "爆破模式", 
                description: "爆破模式",
                spawnPoints: { t: 5, ct: 5 },
                objectives: ["bomb_a", "bomb_b"],
                features: ["cover", "water", "stairs", "windows", "bombsites"]
            },
            zombie: {
                name: "生化模式",
                description: "生化模式", 
                spawnPoints: { human: 8, zombie: 2 },
                objectives: ["survival"],
                features: ["cover", "water", "stairs", "windows", "safe_zones"]
            }
        };

        // 地图风格配置
        const mapStyles = {
            balanced: {
                name: "平衡型",
                description: "平衡型地图",
                layout: "balanced",
                coverDensity: 1.0,
                waterAmount: 1.0,
                complexity: 1.0
            },
            ct_sided: {
                name: "CT优势",
                description: "CT优势地图",
                layout: "ct_sided", 
                coverDensity: 0.8,
                waterAmount: 1.2,
                complexity: 1.1
            },
            t_sided: {
                name: "T优势",
                description: "T优势地图",
                layout: "t_sided",
                coverDensity: 1.2,
                waterAmount: 0.8,
                complexity: 0.9
            },
            aim_heavy: {
                name: "枪法型",
                description: "枪法型地图",
                layout: "aim_heavy",
                coverDensity: 0.6,
                waterAmount: 0.5,
                complexity: 0.8
            },
            tactical: {
                name: "战术型",
                description: "战术型地图",
                layout: "tactical",
                coverDensity: 1.3,
                waterAmount: 1.1,
                complexity: 1.2
            },
            rush: {
                name: "快攻型",
                description: "快攻型地图",
                layout: "rush",
                coverDensity: 0.7,
                waterAmount: 0.6,
                complexity: 0.7
            },
            black_town: {
                name: "黑色城镇",
                description: "黑色城镇风格",
                layout: "urban",
                coverDensity: 1.1,
                waterAmount: 0.3,
                complexity: 1.0,
                theme: "dark_urban"
            },
            desert_gray: {
                name: "沙漠灰",
                description: "沙漠灰风格",
                layout: "desert",
                coverDensity: 0.8,
                waterAmount: 0.1,
                complexity: 0.9,
                theme: "desert"
            },
            new_year_plaza: {
                name: "新年广场",
                description: "新年广场风格",
                layout: "plaza",
                coverDensity: 1.0,
                waterAmount: 0.5,
                complexity: 1.1,
                theme: "festival"
            },
            white_house: {
                name: "白房",
                description: "白房风格",
                layout: "mansion",
                coverDensity: 1.2,
                waterAmount: 0.4,
                complexity: 1.3,
                theme: "luxury"
            },
            transport_ship: {
                name: "运输船",
                description: "运输船风格",
                layout: "ship",
                coverDensity: 0.9,
                waterAmount: 0.8,
                complexity: 1.0,
                theme: "naval"
            },
            satellite_base: {
                name: "卫星基地",
                description: "卫星基地风格",
                layout: "military",
                coverDensity: 1.1,
                waterAmount: 0.2,
                complexity: 1.2,
                theme: "military"
            },
            harbor_dock: {
                name: "港口码头",
                description: "港口码头风格",
                layout: "harbor",
                coverDensity: 1.0,
                waterAmount: 1.5,
                complexity: 1.1,
                theme: "harbor"
            },
            subway_station: {
                name: "地铁站",
                description: "地铁站风格",
                layout: "underground",
                coverDensity: 1.3,
                waterAmount: 0.1,
                complexity: 1.4,
                theme: "underground"
            }
        };

        // 应用游戏模式设置
        function applyGameMode(gameMode) {
            const mode = gameModes[gameMode];
            if (!mode) return;
            
            // 更新地图标题
            document.getElementById('mapName').textContent = mode.name + "地图";
            
            // 更新模式描述
            const modeDescription = document.querySelector('.map-header div:last-child');
            if (modeDescription) {
                modeDescription.textContent = mode.description;
            }
            
            return mode;
        }

        // 应用地图风格设置
        function applyMapStyle(mapStyle) {
            const style = mapStyles[mapStyle];
            if (!style) return;
            
            // 根据风格调整参数
            const coverDensitySlider = document.getElementById('coverDensity');
            const waterAmountSlider = document.getElementById('waterAmount');
            const pathComplexitySlider = document.getElementById('pathComplexity');
            
            if (coverDensitySlider && style.coverDensity) {
                const currentValue = parseInt(coverDensitySlider.value);
                const newValue = Math.round(currentValue * style.coverDensity);
                coverDensitySlider.value = Math.min(100, Math.max(10, newValue));
                document.getElementById('coverValue').textContent = coverDensitySlider.value;
            }
            
            if (waterAmountSlider && style.waterAmount) {
                const currentValue = parseInt(waterAmountSlider.value);
                const newValue = Math.round(currentValue * style.waterAmount);
                waterAmountSlider.value = Math.min(50, Math.max(0, newValue));
                document.getElementById('waterValue').textContent = waterAmountSlider.value;
            }
            
            if (pathComplexitySlider && style.complexity) {
                const currentValue = parseInt(pathComplexitySlider.value);
                const newValue = Math.round(currentValue * style.complexity);
                pathComplexitySlider.value = Math.min(4, Math.max(0, newValue));
                document.getElementById('pathValue').textContent = getComplexityText(pathComplexitySlider.value);
            }
            
            return style;
        }

        // 获取复杂度文本
        function getComplexityText(value) {
            const texts = ['简单', '较简单', '中', '较复杂', '复杂'];
            return texts[value] || '中';
        }
        
        // 生成地图
        function generateMap() {
            try {
                // 防重复点击
                const generateBtn = document.getElementById('generateBtn');
                if (generateBtn.disabled) {
                    console.log('地图正在生成中，请稍候...');
                    return;
                }
                
                console.log('生成地图函数被调用，按钮状态:', generateBtn.disabled);
                
                // 禁用按钮并显示生成状态
                generateBtn.disabled = true;
                generateBtn.textContent = '生成中...';
                
                console.log('开始生成地图...');
                
                // 获取地图参数
                const sizeX = parseInt(document.getElementById('mapSizeX').value);
                const sizeY = parseInt(document.getElementById('mapSizeY').value);
                const isLargeMap = (sizeX >= 400 || sizeY >= 400) || (sizeX * sizeY >= 120000);
                
                // 对于大地图使用异步处理
                if (isLargeMap) {
                    console.log(`检测到大地图 ${sizeX}x${sizeY}，使用异步生成...`);
                    setTimeout(() => {
                        try {
                            generateMapInternal();
                        } catch (error) {
                            console.error('异步地图生成失败:', error);
                            alert('地图生成失败: ' + error.message + '\n请尝试调整参数后重新生成。');
                        } finally {
                            // 恢复按钮状态
                            const generateBtn = document.getElementById('generateBtn');
                            generateBtn.disabled = false;
                            generateBtn.textContent = '生成地图';
                        }
                    }, 50);
                    return;
                }
                
                generateMapInternal();
                
        function generateMapInternal() {
                // 获取游戏模式和地图风格
                const gameMode = document.getElementById('gameMode').value;
                const mapStyle = document.getElementById('mapStyle').value;
                
                // 获取地图参数并进行安全检查
                const mapSizeX = parseInt(document.getElementById('mapSizeX').value);
                const mapSizeY = parseInt(document.getElementById('mapSizeY').value);
                
                // 限制极大地图的参数以避免性能问题
                if (mapSizeX > 800 || mapSizeY > 800) {
                    console.warn(`地图尺寸过大 ${mapSizeX}x${mapSizeY}，可能影响性能`);
                    // 对大地图调整一些参数
                    const roomCountSlider = document.getElementById('roomCount');
                    const currentRoomCount = parseInt(roomCountSlider.value);
                    if (currentRoomCount > 30) {
                        console.log(`大地图自动调整房间数量从 ${currentRoomCount} 到 30`);
                        roomCountSlider.value = 30;
                        document.getElementById('roomValue').textContent = 30;
                    }
                }
            
            // 应用游戏模式设置
            const modeConfig = applyGameMode(gameMode);
            
            // 应用地图风格设置
            const styleConfig = applyMapStyle(mapStyle);
            
            const sizeX = parseInt(document.getElementById('mapSizeX').value);
            const sizeY = parseInt(document.getElementById('mapSizeY').value);
            const size = Math.max(sizeX, sizeY); // 向后兼容，使用较大的尺寸
            const floors = parseInt(document.getElementById('floorCount').value);
            const roomCount = parseInt(document.getElementById('roomCount').value);
            const corridorWidth = parseInt(document.getElementById('corridorWidth').value);
            const coverDensity = parseInt(document.getElementById('coverDensity').value);
            const waterAmount = parseInt(document.getElementById('waterAmount').value);
            const stairsCount = parseInt(document.getElementById('stairsCount').value);
            const windowDensity = parseInt(document.getElementById('windowDensity').value);
            
            // 初始化地图
            initMap(sizeX, sizeY, floors);
            
            // 生成每层的房间
            const allRooms = [];
            for (let floor = 0; floor < floors; floor++) {
                const rooms = generateRooms(sizeX, sizeY, roomCount, floor);
                connectRooms(rooms, floor, corridorWidth);
                
                // 生成大厅（只在第一层）
                if (floor === 0) {
                    generateLobby(Math.max(sizeX, sizeY), floor);
                }
                
                // 生成高低差区域
                generateElevationAreas(Math.max(sizeX, sizeY), floor);
                
                // 添加房间填充（在房间内部创建更多小房间）
                addRoomFilling(rooms, floor);
                
                allRooms.push(...rooms);
            }
            
            // 添加楼梯
            addStairs(allRooms, stairsCount);
            
            // 添加特殊元素
            addSpecialElements(allRooms, coverDensity, waterAmount, windowDensity);
            
            // 添加狙击长道
            const longLanesCount = parseInt(document.getElementById('longLanes').value);
            if (longLanesCount > 0) {
                addLongLanes(allRooms, longLanesCount);
            }
            
            // 添加暗道
            const underpassDensity = parseInt(document.getElementById('underpass').value);
            if (underpassDensity > 0) {
                addUnderpass(allRooms, underpassDensity);
            }
            
            // 创建楼层选择器
            createFloorSelector();
            
            // 重置到第一层
            currentFloor = 0;
            
            // 绘制地图
            drawMap();
            
            console.log('地图生成完成！');
            
            // 对于异步调用，恢复按钮状态
            const generateBtn = document.getElementById('generateBtn');
            if (generateBtn.disabled) {
                generateBtn.disabled = false;
                generateBtn.textContent = '生成地图';
            }
        }
            
        } catch (error) {
            console.error('地图生成失败:', error);
            alert('地图生成失败: ' + error.message + '\n请尝试调整参数后重新生成。');
        } finally {
            // 恢复按钮状态
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = false;
            generateBtn.textContent = '生成地图';
        }
        }
        
        // 获取当前主题的canvas背景色
        function getCanvasBackgroundColor() {
            const rootStyles = getComputedStyle(document.documentElement);
            return rootStyles.getPropertyValue('--canvas-bg').trim();
        }
        
        // 获取移动端适配的canvas尺寸
        function getMobileOptimizedCanvasSize(mapWidth, mapHeight, baseCellSize) {
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            
            if (!isMobile) {
                return { cellSize: baseCellSize, maxCanvasSize: 1200 };
            }
            
            // 移动端限制更小的canvas尺寸
            const maxCanvasSize = isSmallMobile ? 350 : 450;
            const screenWidth = window.innerWidth - 20; // 减去padding
            const maxWidth = Math.min(maxCanvasSize, screenWidth);
            
            // 计算适合的cellSize
            let cellSize = baseCellSize;
            const actualWidth = mapWidth * cellSize;
            const actualHeight = mapHeight * cellSize;
            
            if (actualWidth > maxWidth || actualHeight > maxWidth) {
                const scale = Math.min(maxWidth / actualWidth, maxWidth / actualHeight);
                cellSize = Math.max(1, Math.floor(cellSize * scale));
            }
            
            return { cellSize: cellSize, maxCanvasSize: maxWidth };
        }
        
        // 绘制叠加视图地图
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const optimizedSize = getMobileOptimizedCanvasSize(map[0].length, map.length, 10);
            const cellSize = optimizedSize.cellSize;
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // 清空画布
            ctx.fillStyle = getCanvasBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 从底层到顶层绘制，使用透明度
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25); // 高层更透明
                const offset = floor * 2; // 每层偏移，创建3D效果
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let color = '#000';
                            
                            // 根据楼层调整颜色
                            switch(tile) {
                                case TileType.FLOOR: 
                                    color = floor === 0 ? 'rgba(74, 74, 74, ' : 
                                           floor === 1 ? 'rgba(90, 90, 90, ' : 
                                           floor === 2 ? 'rgba(106, 106, 106, ' : 
                                           'rgba(122, 122, 122, ';
                                    break;
                                case TileType.WALL: 
                                    color = floor === 0 ? 'rgba(176, 176, 176, ' : 
                                           floor === 1 ? 'rgba(160, 160, 176, ' : 
                                           floor === 2 ? 'rgba(144, 144, 176, ' : 
                                           'rgba(128, 128, 176, ';
                                    break;
                                case TileType.DOOR: 
                                    color = 'rgba(96, 96, 96, '; 
                                    break;
                                case TileType.WINDOW: 
                                    color = 'rgba(106, 140, 175, '; 
                                    break;
                                case TileType.COVER: 
                                    color = 'rgba(48, 48, 48, '; 
                                    break;
                                case TileType.BOMBSITE_A: 
                                    color = 'rgba(90, 90, 0, '; 
                                    break;
                                case TileType.BOMBSITE_B: 
                                    color = 'rgba(90, 58, 0, '; 
                                    break;
                                case TileType.T_SPAWN: 
                                    color = 'rgba(58, 32, 32, '; 
                                    break;
                                case TileType.CT_SPAWN: 
                                    color = 'rgba(32, 32, 48, '; 
                                    break;
                                case TileType.STAIRS_UP: 
                                    color = 'rgba(139, 115, 85, '; 
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    color = 'rgba(107, 83, 69, '; 
                                    break;
                                case TileType.WATER: 
                                    color = 'rgba(42, 77, 105, '; 
                                    break;
                                case TileType.BRIDGE: 
                                    color = 'rgba(90, 90, 90, '; 
                                    break;
                            }
                            
                            // 添加透明度
                            color += opacity + ')';
                            
                            ctx.fillStyle = color;
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // 绘制墙壁边框
                            if (tile === TileType.WALL) {
                                ctx.strokeStyle = 'rgba(128, 128, 128, ' + (opacity * 0.5) + ')';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(
                                    x * cellSize + offset, 
                                    y * cellSize + offset, 
                                    cellSize, 
                                    cellSize
                                );
                            }
                            
                            // 绘制楼梯箭头和楼层标记
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                ctx.font = '8px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? '↑' : '↓';
                                ctx.fillText(
                                    arrow + (floor + 1), 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + 3 + offset
                                );
                            }
                        }
                    }
                }
                
                // 绘制楼层标签
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`F${floor + 1}`, 10 + offset, 20 + offset);
            }
            
            // 绘制说明
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('叠加视图模式', canvas.width - 10, 20);
            
            // 绘制楼层图例
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.fillRect(10, 40 + i * 20, 15, 15);
                ctx.fillStyle = '#ccc';
                ctx.fillText(`第${i + 1}层`, 30, 50 + i * 20);
            }
            
            // 绘制包点标记（所有层）
            const overlayBombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + overlayBombFontSize + 'px Arial';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                ctx.fillStyle = 'rgba(255, 215, 0, ' + opacity + ')';
                
                // A包点
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_A) {
                            ctx.strokeText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // B包点
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_B) {
                            ctx.strokeText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // C包点
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_C) {
                            ctx.strokeText('C', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('C', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // D包点
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_D) {
                            ctx.strokeText('D', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('D', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // E包点
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_E) {
                            ctx.strokeText('E', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('E', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
            }
        }
        
        // 创建楼层选择器
        function createFloorSelector() {
            const selector = document.getElementById('floorSelector');
            selector.innerHTML = '';
            
            // 添加楼层按钮
            for (let i = 0; i < totalFloors; i++) {
                const btn = document.createElement('button');
                btn.className = 'floor-btn';
                btn.textContent = `第${i + 1}层`;
                btn.onclick = function() {
                    overlayMode = false;
                    currentFloor = i;
                    updateFloorButtons();
                    drawMap();
                };
                if (i === 0 && !overlayMode) {
                    btn.classList.add('active');
                }
                selector.appendChild(btn);
            }
            
            // 添加叠加视图按钮
            if (totalFloors > 1) {
                const overlayBtn = document.createElement('button');
                overlayBtn.className = 'overlay-btn';
                overlayBtn.textContent = '🔲 叠加视图';
                overlayBtn.onclick = function() {
                    overlayMode = !overlayMode;
                    updateFloorButtons();
                    
                    if (overlayMode) {
                        overlayBtn.classList.add('active');
                        drawOverlayMap();
                    } else {
                        overlayBtn.classList.remove('active');
                        drawMap();
                    }
                };
                selector.appendChild(overlayBtn);
            }
        }
        
        // 更新楼层按钮状态
        function updateFloorButtons() {
            const buttons = document.querySelectorAll('.floor-btn');
            const overlayBtn = document.querySelector('.overlay-btn');
            
            buttons.forEach((btn, index) => {
                if (!overlayMode && index === currentFloor) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            if (overlayBtn) {
                if (overlayMode) {
                    overlayBtn.classList.add('active');
                } else {
                    overlayBtn.classList.remove('active');
                }
            }
        }
        
        // 绘制地图
        function drawMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // 启用抗锯齿和平滑效果
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[currentFloor]) return;
            
            const map = mapFloors[currentFloor];
            const mapSizeX = parseInt(document.getElementById('mapSizeX').value);
            const mapSizeY = parseInt(document.getElementById('mapSizeY').value);
            const mapSize = Math.max(mapSizeX, mapSizeY); // 使用较大的尺寸来确定格子大小
            
            // 根据地图尺寸动态调整方块大小，使用更小的尺寸减少像素感
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // 限制画布最大尺寸，避免过大
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // 清空画布
            ctx.fillStyle = getCanvasBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制地图
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[0].length; x++) {
                    const tile = map[y][x];
                    let color = '#000';
                    
                    switch(tile) {
                        case TileType.FLOOR: color = '#4a4a4a'; break;
                        case TileType.WALL: color = '#b0b0b0'; break;
                        case TileType.DOOR: color = '#606060'; break;
                        case TileType.WINDOW: color = '#6a8caf'; break;
                        case TileType.COVER: color = '#303030'; break;
                        case TileType.HIGH_GROUND: color = '#6a6a4a'; break;    // 高地（浅黄灰）
                        case TileType.LOW_GROUND: color = '#2a2a4a'; break;     // 低地（深蓝灰）
                        case TileType.MEDIUM_GROUND: color = '#4a4a4a'; break;  // 中等地（标准灰）
                        case TileType.BOMBSITE_A: color = '#5a5a00'; break;
                        case TileType.BOMBSITE_B: color = '#5a3a00'; break;
                        case TileType.BOMBSITE_C: color = '#5a1a00'; break; // 包点C（深橙）
                        case TileType.BOMBSITE_D: color = '#3a5a00'; break; // 包点D（深绿）
                        case TileType.BOMBSITE_E: color = '#1a5a00'; break; // 包点E（深青）
                        case TileType.T_SPAWN: color = '#3a2020'; break;
                        case TileType.CT_SPAWN: color = '#202030'; break;
                        case TileType.STAIRS_UP: color = '#8B7355'; break;
                        case TileType.STAIRS_DOWN: color = '#6B5345'; break;
                        case TileType.WATER: color = '#2a4d69'; break;
                        case TileType.BRIDGE: color = '#5a5a5a'; break;
                        case TileType.OUTDOOR: color = '#7a8a6a'; break;           // 外场地面（浅绿灰）
                        case TileType.OUTDOOR_WALL: color = '#8a8a7a'; break;     // 外场围墙（浅灰）
                        case TileType.OUTDOOR_COVER: color = '#4a5a4a'; break;    // 外场掩体（深绿灰）
                        case TileType.LOBBY: color = '#6a7a8a'; break;            // 大厅
                        case TileType.LOBBY_ENTRANCE: color = '#8a6a7a'; break;   // 大厅入口
                        case TileType.LOBBY_CENTER: color = '#7a6a8a'; break;     // 大厅中心
                        // 常见地形/模块颜色
                        case TileType.LONG_LANE: color = '#8a4a4a'; break;        // 大道（深红灰）
                        case TileType.SHORT_LANE: color = '#4a8a4a'; break;       // 小道（深绿灰）
                        case TileType.MID_LANE: color = '#4a4a8a'; break;         // 中路（深蓝灰）
                        case TileType.PLATFORM: color = '#8a8a4a'; break;         // 高台（深黄灰）
                        case TileType.UNDERPASS: color = '#4a8a8a'; break;        // 暗道（深青灰）
                        case TileType.CONNECTOR: color = '#8a4a8a'; break;        // 连接路（深紫灰）
                        case TileType.RAMP: color = '#6a6a6a'; break;             // 斜坡（中灰）
                        case TileType.ROTATION_PATH: color = '#5a5a5a'; break;    // 转点路线（深灰）
                        case TileType.SHADOW_POINT: color = '#8a6a4a'; break;      // 阴点（深棕灰）
                    }
                    
                    if (tile !== TileType.VOID) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        
                        // 移除墙壁边框，不使用格子
                        
                        // 绘制楼梯箭头
                        if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                            ctx.fillStyle = '#fff';
                            const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                            ctx.font = fontSize + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(tile === TileType.STAIRS_UP ? '↑' : '↓', 
                                x * cellSize + cellSize/2, y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3));
                        }
                    }
                }
            }
            
            // 绘制包点标记
            const bombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + bombFontSize + 'px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            // 包点标记映射
            const bombSiteMarkers = {
                [TileType.BOMBSITE_A]: 'A',
                [TileType.BOMBSITE_B]: 'B',
                [TileType.BOMBSITE_C]: 'C',
                [TileType.BOMBSITE_D]: 'D',
                [TileType.BOMBSITE_E]: 'E'
            };
            
            // 绘制所有包点标记
            for (const [tileType, marker] of Object.entries(bombSiteMarkers)) {
                for (let y = 0; y < map.length; y++) {
                    for (let x = 0; x < map[0].length; x++) {
                        if (map[y][x] === parseInt(tileType)) {
                            ctx.strokeText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                            ctx.fillText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                            y = map.length;
                            break;
                        }
                    }
                }
            }
        }
        
        // 绘制叠加视图
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // 启用抗锯齿和平滑效果
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const mapSizeX = parseInt(document.getElementById('mapSizeX').value);
            const mapSizeY = parseInt(document.getElementById('mapSizeY').value);
            const mapSize = Math.max(mapSizeX, mapSizeY); // 使用较大的尺寸来确定格子大小
            
            // 根据地图尺寸动态调整方块大小，使用更小的尺寸减少像素感
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // 限制画布最大尺寸，避免过大
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // 清空画布
            ctx.fillStyle = getCanvasBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 从底层到顶层绘制
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let baseColor = [0, 0, 0];
                            
                            switch(tile) {
                                case TileType.FLOOR: 
                                    baseColor = [74 + floor * 16, 74 + floor * 16, 74 + floor * 16];
                                    break;
                                case TileType.WALL: 
                                    baseColor = [176 - floor * 16, 176 - floor * 16, 176];
                                    break;
                                case TileType.HIGH_GROUND: 
                                    baseColor = [106, 106, 74]; // 高地（浅黄灰）
                                    break;
                                case TileType.LOW_GROUND: 
                                    baseColor = [42, 42, 74]; // 低地（深蓝灰）
                                    break;
                                case TileType.MEDIUM_GROUND: 
                                    baseColor = [74, 74, 74]; // 中等地（标准灰）
                                    break;
                                case TileType.COVER: 
                                    baseColor = [48, 48, 48];
                                    break;
                                case TileType.BOMBSITE_A: 
                                    baseColor = [90, 90, 0];
                                    break;
                                case TileType.BOMBSITE_B: 
                                    baseColor = [90, 58, 0];
                                    break;
                                case TileType.BOMBSITE_C: 
                                    baseColor = [90, 26, 0]; // 包点C（深橙）
                                    break;
                                case TileType.BOMBSITE_D: 
                                    baseColor = [58, 90, 0]; // 包点D（深绿）
                                    break;
                                case TileType.BOMBSITE_E: 
                                    baseColor = [26, 90, 0]; // 包点E（深青）
                                    break;
                                case TileType.T_SPAWN: 
                                    baseColor = [58, 32, 32];
                                    break;
                                case TileType.CT_SPAWN: 
                                    baseColor = [32, 32, 48];
                                    break;
                                case TileType.STAIRS_UP: 
                                    baseColor = [139, 115, 85];
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    baseColor = [107, 83, 69];
                                    break;
                                case TileType.WATER: 
                                    baseColor = [42, 77, 105];
                                    break;
                                case TileType.WINDOW:
                                    baseColor = [106, 140, 175];
                                    break;
                                // 常见地形/模块颜色
                                case TileType.LONG_LANE:
                                    baseColor = [138, 74, 74]; // 大道（深红灰）
                                    break;
                                case TileType.SHORT_LANE:
                                    baseColor = [74, 138, 74]; // 小道（深绿灰）
                                    break;
                                case TileType.MID_LANE:
                                    baseColor = [74, 74, 138]; // 中路（深蓝灰）
                                    break;
                                case TileType.PLATFORM:
                                    baseColor = [138, 138, 74]; // 高台（深黄灰）
                                    break;
                                case TileType.UNDERPASS:
                                    baseColor = [74, 138, 138]; // 暗道（深青灰）
                                    break;
                                case TileType.CONNECTOR:
                                    baseColor = [138, 74, 138]; // 连接路（深紫灰）
                                    break;
                                case TileType.RAMP:
                                    baseColor = [106, 106, 106]; // 斜坡（中灰）
                                    break;
                                case TileType.ROTATION_PATH:
                                    baseColor = [90, 90, 90]; // 转点路线（深灰）
                                    break;
                                case TileType.SHADOW_POINT:
                                    baseColor = [138, 106, 74]; // 阴点（深棕灰）
                                    break;
                                default:
                                    baseColor = [50, 50, 50];
                            }
                            
                            ctx.fillStyle = 'rgba(' + baseColor[0] + ',' + baseColor[1] + ',' + baseColor[2] + ',' + opacity + ')';
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // 移除墙壁边框，不使用格子
                            
                            // 楼梯标记
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                                ctx.font = fontSize + 'px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? '↑' : '↓';
                                ctx.fillText(
                                    arrow, 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3) + offset
                                );
                            }
                        }
                    }
                }
                
                // 楼层标签
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                const floorFontSize = Math.max(8, Math.floor(cellSize * 0.8));
                ctx.font = 'bold ' + floorFontSize + 'px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('F' + (floor + 1), Math.floor(cellSize * 0.8) + offset, Math.floor(cellSize * 1.5) + offset);
            }
            
            // 标题
            ctx.fillStyle = '#4CAF50';
            const titleFontSize = Math.max(10, Math.floor(cellSize * 1.0));
            ctx.font = 'bold ' + titleFontSize + 'px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('叠加视图', canvas.width - Math.floor(cellSize * 0.8), Math.floor(cellSize * 1.5));
            
            // 图例
            const legendFontSize = Math.max(8, Math.floor(cellSize * 0.7));
            ctx.font = legendFontSize + 'px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(200, 200, 200, ' + opacity + ')';
                const legendY = Math.floor(cellSize * 2.5) + i * Math.floor(cellSize * 1.5);
                ctx.fillRect(Math.floor(cellSize * 0.8), legendY, Math.floor(cellSize * 1.2), Math.floor(cellSize * 1.2));
                ctx.fillStyle = '#ccc';
                ctx.fillText('第' + (i + 1) + '层', Math.floor(cellSize * 2.2), legendY + Math.floor(cellSize * 0.8));
            }
        }
        
        // 导出地图
        function exportMap() {
            const data = {
                floors: mapFloors,
                totalFloors: totalFloors,
                currentFloor: currentFloor
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map_' + Date.now() + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // UCC导出日志功能
        function logUCCExport(message) {
            const logElement = document.getElementById('uccExportLog');
            if (logElement) {
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `[${timestamp}] ${message}<br>`;
                logElement.scrollTop = logElement.scrollHeight;
            }
            console.log(message);
        }

        function clearUCCLog() {
            const logElement = document.getElementById('uccExportLog');
            if (logElement) {
                logElement.innerHTML = '';
            }
        }

        // UCC导出使用说明弹窗相关函数
        function showUccTutorial() {
            const modal = document.getElementById('uccTutorialModal');
            if (modal) {
                modal.style.display = 'flex';
                // 添加ESC键关闭功能
                document.addEventListener('keydown', handleTutorialKeydown);
            }
        }

        function closeUccTutorial(neverShowAgain = false) {
            const modal = document.getElementById('uccTutorialModal');
            if (modal) {
                modal.style.display = 'none';
                // 移除ESC键监听
                document.removeEventListener('keydown', handleTutorialKeydown);
                
                // 如果用户选择不再显示，保存到localStorage
                if (neverShowAgain) {
                    localStorage.setItem('uccTutorialShown', 'true');
                }
            }
        }

        function handleTutorialKeydown(event) {
            if (event.key === 'Escape') {
                closeUccTutorial();
            }
        }

        function shouldShowUccTutorial() {
            // 检查是否已经显示过教程
            return localStorage.getItem('uccTutorialShown') !== 'true';
        }

        // UCC导出功能 - 基于Python脚本精确实现
        async function exportUCC() {
            try {
                // 检查是否需要显示首次使用教程
                if (shouldShowUccTutorial()) {
                    showUccTutorial();
                    return; // 显示教程后停止执行，用户关闭教程后需要重新点击导出按钮
                }

                clearUCCLog();
                logUCCExport('🚀 开始UCC导出...');
                
                // 获取导出参数
                const zRotation = parseFloat(document.getElementById('uccZRotation').value);
                const positionMultiplier = parseFloat(document.getElementById('uccPositionMultiplier').value);
                const scaleMultiplier = parseFloat(document.getElementById('uccScaleMultiplier').value);
                const autoConvertNegative = document.getElementById('uccAutoConvertNegative').checked;
                const wallHeightMultiplier = parseFloat(document.getElementById('uccWallHeight').value) || 1;
                const sourceFile = 'mf5';

                logUCCExport(`📋 导出参数: Z轴旋转=${zRotation}°, 位置倍增=${positionMultiplier}, 缩放倍增=${scaleMultiplier}, 墙高倍增=${wallHeightMultiplier}, 负值转正=${autoConvertNegative}, 源文件=${sourceFile}.ucc（仅允许导入弹窗方式）`);

                // 检查地图数据
                if (!mapFloors || mapFloors.length === 0) {
                    throw new Error('请先生成地图再导出');
                }
                logUCCExport(`📊 地图数据: ${mapFloors.length}层, 总共${totalFloors}层`);
                
                // 使用导入弹窗拾取的 mf5.ucc 模板；若未导入则立刻弹出选择
                let sourceTemplate = window.__importedUccTemplate;
                if (!sourceTemplate || !(sourceTemplate instanceof ArrayBuffer)) {
                    const fileInput = document.getElementById('templateFileInput');
                    if (!fileInput) throw new Error('缺少模板文件输入控件');
                    logUCCExport('📥 需要 mf5.ucc 模板，正在打开文件选择对话框...');
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const handler = async function() {
                            const file = fileInput.files && fileInput.files[0];
                            if (!file) {
                                reject(new Error('未选择文件'));
                                fileInput.removeEventListener('change', handler);
                                return;
                            }
                            const nameLower = file.name.toLowerCase();
                            if (nameLower !== 'mf5.ucc') {
                                reject(new Error('只允许选择文件名为 mf5.ucc 的模板'));
                                fileInput.value = '';
                                fileInput.removeEventListener('change', handler);
                                return;
                            }
                            try {
                                const buf = await file.arrayBuffer();
                                resolve(buf);
                            } catch(e) {
                                reject(e);
                            } finally {
                                fileInput.removeEventListener('change', handler);
                            }
                        };
                        fileInput.addEventListener('change', handler);
                        // 触发系统文件选择
                        fileInput.value = '';
                        fileInput.click();
                    });
                    window.__importedUccTemplate = arrayBuffer;
                    sourceTemplate = arrayBuffer;
                }
                logUCCExport(`✅ 已使用导入的 mf5.ucc 模板 (${sourceTemplate.byteLength} 字节)`);

                // 创建UCC二进制文件
                logUCCExport('🔧 正在处理地图数据并生成UCC文件...');
                const uccData = await createUCCFileFromTemplate(sourceTemplate, mapFloors, totalFloors, {
                    zRotation,
                    positionMultiplier,
                    scaleMultiplier,
                    wallHeightMultiplier,
                    autoConvertNegative,
                    sourceFile
                });

                // 下载文件
                const filename = 'exported_map_' + Date.now() + '.ucc';
                const blob = new Blob([uccData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                logUCCExport(`🎉 UCC文件导出成功！文件名: ${filename} (${uccData.byteLength} 字节)`);
            } catch (error) {
                logUCCExport(`❌ UCC导出失败: ${error.message}`);
                console.error('UCC导出失败:', error);
                alert('UCC导出失败: ' + error.message);
            }
        }

        // 已禁用的模板加载（统一通过导入弹窗）
        async function loadUCCTemplate() {
            throw new Error('模板加载已改为仅通过导入弹窗选择 mf5.ucc');
        }

        // 创建最小UCC模板（已禁用 - 仅使用现有模板）
        function createMinimalUCCTemplate() {
            // 此功能已被禁用，因为我们只允许使用现有的模板文件
            throw new Error("禁止创建新的UCC模板文件。必须使用Core文件夹中现有的模板文件。");
        }

        // 基于现有模板修改UCC文件 - 遵循Python脚本的精确实现
        async function createUCCFileFromTemplate(templateBuffer, floors, totalFloors, options) {
            // 复制现有模板到缓冲区进行修改 (禁止新建文件)
            const buffer = templateBuffer.slice();
            const view = new DataView(buffer);
            
            logUCCExport(`📋 基于现有模板进行修改 (${buffer.byteLength} 字节)`);
            
            // 收集所有立方体数据
            const cubes = [];
            
            for (let floorIndex = 0; floorIndex < floors.length; floorIndex++) {
                const floor = floors[floorIndex];
                const floorHeight = floorIndex * 10; // 每层10个单位高
                
                for (let y = 0; y < floor.length; y++) {
                    for (let x = 0; x < floor[y].length; x++) {
                        const cell = floor[y][x];
                        if (cell === TileType.WALL) { // 墙体
                            cubes.push({
                                name: `Wall_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.FLOOR) { // 房间地板
                            cubes.push({
                                name: `Floor_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight - 0.5,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 0.1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.DOOR) { // 特殊方块
                            cubes.push({
                                name: `Special_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        }
                    }
                }
            }
            
            logUCCExport(`📦 收集到 ${cubes.length} 个立方体对象`);
            
            // 应用围绕中心点的Z轴旋转 - 基于Python实现
            if (options.zRotation !== 0) {
                logUCCExport(`🔄 应用Z轴旋转 ${options.zRotation}°...`);
                applyCenterRotationPython(cubes, options.zRotation);
            }
            
            // 计算文件能容纳的最大方块数 - 基于Python公式
            const maxPossibleCubes = Math.floor((buffer.byteLength - 127) / 200);
            logUCCExport(`🗂️ 文件可容纳约 ${maxPossibleCubes} 个立方体，实际需要 ${cubes.length} 个`);
            
            // 按Python脚本方式写入立方体数据
            for (let i = 0; i < cubes.length && i < maxPossibleCubes; i++) {
                const cube = cubes[i];
                
                // 使用Python脚本的固定索引计算方式
                const baseIndex = 127 + (i * 200);
                const coordStart = baseIndex;
                const rotationStart = baseIndex + 12;
                const sizeIndex = baseIndex + 28;
                
                // 检查索引是否在文件范围内
                if (sizeIndex + 12 > buffer.byteLength) {
                    console.warn(`立方体 ${cube.name} 在索引 ${i} 处超出文件大小`);
                    continue;
                }
                
                // 转换坐标系统（Blender到UCC）- 基于Python实现
                const uccX = cube.x * 35 * options.positionMultiplier;
                const uccY = cube.y * 35 * options.positionMultiplier;
                const uccZ = cube.z * 35 * options.positionMultiplier;
                
                // 转换旋转（四元数）
                const uccRotation = [cube.rotationX, cube.rotationY, cube.rotationZ, cube.rotationW];
                
                // 转换尺寸，应用缩放倍增器和负值转换
                let scaleX = cube.scaleX * options.scaleMultiplier;
                let scaleY = cube.scaleY * options.scaleMultiplier;
                let scaleZ = cube.scaleZ * options.scaleMultiplier;
                // 对墙体应用额外的高度倍增
                if (cube.name.startsWith('Wall_') && typeof options.wallHeightMultiplier === 'number') {
                    scaleZ = scaleZ * options.wallHeightMultiplier;
                }
                
                if (options.autoConvertNegative) {
                    scaleX = Math.abs(scaleX);
                    scaleY = Math.abs(scaleY);
                    scaleZ = Math.abs(scaleZ);
                }
                
                // 写入数据到指定位置 - 遵循Python的struct.pack格式
                // 写入坐标 (12字节，小端序)
                if (coordStart >= 0 && coordStart + 12 <= buffer.byteLength) {
                    view.setFloat32(coordStart, uccX, true);
                    view.setFloat32(coordStart + 4, uccY, true);
                    view.setFloat32(coordStart + 8, uccZ, true);
                }
                
                // 写入旋转 (16字节，小端序，四元数XYZW)
                if (rotationStart >= 0 && rotationStart + 16 <= buffer.byteLength) {
                    view.setFloat32(rotationStart, uccRotation[0], true);
                    view.setFloat32(rotationStart + 4, uccRotation[1], true);
                    view.setFloat32(rotationStart + 8, uccRotation[2], true);
                    view.setFloat32(rotationStart + 12, uccRotation[3], true);
                }
                
                // 写入尺寸 (在分隔符后12字节，小端序)
                if (sizeIndex >= 0 && sizeIndex + 16 <= buffer.byteLength) {
                    // 确保分隔符存在
                    view.setUint8(sizeIndex, 0x00);
                    view.setUint8(sizeIndex + 1, 0x00);
                    view.setUint8(sizeIndex + 2, 0x80);
                    view.setUint8(sizeIndex + 3, 0x3F);
                    
                    // 写入尺寸数据
                    view.setFloat32(sizeIndex + 4, scaleX, true);
                    view.setFloat32(sizeIndex + 8, scaleY, true);
                    view.setFloat32(sizeIndex + 12, scaleZ, true);
                }
                
                // 每隔一定数量显示进度
                if (i % 50 === 0 || i === cubes.length - 1) {
                    logUCCExport(`📝 正在写入立方体数据... ${i + 1}/${cubes.length}`);
                }
            }
            
            // 将多余的方块位置归零 - 基于Python实现
            const maxCubes = Math.min(10000, maxPossibleCubes);
            logUCCExport(`🧹 清理多余位置... (${cubes.length} 到 ${maxCubes})`);
            for (let i = cubes.length; i < maxCubes; i++) {
                const baseIndex = 127 + (i * 200);
                const coordStart = baseIndex;
                const rotationStart = baseIndex + 12;
                const sizeIndex = baseIndex + 28;
                
                // 检查索引是否在文件范围内
                if (sizeIndex + 12 > buffer.byteLength) {
                    break;
                }
                
                // 位置归零
                if (coordStart >= 0 && coordStart + 12 <= buffer.byteLength) {
                    view.setFloat32(coordStart, 0.0, true);
                    view.setFloat32(coordStart + 4, 0.0, true);
                    view.setFloat32(coordStart + 8, 0.0, true);
                }
                
                // 旋转归零（默认四元数）
                if (rotationStart >= 0 && rotationStart + 16 <= buffer.byteLength) {
                    view.setFloat32(rotationStart, 0.0, true);
                    view.setFloat32(rotationStart + 4, 0.0, true);
                    view.setFloat32(rotationStart + 8, 0.0, true);
                    view.setFloat32(rotationStart + 12, 1.0, true);
                }
                
                // 尺寸归零
                if (sizeIndex >= 0 && sizeIndex + 16 <= buffer.byteLength) {
                    view.setFloat32(sizeIndex + 4, 0.0, true);
                    view.setFloat32(sizeIndex + 8, 0.0, true);
                    view.setFloat32(sizeIndex + 12, 0.0, true);
                }
            }
            
            logUCCExport(`✅ 已导出 ${cubes.length} 个立方体，多余位置已清理`);
            return buffer;
        }

        // 应用围绕中心点的Z轴旋转 - 基于Python mathutils实现
        function applyCenterRotationPython(cubes, zAngleDegrees) {
            if (cubes.length === 0) return;
            
            // 计算所有立方体的平均位置（组合中心点）
            let totalX = 0, totalY = 0, totalZ = 0;
            for (const cube of cubes) {
                totalX += cube.x;
                totalY += cube.y;
                totalZ += cube.z;
            }
            const centerX = totalX / cubes.length;
            const centerY = totalY / cubes.length;
            const centerZ = totalZ / cubes.length;
            
            logUCCExport(`🎯 计算组合中心点: (${centerX.toFixed(3)}, ${centerY.toFixed(3)}, ${centerZ.toFixed(3)})`);
            
            // 转换角度为弧度
            const zAngleRad = zAngleDegrees * Math.PI / 180;
            
            // 创建Z轴旋转四元数 - 基于Python的实现
            const zQuat = {
                x: 0,
                y: 0,
                z: Math.sin(zAngleRad / 2),
                w: Math.cos(zAngleRad / 2)
            };
            
            // 对每个立方体应用围绕组合中心的旋转
            for (const cube of cubes) {
                // 计算相对于组合中心的偏移
                const offsetX = cube.x - centerX;
                const offsetY = cube.y - centerY;
                const offsetZ = cube.z - centerZ;
                
                // 应用Z轴旋转到偏移向量
                const rotatedOffsetX = offsetX * Math.cos(zAngleRad) - offsetY * Math.sin(zAngleRad);
                const rotatedOffsetY = offsetX * Math.sin(zAngleRad) + offsetY * Math.cos(zAngleRad);
                const rotatedOffsetZ = offsetZ; // Z轴旋转不影响Z坐标
                
                // 计算新的位置
                cube.x = centerX + rotatedOffsetX;
                cube.y = centerY + rotatedOffsetY;
                cube.z = centerZ + rotatedOffsetZ;
                
                // 应用旋转到物体的朝向（四元数乘法）
                const originalQuat = {
                    x: cube.rotationX,
                    y: cube.rotationY,
                    z: cube.rotationZ,
                    w: cube.rotationW
                };
                
                // 四元数乘法：zQuat * originalQuat
                const newQuat = multiplyQuaternions(zQuat, originalQuat);
                cube.rotationX = newQuat.x;
                cube.rotationY = newQuat.y;
                cube.rotationZ = newQuat.z;
                cube.rotationW = newQuat.w;
            }
            
            logUCCExport(`✅ 所有立方体已围绕组合中心完成 Z轴${zAngleDegrees}° 整体旋转`);
        }
        
        // 四元数乘法
        function multiplyQuaternions(q1, q2) {
            return {
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
            };
        }

        // 创建UCC文件的核心函数（保留兼容性）
        function createUCCFile(floors, totalFloors, options) {
            // 创建基础UCC文件模板
            const baseTemplate = createUCCTemplate(options.sourceFile);
            
            // 收集所有立方体数据
            const cubes = [];
            
            for (let floorIndex = 0; floorIndex < floors.length; floorIndex++) {
                const floor = floors[floorIndex];
                const floorHeight = floorIndex * 10; // 每层10个单位高
                
                for (let y = 0; y < floor.length; y++) {
                    for (let x = 0; x < floor[y].length; x++) {
                        const cell = floor[y][x];
                        if (cell === TileType.WALL) { // 墙体
                            cubes.push({
                                name: `Wall_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.FLOOR) { // 房间地板
                            cubes.push({
                                name: `Floor_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight - 0.5,
                                scaleX: 1,
                                scaleY: 1,
                                scaleZ: 0.1,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        } else if (cell === TileType.DOOR) { // 特殊方块
                            cubes.push({
                                name: `Special_${floorIndex}_${x}_${y}`,
                                x: x,
                                y: y,
                                z: floorHeight,
                                scaleX: 1.2,
                                scaleY: 1.2,
                                scaleZ: 1.2,
                                rotationX: 0,
                                rotationY: 0,
                                rotationZ: 0,
                                rotationW: 1
                            });
                        }
                    }
                }
            }

            console.log(`生成了 ${cubes.length} 个立方体`);

            // 应用Z轴旋转变换（围绕中心点）
            if (options.zRotation !== 0) {
                applyCenterRotation(cubes, options.zRotation);
            }

            // 写入立方体数据到UCC模板
            return writeObjectsToUCC(baseTemplate, cubes, options);
        }

        // 创建UCC模板
        function createUCCTemplate(sourceType) {
            // 创建基础UCC文件结构
            // 最小UCC文件大小约为127字节的头部 + 20000 * 200字节的数据区域
            const headerSize = 127;
            const maxObjects = 10000;
            const objectSize = 200; // 每个物体200字节
            const totalSize = headerSize + (maxObjects * objectSize);
            
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            
            // 写入UCC文件头 (简化版本)
            // 这里我们创建一个最小的有效UCC头部
            const header = new Uint8Array([
                0x55, 0x43, 0x43, 0x20, // "UCC "
                0x01, 0x00, 0x00, 0x00, // 版本
                0x00, 0x00, 0x00, 0x00, // 保留字段
                0x7F, 0x00, 0x00, 0x00  // 数据开始偏移 (127)
            ]);
            
            // 复制头部到缓冲区
            const headerView = new Uint8Array(buffer, 0, header.length);
            headerView.set(header);
            
            // 填充剩余头部为零
            for (let i = header.length; i < headerSize; i++) {
                view.setUint8(i, 0);
            }
            
            return buffer;
        }

        // 应用围绕中心点的Z轴旋转
        function applyCenterRotation(cubes, zAngleDegrees) {
            if (cubes.length === 0) return;
            
            // 计算所有立方体的中心点
            let centerX = 0, centerY = 0, centerZ = 0;
            for (const cube of cubes) {
                centerX += cube.x;
                centerY += cube.y;
                centerZ += cube.z;
            }
            centerX /= cubes.length;
            centerY /= cubes.length;
            centerZ /= cubes.length;
            
            console.log(`中心点: (${centerX.toFixed(2)}, ${centerY.toFixed(2)}, ${centerZ.toFixed(2)})`);
            
            // 转换角度为弧度
            const zAngleRad = zAngleDegrees * Math.PI / 180;
            const cos = Math.cos(zAngleRad);
            const sin = Math.sin(zAngleRad);
            
            // 创建Z轴旋转四元数
            const rotationQuat = {
                x: 0,
                y: 0,
                z: Math.sin(zAngleRad / 2),
                w: Math.cos(zAngleRad / 2)
            };
            
            // 对每个立方体应用旋转
            for (const cube of cubes) {
                // 计算相对于中心点的偏移
                const offsetX = cube.x - centerX;
                const offsetY = cube.y - centerY;
                
                // 应用旋转到偏移向量
                const rotatedX = offsetX * cos - offsetY * sin;
                const rotatedY = offsetX * sin + offsetY * cos;
                
                // 更新位置
                cube.x = centerX + rotatedX;
                cube.y = centerY + rotatedY;
                
                // 应用旋转到物体的朝向（四元数乘法）
                const currentQuat = {
                    x: cube.rotationX,
                    y: cube.rotationY,
                    z: cube.rotationZ,
                    w: cube.rotationW
                };
                
                const newQuat = multiplyQuaternions(rotationQuat, currentQuat);
                cube.rotationX = newQuat.x;
                cube.rotationY = newQuat.y;
                cube.rotationZ = newQuat.z;
                cube.rotationW = newQuat.w;
            }
            
            console.log(`已对 ${cubes.length} 个立方体应用 ${zAngleDegrees}° Z轴旋转`);
        }

        // 四元数乘法
        function multiplyQuaternions(q1, q2) {
            return {
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
            };
        }

        // 将立方体数据写入UCC文件
        function writeObjectsToUCC(templateBuffer, cubes, options) {
            const buffer = templateBuffer.slice(); // 创建副本
            const view = new DataView(buffer);
            
            const headerSize = 127;
            const objectSize = 200;
            const maxObjects = Math.min(cubes.length, 10000);
            
            console.log(`写入 ${maxObjects} 个物体到UCC文件`);
            
            // 写入每个立方体的数据
            for (let i = 0; i < maxObjects; i++) {
                const cube = cubes[i];
                const baseIndex = headerSize + (i * objectSize);
                
                // 转换坐标系统（Web坐标到UCC坐标）
                const uccX = cube.x * 35 * options.positionMultiplier;
                const uccY = cube.y * 35 * options.positionMultiplier;
                const uccZ = cube.z * 35 * options.positionMultiplier;
                
                // 处理缩放
                let scaleX = cube.scaleX * options.scaleMultiplier;
                let scaleY = cube.scaleY * options.scaleMultiplier;
                let scaleZ = cube.scaleZ * options.scaleMultiplier;
                
                if (options.autoConvertNegative) {
                    scaleX = Math.abs(scaleX);
                    scaleY = Math.abs(scaleY);
                    scaleZ = Math.abs(scaleZ);
                }
                
                // 写入坐标 (12字节)
                const coordStart = baseIndex;
                view.setFloat32(coordStart, uccX, true);      // X坐标
                view.setFloat32(coordStart + 4, uccY, true);  // Y坐标
                view.setFloat32(coordStart + 8, uccZ, true);  // Z坐标
                
                // 写入旋转 (16字节，四元数XYZW)
                const rotationStart = baseIndex + 12;
                view.setFloat32(rotationStart, cube.rotationX, true);     // X
                view.setFloat32(rotationStart + 4, cube.rotationY, true); // Y
                view.setFloat32(rotationStart + 8, cube.rotationZ, true); // Z
                view.setFloat32(rotationStart + 12, cube.rotationW, true); // W
                
                // 写入尺寸分隔符和尺寸 (4 + 12字节)
                const sizeStart = baseIndex + 28;
                // 尺寸分隔符
                view.setUint8(sizeStart, 0x00);
                view.setUint8(sizeStart + 1, 0x00);
                view.setUint8(sizeStart + 2, 0x80);
                view.setUint8(sizeStart + 3, 0x3F);
                
                // 尺寸数据
                view.setFloat32(sizeStart + 4, scaleX, true);  // X尺寸
                view.setFloat32(sizeStart + 8, scaleY, true);  // Y尺寸
                view.setFloat32(sizeStart + 12, scaleZ, true); // Z尺寸
                
                // 写入物体名称 (从44字节开始)
                const nameStart = baseIndex + 44;
                const nameBytes = new TextEncoder().encode(cube.name);
                const maxNameLength = Math.min(nameBytes.length, 155); // 预留空间
                
                for (let j = 0; j < maxNameLength; j++) {
                    view.setUint8(nameStart + j, nameBytes[j]);
                }
                // 名称结束符
                if (nameStart + maxNameLength < buffer.byteLength) {
                    view.setUint8(nameStart + maxNameLength, 0);
                }
            }
            
            // 清零剩余的物体位置
            for (let i = maxObjects; i < 10000; i++) {
                const baseIndex = headerSize + (i * objectSize);
                if (baseIndex + objectSize <= buffer.byteLength) {
                    // 清零整个物体数据区域
                    for (let j = 0; j < objectSize; j++) {
                        view.setUint8(baseIndex + j, 0);
                    }
                    
                    // 设置默认旋转四元数 (0, 0, 0, 1)
                    const rotationStart = baseIndex + 12;
                    view.setFloat32(rotationStart + 12, 1.0, true); // W = 1
                }
            }
            
            console.log('UCC文件数据写入完成');
            return buffer;
        }
        
        // 找到最佳的门位置
        function findBestDoorPosition(room, floor) {
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0, score: 0 }, // 左
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0, score: 0 }, // 右
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1, score: 0 }, // 上
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1, score: 0 } // 下
            ];
            
            // 为每个位置评分
            for (let side of sides) {
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    
                    // 检查门外是否有空地
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        side.score += 10;
                    }
                    
                    // 检查是否靠近其他房间
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = -3; dx <= 3; dx++) {
                            const nx = corridorX + dx;
                            const ny = corridorY + dy;
                            if (nx >= 0 && nx < mapFloors[floor][0].length && 
                                ny >= 0 && ny < mapFloors[floor].length) {
                                if (mapFloors[floor][ny][nx] === TileType.FLOOR) {
                                    side.score += 5;
                                }
                            }
                        }
                    }
                }
            }
            
            // 选择得分最高的位置
            sides.sort((a, b) => b.score - a.score);
            return sides[0].score > 0 ? sides[0] : null;
        }
        
        // 创建连续水域区域
        function createWaterAreas(waterAmount) {
            const mapSize = mapFloors[0].length;
            const waterCount = Math.floor(mapSize * mapSize * waterAmount / 1000);
            
            // 创建多个水域区域
            const waterAreas = Math.max(1, Math.floor(waterCount / 50)); // 根据水域数量决定区域数量
            
            for (let area = 0; area < waterAreas; area++) {
                // 随机选择水域起始点
                let startX, startY;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    startX = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    startY = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    (startX < 0 || startX >= mapSize || startY < 0 || startY >= mapSize ||
                     !mapFloors[0][startY] || mapFloors[0][startY][startX] === undefined ||
                     (mapFloors[0][startY][startX] !== TileType.FLOOR &&
                      mapFloors[0][startY][startX] !== TileType.MEDIUM_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.HIGH_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.LOW_GROUND))
                );
                
                if (attempts >= maxAttempts) continue;
                
                // 使用洪水填充算法创建连续水域
                const areaSize = Math.floor(waterCount / waterAreas);
                floodFillWater(startX, startY, areaSize);
            }
        }
        
        // 洪水填充算法创建水域
        function floodFillWater(startX, startY, maxSize) {
            const queue = [{x: startX, y: startY}];
            const visited = new Set();
            let filledCount = 0;
            
            while (queue.length > 0 && filledCount < maxSize) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                                        // 检查当前位置是否适合放置水域
                        if (current.x >= 0 && current.x < mapFloors[0][0].length &&
                            current.y >= 0 && current.y < mapFloors[0].length &&
                            mapFloors[0][current.y] && mapFloors[0][current.y][current.x] !== undefined) {
                            
                            if (mapFloors[0][current.y][current.x] === TileType.FLOOR ||
                                mapFloors[0][current.y][current.x] === TileType.MEDIUM_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.HIGH_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.LOW_GROUND) {
                                
                                // 放置水域
                                mapFloors[0][current.y][current.x] = TileType.WATER;
                        filledCount++;
                        
                        // 添加相邻位置到队列
                        const directions = [
                            {dx: -1, dy: 0}, {dx: 1, dy: 0},
                            {dx: 0, dy: -1}, {dx: 0, dy: 1}
                        ];
                        
                        for (const dir of directions) {
                            const nextX = current.x + dir.dx;
                            const nextY = current.y + dir.dy;
                            const nextKey = `${nextX},${nextY}`;
                            
                            if (!visited.has(nextKey) && 
                                nextX >= 0 && nextX < mapFloors[0][0].length &&
                                nextY >= 0 && nextY < mapFloors[0].length) {
                                
                                // 随机决定是否继续扩展（创建自然形状）
                                if (Math.random() < 0.7) { // 70%概率继续扩展
                                    queue.push({x: nextX, y: nextY});
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // 种子系统
        let savedSeeds = [];
        let currentSeed = null;
        
        // 生成当前参数的唯一种子
        function generateSeed() {
            const params = {
                mapSizeX: document.getElementById('mapSizeX').value,
                mapSizeY: document.getElementById('mapSizeY').value,
                floorCount: document.getElementById('floorCount').value,
                roomCount: document.getElementById('roomCount').value,
                roomSize: document.getElementById('roomSize').value,
                roomPosition: document.getElementById('roomPosition').value,
                corridorWidth: document.getElementById('corridorWidth').value,
                pathComplexity: document.getElementById('pathComplexity').value,
                corridorRandom: document.getElementById('corridorRandom').value,
                coverDensity: document.getElementById('coverDensity').value,
                waterAmount: document.getElementById('waterAmount').value,
                stairsCount: document.getElementById('stairsCount').value,
                windowDensity: document.getElementById('windowDensity').value,
                elevation: document.getElementById('elevation').value,
                longLanes: document.getElementById('longLanes').value,
                midControl: document.getElementById('midControl').value,
                rotateTime: document.getElementById('rotateTime').value,
                verticality: document.getElementById('verticality').value,
                breakables: document.getElementById('breakables').value,
                fieldLayout: document.getElementById('fieldLayout').value,
                gameMode: document.getElementById('gameMode').value,
                mapStyle: document.getElementById('mapStyle').value,
                outdoorRatio: document.getElementById('outdoorRatio').value,
                outdoorWall: document.getElementById('outdoorWall').checked,
                generateLobby: document.getElementById('generateLobby').value,
                nadeSpots: document.getElementById('nadeSpots').value,
                // 常见地形/模块参数
                longLane: document.getElementById('longLane').value,
                shortLane: document.getElementById('shortLane').value,
                midLane: document.getElementById('midLane').value,
                platform: document.getElementById('platform').value,
                underpass: document.getElementById('underpass').value,
                connector: document.getElementById('connector').value,
                ramp: document.getElementById('ramp').value,
                rotation: document.getElementById('rotation').value,
                bombSiteCount: document.getElementById('bombSiteCount').value,
                shadowPoint: document.getElementById('shadowPoint').value,
                roomFill: document.getElementById('roomFill').value
            };
            
            // 创建种子字符串
            const seedString = JSON.stringify(params);
            return btoa(seedString).substring(0, 16); // 取前16位作为种子
        }
        
        // 保存当前种子
        function saveCurrentSeed() {
            const seed = generateSeed();
            const seedName = prompt('请输入种子名称:', `种子_${new Date().toLocaleDateString()}`);
            
            if (!seedName) return;
            
            const seedData = {
                id: Date.now(),
                name: seedName,
                seed: seed,
                date: new Date().toISOString(),
                params: {
                    mapSizeX: document.getElementById('mapSizeX').value,
                    mapSizeY: document.getElementById('mapSizeY').value,
                    floorCount: document.getElementById('floorCount').value,
                    roomCount: document.getElementById('roomCount').value,
                    roomSize: document.getElementById('roomSize').value,
                    roomPosition: document.getElementById('roomPosition').value,
                    corridorWidth: document.getElementById('corridorWidth').value,
                    pathComplexity: document.getElementById('pathComplexity').value,
                    corridorRandom: document.getElementById('corridorRandom').value,
                    coverDensity: document.getElementById('coverDensity').value,
                    waterAmount: document.getElementById('waterAmount').value,
                    stairsCount: document.getElementById('stairsCount').value,
                    windowDensity: document.getElementById('windowDensity').value,
                    elevation: document.getElementById('elevation').value,
                    longLanes: document.getElementById('longLanes').value,
                    midControl: document.getElementById('midControl').value,
                    rotateTime: document.getElementById('rotateTime').value,
                    verticality: document.getElementById('verticality').value,
                    breakables: document.getElementById('breakables').value,
                    fieldLayout: document.getElementById('fieldLayout').value,
                    gameMode: document.getElementById('gameMode').value,
                    mapStyle: document.getElementById('mapStyle').value,
                    outdoorRatio: document.getElementById('outdoorRatio').value,
                    outdoorWall: document.getElementById('outdoorWall').checked,
                    generateLobby: document.getElementById('generateLobby').value,
                    nadeSpots: document.getElementById('nadeSpots').value,
                    longLane: document.getElementById('longLane').value,
                    shortLane: document.getElementById('shortLane').value,
                    midLane: document.getElementById('midLane').value,
                    platform: document.getElementById('platform').value,
                    underpass: document.getElementById('underpass').value,
                    connector: document.getElementById('connector').value,
                    ramp: document.getElementById('ramp').value,
                    rotation: document.getElementById('rotation').value,
                    bombSiteCount: document.getElementById('bombSiteCount').value,
                    shadowPoint: document.getElementById('shadowPoint').value,
                    roomFill: document.getElementById('roomFill').value
                }
            };
            
            savedSeeds.push(seedData);
            saveSeedsToStorage();
            renderSeedsList();
        }
        
        // 应用种子参数
        function applySeed(seedData) {
            const params = seedData.params;
            
            // 应用所有参数
            Object.keys(params).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = params[key];
                    
                    // 触发oninput事件以更新显示值
                    if (element.oninput) {
                        element.oninput();
                    }
                }
            });
            
            // 特殊处理下拉菜单
            if (params.gameMode) {
                document.getElementById('gameMode').value = params.gameMode;
                applyGameMode(params.gameMode);
            }
            
            if (params.mapStyle) {
                document.getElementById('mapStyle').value = params.mapStyle;
                applyMapStyle(params.mapStyle);
            }
            
            // 重新生成地图
            generateMap();
        }
        
        // 删除种子
        function deleteSeed(seedId) {
            if (confirm('确定要删除这个种子吗？')) {
                savedSeeds = savedSeeds.filter(seed => seed.id !== seedId);
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // 清空所有种子
        function clearAllSeeds() {
            if (confirm('确定要清空所有种子吗？')) {
                savedSeeds = [];
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // 切换种子面板显示/隐藏
        function toggleSeedsPanel() {
            const panel = document.querySelector('.seeds-panel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }
        
        // 隐藏种子面板
        function hideSeedsPanel() {
            const panel = document.querySelector('.seeds-panel');
            panel.style.display = 'none';
        }
        
        // 显示种子面板
        function showSeedsPanel() {
            const panel = document.querySelector('.seeds-panel');
            panel.style.display = 'block';
        }
        
        // 渲染种子列表
        function renderSeedsList() {
            const seedsList = document.getElementById('seedsList');
            seedsList.innerHTML = '';
            
            if (savedSeeds.length === 0) {
                seedsList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">暂无收藏的种子</div>';
                return;
            }
            
            savedSeeds.forEach(seed => {
                const seedItem = document.createElement('div');
                seedItem.className = 'seed-item';
                
                const date = new Date(seed.date);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString().substring(0, 5);
                
                // 创建参数摘要
                const paramSummary = [
                    `尺寸: ${seed.params.mapSizeX || seed.params.mapSize || '60'} x ${seed.params.mapSizeY || seed.params.mapSize || '60'}`,
                    `层数: ${seed.params.floorCount}`,
                    `房间: ${seed.params.roomCount}`,
                    `掩体: ${seed.params.coverDensity}%`,
                    `水域: ${seed.params.waterAmount}%`
                ].join(' | ');
                
                seedItem.innerHTML = `
                    <div class="seed-header">
                        <div class="seed-name">${seed.name}</div>
                        <div class="seed-date">${dateStr}</div>
                    </div>
                    <div class="seed-params">${paramSummary}</div>
                    <div class="seed-actions">
                        <button onclick="applySeed(${JSON.stringify(seed).replace(/"/g, '&quot;')})">应用</button>
                        <button class="delete" onclick="deleteSeed(${seed.id})">删除</button>
                    </div>
                `;
                
                seedsList.appendChild(seedItem);
            });
        }
        
        // 保存种子到本地存储
        function saveSeedsToStorage() {
            localStorage.setItem('mapGeneratorSeeds', JSON.stringify(savedSeeds));
        }
        
        // 从本地存储加载种子
        function loadSeedsFromStorage() {
            const stored = localStorage.getItem('mapGeneratorSeeds');
            if (stored) {
                savedSeeds = JSON.parse(stored);
            }
        }
        
        // 添加房间填充（使用迷宫算法填充房间）
        function addRoomFilling(rooms, floor) {
            const roomFillDensity = parseInt(document.getElementById('roomFill').value);
            if (roomFillDensity === 0) return; // 无填充
            
            const densityMultiplier = [0, 0.3, 0.6, 1.0, 1.5][roomFillDensity]; // 密度倍数
            console.log(`楼层${floor}房间填充密度: ${roomFillDensity}, 倍数: ${densityMultiplier}`);
            
            let totalFilledRooms = 0;
            const maxFillRooms = Math.min(20, rooms.length); // 限制最大填充房间数
            let processedRooms = 0;
            
            for (let room of rooms) {
                if (processedRooms >= maxFillRooms) break; // 限制处理数量
                
                // 跳过太小的房间或过大的房间（避免性能问题）
                if (room.width < 8 || room.height < 8 || room.width > 50 || room.height > 50) continue;
                
                // 根据密度决定是否填充这个房间
                if (Math.random() < densityMultiplier) {
                    console.log(`房间(${room.x},${room.y},${room.width}x${room.height}) 使用迷宫填充，密度: ${roomFillDensity}`);
                    
                    if (createMazeInRoom(room, floor, roomFillDensity)) {
                        totalFilledRooms++;
                    }
                }
                processedRooms++;
            }
            
            console.log(`楼层${floor}总共填充了${totalFilledRooms}个迷宫房间`);
        }
        
        // 在房间内部创建迷宫
        function createMazeInRoom(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2; // 留出边距
            const roomHeight = parentRoom.height - 2;
            
            if (roomWidth < 4 || roomHeight < 4) return false;
            
            // 根据密度调整迷宫网格大小
            const densityFactors = [0, 1.5, 1.2, 1.0, 0.8]; // 密度越高，网格越小（更密集）
            const gridSizeFactor = densityFactors[density];
            
            // 计算迷宫网格大小（根据密度调整）
            const baseMazeWidth = Math.floor(roomWidth / 2);
            const baseMazeHeight = Math.floor(roomHeight / 2);
            const mazeWidth = Math.max(2, Math.floor(baseMazeWidth * gridSizeFactor));
            const mazeHeight = Math.max(2, Math.floor(baseMazeHeight * gridSizeFactor));
            
            console.log(`迷宫网格: ${mazeWidth}x${mazeHeight}, 密度: ${density}, 网格因子: ${gridSizeFactor}`);
            
            // 创建迷宫网格
            const maze = createMazeGrid(mazeWidth, mazeHeight, density);
            
            // 将迷宫应用到房间中
            applyMazeToRoom(maze, parentRoom, floor, density);
            
            // 创建入口和出口
            createMazeEntrances(parentRoom, floor, density);
            
            return true;
        }
        
        // 创建迷宫网格（使用深度优先搜索算法）
        function createMazeGrid(width, height, density) {
            // 初始化迷宫网格，所有墙都是封闭的
            const maze = [];
            for (let y = 0; y < height * 2 + 1; y++) {
                maze[y] = [];
                for (let x = 0; x < width * 2 + 1; x++) {
                    maze[y][x] = 1; // 1表示墙，0表示通道
                }
            }
            
            // 使用深度优先搜索生成迷宫
            const stack = [];
            const visited = new Set();
            
            // 从左上角开始
            const startX = 1;
            const startY = 1;
            stack.push([startX, startY]);
            visited.add(`${startX},${startY}`);
            maze[startY][startX] = 0;
            
            const directions = [
                [0, -2], // 上
                [2, 0],  // 右
                [0, 2],  // 下
                [-2, 0]  // 左
            ];
            
            while (stack.length > 0) {
                const [currentX, currentY] = stack[stack.length - 1];
                
                // 随机打乱方向
                const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                
                let moved = false;
                for (const [dx, dy] of shuffledDirections) {
                    const newX = currentX + dx;
                    const newY = currentY + dy;
                    
                    if (newX >= 1 && newX < width * 2 && newY >= 1 && newY < height * 2) {
                        const key = `${newX},${newY}`;
                        if (!visited.has(key)) {
                            // 打通墙壁
                            maze[currentY + dy/2][currentX + dx/2] = 0;
                            maze[newY][newX] = 0;
                            
                            visited.add(key);
                            stack.push([newX, newY]);
                            moved = true;
                            break;
                        }
                    }
                }
                
                if (!moved) {
                    stack.pop();
                }
            }
            
            // 根据密度添加额外的墙壁（增加迷宫复杂度）
            addDensityWalls(maze, width, height, density);
            
            return maze;
        }
        
        // 根据密度添加额外的墙壁
        function addDensityWalls(maze, width, height, density) {
            const densityFactors = [0, 0.1, 0.2, 0.3, 0.5]; // 密度越高，额外墙壁越多
            const extraWallChance = densityFactors[density];
            
            if (extraWallChance === 0) return;
            
            const totalCells = width * height;
            const extraWalls = Math.floor(totalCells * extraWallChance);
            
            console.log(`添加${extraWalls}个额外墙壁，密度: ${density}, 概率: ${extraWallChance}`);
            
            for (let i = 0; i < extraWalls; i++) {
                // 随机选择位置添加墙壁
                const x = 1 + Math.floor(Math.random() * (width - 1)) * 2;
                const y = 1 + Math.floor(Math.random() * (height - 1)) * 2;
                
                // 检查是否可以添加墙壁（不会完全封闭区域）
                if (canAddWall(maze, x, y)) {
                    maze[y][x] = 1;
                }
            }
        }
        
        // 检查是否可以添加墙壁
        function canAddWall(maze, x, y) {
            // 检查周围是否有足够的通道
            let channelCount = 0;
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length) {
                    if (maze[ny][nx] === 0) {
                        channelCount++;
                    }
                }
            }
            
            // 确保至少有两个通道连接
            return channelCount >= 2;
        }
        
        // 将迷宫应用到房间中
        function applyMazeToRoom(maze, parentRoom, floor, density) {
            const startX = parentRoom.x + 1;
            const startY = parentRoom.y + 1;
            
            // 根据密度调整墙壁厚度
            const wallThickness = Math.max(1, Math.floor(density / 2)); // 密度越高，墙壁越厚
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    const worldX = startX + x;
                    const worldY = startY + y;
                    
                    if (worldX >= 0 && worldX < mapFloors[floor][0].length && 
                        worldY >= 0 && worldY < mapFloors[floor].length) {
                        if (mapFloors[floor][worldY] && mapFloors[floor][worldY][worldX] !== undefined) {
                            if (maze[y][x] === 1) {
                                // 墙壁（根据密度调整厚度）
                                for (let wy = 0; wy < wallThickness; wy++) {
                                    for (let wx = 0; wx < wallThickness; wx++) {
                                        const thickX = worldX + wx;
                                        const thickY = worldY + wy;
                                        if (thickX >= 0 && thickX < mapFloors[floor][0].length && 
                                            thickY >= 0 && thickY < mapFloors[floor].length) {
                                            if (mapFloors[floor][thickY] && mapFloors[floor][thickY][thickX] !== undefined) {
                                                mapFloors[floor][thickY][thickX] = TileType.WALL;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // 通道
                                mapFloors[floor][worldY][worldX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
            
            console.log(`迷宫墙壁厚度: ${wallThickness}, 密度: ${density}`);
        }
        
        // 创建迷宫入口和出口
        function createMazeEntrances(parentRoom, floor, density) {
            const roomWidth = parentRoom.width;
            const roomHeight = parentRoom.height;
            
            // 根据密度调整入口数量
            const entranceCount = Math.min(4, Math.max(1, Math.floor(density / 2) + 1));
            
            // 创建多个入口（根据密度）
            for (let e = 0; e < entranceCount; e++) {
                // 随机选择入口位置（房间边缘）
                const entranceSide = Math.floor(Math.random() * 4);
                let entranceX, entranceY;
                
                switch (entranceSide) {
                    case 0: // 上边
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y;
                        break;
                    case 1: // 右边
                        entranceX = parentRoom.x + roomWidth - 1;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                    case 2: // 下边
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y + roomHeight - 1;
                        break;
                    case 3: // 左边
                        entranceX = parentRoom.x;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                }
                
                // 创建入口门
                if (entranceX >= 0 && entranceX < mapFloors[floor][0].length && 
                    entranceY >= 0 && entranceY < mapFloors[floor].length) {
                    if (mapFloors[floor][entranceY] && mapFloors[floor][entranceY][entranceX] !== undefined) {
                        mapFloors[floor][entranceY][entranceX] = TileType.DOOR;
                    }
                }
            }
            
            // 根据密度调整内部门数量
            const internalDoorCount = Math.min(5, Math.max(1, density + 1));
            for (let i = 0; i < internalDoorCount; i++) {
                createRandomInternalDoor(parentRoom, floor, density);
            }
            
            console.log(`迷宫入口数量: ${entranceCount}, 内部门数量: ${internalDoorCount}, 密度: ${density}`);
        }
        
        // 创建随机内部门
        function createRandomInternalDoor(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2;
            const roomHeight = parentRoom.height - 2;
            
            let attempts = 0;
            const maxAttempts = 30; // 增加尝试次数
            
            while (attempts < maxAttempts) {
                const x = parentRoom.x + 1 + Math.floor(Math.random() * roomWidth);
                const y = parentRoom.y + 1 + Math.floor(Math.random() * roomHeight);
                
                if (x >= 0 && x < mapFloors[floor][0].length && 
                    y >= 0 && y < mapFloors[floor].length) {
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        if (mapFloors[floor][y][x] === TileType.WALL) {
                            // 根据密度决定是否创建门（密度越高，越容易创建门）
                            const doorChance = 0.3 + (density * 0.15); // 30% + 密度*15%
                            if (Math.random() < doorChance) {
                                mapFloors[floor][y][x] = TileType.DOOR;
                                return;
                            }
                        }
                    }
                }
                attempts++;
            }
        }
        
        // 添加暗道
        function addUnderpass(rooms, density) {
            if (!rooms || rooms.length === 0) return;
            
            const densityMultiplier = [0, 0.5, 1.0, 1.8, 3.0][density];
            const totalFloors = mapFloors.length;
            
            // 为每层生成暗道
            for (let floor = 0; floor < totalFloors; floor++) {
                const floorRooms = rooms.filter(room => room.floor === floor);
                if (floorRooms.length < 2) continue; // 至少需要2个房间才能连接
                
                const mapSize = mapFloors[floor].length;
                const underpassCount = Math.max(1, Math.floor(floorRooms.length * densityMultiplier / 2));
                
                console.log(`楼层${floor}暗道密度: ${density}, 倍数: ${densityMultiplier}, 目标数量: ${underpassCount}`);
                
                let createdCount = 0;
                let attempts = 0;
                const maxAttempts = underpassCount * 5;
                
                // 获取可连接的房间对
                const connectableRoomPairs = findConnectableRoomPairs(floorRooms, floor);
                
                while (createdCount < underpassCount && attempts < maxAttempts && connectableRoomPairs.length > 0) {
                    attempts++;
                    
                    // 随机选择一对房间进行连接
                    const pairIndex = Math.floor(Math.random() * connectableRoomPairs.length);
                    const roomPair = connectableRoomPairs[pairIndex];
                    
                    if (createUnderpassBetweenRooms(roomPair.room1, roomPair.room2, floor)) {
                        createdCount++;
                        // 移除已连接的房间对，避免重复连接
                        connectableRoomPairs.splice(pairIndex, 1);
                    }
                }
                
                console.log(`楼层${floor}实际创建暗道数量: ${createdCount}`);
            }
        }
        
        // 找到可连接的房间对
        function findConnectableRoomPairs(rooms, floor) {
            const pairs = [];
            
            for (let i = 0; i < rooms.length; i++) {
                for (let j = i + 1; j < rooms.length; j++) {
                    const room1 = rooms[i];
                    const room2 = rooms[j];
                    
                    // 计算房间间距离
                    const distance = Math.sqrt(
                        Math.pow(room1.x + room1.width/2 - room2.x - room2.width/2, 2) +
                        Math.pow(room1.y + room1.height/2 - room2.y - room2.height/2, 2)
                    );
                    
                    // 只连接距离适中的房间（不太近也不太远）
                    if (distance > 8 && distance < 25) {
                        // 检查两个房间之间是否已经有直接通道连接
                        if (!hasDirectPath(room1, room2, floor)) {
                            pairs.push({
                                room1: room1,
                                room2: room2,
                                distance: distance
                            });
                        }
                    }
                }
            }
            
            // 按距离排序，优先连接距离适中的房间
            pairs.sort((a, b) => a.distance - b.distance);
            
            return pairs;
        }
        
        // 检查两个房间是否已有直接路径连接
        function hasDirectPath(room1, room2, floor) {
            // 简化检查：如果两个房间的边界相邻或接近，认为已有连接
            const room1Center = {x: room1.x + room1.width/2, y: room1.y + room1.height/2};
            const room2Center = {x: room2.x + room2.width/2, y: room2.y + room2.height/2};
            
            // 检查两个房间中心点之间的直线路径上是否都是可通行区域
            const dx = Math.abs(room2Center.x - room1Center.x);
            const dy = Math.abs(room2Center.y - room1Center.y);
            
            if (dx <= 3 && dy <= 3) {
                return true; // 房间很近，可能已经连接
            }
            
            return false;
        }
        
        // 在两个房间之间创建暗道
        function createUnderpassBetweenRooms(room1, room2, floor) {
            // 找到房间的最佳连接点
            const connection = findBestConnectionPoints(room1, room2, floor);
            if (!connection) return false;
            
            // 创建暗道路径
            const path = createUnderpassPath(connection.start, connection.end, floor);
            if (path.length === 0) return false;
            
            // 在路径上创建暗道
            for (const point of path) {
                if (point.x >= 0 && point.x < mapFloors[floor][0].length && 
                    point.y >= 0 && point.y < mapFloors[floor].length) {
                    const currentTile = mapFloors[floor][point.y][point.x];
                    
                    // 只在墙壁或空地中创建暗道
                    if (currentTile === TileType.WALL || currentTile === TileType.VOID) {
                        mapFloors[floor][point.y][point.x] = TileType.UNDERPASS;
                    }
                }
            }
            
            // 在两端创建与房间的连接点
            createRoomConnection(connection.start, room1, floor);
            createRoomConnection(connection.end, room2, floor);
            
            return true;
        }
        
        // 找到两个房间的最佳连接点
        function findBestConnectionPoints(room1, room2, floor) {
            const room1Center = {x: room1.x + room1.width/2, y: room1.y + room1.height/2};
            const room2Center = {x: room2.x + room2.width/2, y: room2.y + room2.height/2};
            
            // 找到房间边缘的连接点
            let bestStart = null;
            let bestEnd = null;
            let minDistance = Infinity;
            
            // 检查房间1的边缘点
            const room1Points = getRoomEdgePoints(room1);
            const room2Points = getRoomEdgePoints(room2);
            
            for (const p1 of room1Points) {
                for (const p2 of room2Points) {
                    const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestStart = p1;
                        bestEnd = p2;
                    }
                }
            }
            
            if (bestStart && bestEnd && minDistance > 5) { // 确保有足够距离创建暗道
                return {start: bestStart, end: bestEnd};
            }
            
            return null;
        }
        
        // 获取房间边缘点
        function getRoomEdgePoints(room) {
            const points = [];
            
            // 房间四个边的中点
            points.push({x: room.x + room.width/2, y: room.y}); // 上
            points.push({x: room.x + room.width/2, y: room.y + room.height}); // 下
            points.push({x: room.x, y: room.y + room.height/2}); // 左
            points.push({x: room.x + room.width, y: room.y + room.height/2}); // 右
            
            // 四个角点
            points.push({x: room.x, y: room.y}); // 左上
            points.push({x: room.x + room.width, y: room.y}); // 右上
            points.push({x: room.x, y: room.y + room.height}); // 左下
            points.push({x: room.x + room.width, y: room.y + room.height}); // 右下
            
            return points.map(p => ({x: Math.floor(p.x), y: Math.floor(p.y)}));
        }
        
        // 创建暗道路径
        function createUnderpassPath(start, end, floor) {
            const path = [];
            
            // 使用L形路径（先水平后垂直，或先垂直后水平）
            const useHorizontalFirst = Math.random() > 0.5;
            
            if (useHorizontalFirst) {
                // 先水平移动
                const startX = Math.min(start.x, end.x);
                const endX = Math.max(start.x, end.x);
                for (let x = startX; x <= endX; x++) {
                    path.push({x: x, y: start.y});
                }
                
                // 再垂直移动
                const startY = Math.min(start.y, end.y);
                const endY = Math.max(start.y, end.y);
                for (let y = startY; y <= endY; y++) {
                    path.push({x: end.x, y: y});
                }
            } else {
                // 先垂直移动
                const startY = Math.min(start.y, end.y);
                const endY = Math.max(start.y, end.y);
                for (let y = startY; y <= endY; y++) {
                    path.push({x: start.x, y: y});
                }
                
                // 再水平移动
                const startX = Math.min(start.x, end.x);
                const endX = Math.max(start.x, end.x);
                for (let x = startX; x <= endX; x++) {
                    path.push({x: x, y: end.y});
                }
            }
            
            return path;
        }
        
        // 创建暗道与房间的连接
        function createRoomConnection(connectionPoint, room, floor) {
            // 在连接点附近的房间内创建暗道入口
            const roomMinX = Math.max(0, room.x + 1);
            const roomMaxX = Math.min(mapFloors[floor][0].length - 1, room.x + room.width - 1);
            const roomMinY = Math.max(0, room.y + 1);
            const roomMaxY = Math.min(mapFloors[floor].length - 1, room.y + room.height - 1);
            
            // 找到最接近连接点的房间内位置
            let bestRoomPoint = null;
            let minDistance = Infinity;
            
            for (let y = roomMinY; y <= roomMaxY; y++) {
                for (let x = roomMinX; x <= roomMaxX; x++) {
                    const currentTile = mapFloors[floor][y][x];
                    if (currentTile === TileType.FLOOR || 
                        currentTile === TileType.MEDIUM_GROUND ||
                        currentTile === TileType.HIGH_GROUND ||
                        currentTile === TileType.LOW_GROUND) {
                        
                        const distance = Math.sqrt(
                            Math.pow(x - connectionPoint.x, 2) + 
                            Math.pow(y - connectionPoint.y, 2)
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestRoomPoint = {x: x, y: y};
                        }
                    }
                }
            }
            
            // 创建从暗道到房间的连接通道
            if (bestRoomPoint) {
                const dx = Math.abs(bestRoomPoint.x - connectionPoint.x);
                const dy = Math.abs(bestRoomPoint.y - connectionPoint.y);
                
                if (dx <= 2 && dy <= 2) {
                    // 直接连接
                    const connectX = Math.floor((bestRoomPoint.x + connectionPoint.x) / 2);
                    const connectY = Math.floor((bestRoomPoint.y + connectionPoint.y) / 2);
                    
                    if (connectX >= 0 && connectX < mapFloors[floor][0].length && 
                        connectY >= 0 && connectY < mapFloors[floor].length) {
                        mapFloors[floor][connectY][connectX] = TileType.UNDERPASS;
                    }
                }
            }
        }
        
        // 检查是否可以放置暗道
        function canPlaceUnderpass(x1, y1, x2, y2, floor) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            // 检查暗道路径上的每个位置
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (x < 0 || x >= mapFloors[floor][0].length || 
                        y < 0 || y >= mapFloors[floor].length) {
                        return false;
                    }
                    
                    const currentTile = mapFloors[floor][y][x];
                    // 只能在墙壁或空地中创建暗道
                    if (currentTile !== TileType.WALL && currentTile !== TileType.VOID) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // 创建暗道隧道
        function createUnderpassTunnel(x1, y1, x2, y2, floor) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            // 创建暗道通道
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (x >= 0 && x < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length) {
                        mapFloors[floor][y][x] = TileType.UNDERPASS;
                    }
                }
            }
            
            // 在暗道两端创建入口（连接到邻近的可通行区域）
            const endpoints = [
                {x: x1, y: y1},
                {x: x2, y: y2}
            ];
            
            for (const endpoint of endpoints) {
                createUnderpassEntrance(endpoint.x, endpoint.y, floor);
            }
        }
        
        // 创建暗道入口
        function createUnderpassEntrance(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length) {
                    
                    const neighborTile = mapFloors[floor][ny][nx];
                    
                    // 如果邻近位置是可通行区域，创建连接
                    if (neighborTile === TileType.FLOOR || 
                        neighborTile === TileType.MEDIUM_GROUND ||
                        neighborTile === TileType.HIGH_GROUND ||
                        neighborTile === TileType.LOW_GROUND) {
                        
                        // 在暗道和可通行区域之间创建连接点
                        const midX = Math.floor((x + nx) / 2);
                        const midY = Math.floor((y + ny) / 2);
                        
                        if (midX >= 0 && midX < mapFloors[floor][0].length && 
                            midY >= 0 && midY < mapFloors[floor].length) {
                            mapFloors[floor][midY][midX] = TileType.UNDERPASS;
                        }
                    }
                }
            }
        }
        
        // 添加狙击长道
        function addLongLanes(rooms, count) {
            if (!rooms || rooms.length === 0 || count <= 0) return;
            
            console.log(`开始生成${count}条狙击长道`);
            
            let createdLanes = 0;
            const maxAttempts = count * 10;
            let attempts = 0;
            
            // 为每层尝试生成长道
            for (let floor = 0; floor < totalFloors && createdLanes < count; floor++) {
                const floorRooms = rooms.filter(room => room.floor === floor);
                if (floorRooms.length < 2) continue;
                
                attempts = 0;
                while (createdLanes < count && attempts < maxAttempts) {
                    attempts++;
                    
                    // 随机选择长道方向：水平或垂直
                    const isHorizontal = Math.random() > 0.5;
                    
                    if (createLongLane(floor, isHorizontal)) {
                        createdLanes++;
                        console.log(`成功创建第${createdLanes}条长道 (楼层${floor}, ${isHorizontal ? '水平' : '垂直'})`);
                    }
                }
            }
            
            console.log(`总共创建了${createdLanes}条狙击长道`);
        }
        
        // 创建单条狙击长道
        function createLongLane(floor, isHorizontal) {
            if (!mapFloors[floor]) return false;
            
            const mapHeight = mapFloors[floor].length;
            const mapWidth = mapFloors[floor][0] ? mapFloors[floor][0].length : 0;
            
            if (mapWidth === 0 || mapHeight === 0) return false;
            
            const minLength = 15; // 最小长道长度
            const maxLength = Math.min(isHorizontal ? mapWidth - 10 : mapHeight - 10, 40); // 最大长度
            
            if (maxLength < minLength) return false;
            
            const length = minLength + Math.floor(Math.random() * (maxLength - minLength));
            const width = 3; // 长道宽度
            
            let startX, startY;
            
            if (isHorizontal) {
                // 水平长道
                startX = Math.floor(Math.random() * (mapWidth - length - 5)) + 3;
                startY = Math.floor(Math.random() * (mapHeight - width - 5)) + 3;
                
                // 检查区域是否可用
                if (!isAreaClearForLongLane(startX, startY, length, width, floor)) {
                    return false;
                }
                
                // 创建水平长道
                for (let x = startX; x < startX + length; x++) {
                    for (let y = startY; y < startY + width; y++) {
                        if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight && 
                            mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                            mapFloors[floor][y][x] = TileType.LONG_LANE;
                        }
                    }
                }
            } else {
                // 垂直长道
                startX = Math.floor(Math.random() * (mapWidth - width - 5)) + 3;
                startY = Math.floor(Math.random() * (mapHeight - length - 5)) + 3;
                
                // 检查区域是否可用
                if (!isAreaClearForLongLane(startX, startY, width, length, floor)) {
                    return false;
                }
                
                // 创建垂直长道
                for (let x = startX; x < startX + width; x++) {
                    for (let y = startY; y < startY + length; y++) {
                        if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight && 
                            mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                            mapFloors[floor][y][x] = TileType.LONG_LANE;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // 检查区域是否可以放置长道
        function isAreaClearForLongLane(startX, startY, width, height, floor) {
            if (!mapFloors[floor]) return false;
            
            const mapHeight = mapFloors[floor].length;
            const mapWidth = mapFloors[floor][0] ? mapFloors[floor][0].length : 0;
            
            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height; y++) {
                    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) {
                        return false;
                    }
                    
                    if (!mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                        return false;
                    }
                    
                    const currentTile = mapFloors[floor][y][x];
                    
                    // 只能在空地、墙壁或地板上建造长道
                    if (currentTile !== TileType.VOID && 
                        currentTile !== TileType.WALL && 
                        currentTile !== TileType.FLOOR &&
                        currentTile !== TileType.MEDIUM_GROUND) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        
        // 添加阴点（垂直小墙体）
        function addShadowPoints(density, floor = 0) {
            const mapSize = mapFloors[floor].length;
            const densityMultiplier = [0, 0.3, 0.8, 1.5, 2.5][density]; // 调整密度倍数，使默认值更明显
            const shadowPointCount = Math.max(1, Math.floor(mapSize * mapSize * densityMultiplier / 150)); // 增加基础数量
            
            console.log(`楼层${floor}阴点密度: ${density}, 倍数: ${densityMultiplier}, 目标数量: ${shadowPointCount}`);
            
            let createdCount = 0;
            for (let i = 0; i < shadowPointCount * 2; i++) { // 增加尝试次数
                // 随机选择位置
                let x, y;
                let attempts = 0;
                const maxAttempts = 30;
                
                do {
                    x = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    y = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    !isValidShadowPointPosition(x, y, floor)
                );
                
                if (attempts >= maxAttempts) continue;
                
                // 创建阴点（垂直小墙体）
                createShadowPoint(x, y, floor);
                createdCount++;
                
                if (createdCount >= shadowPointCount) break;
            }
            
            console.log(`楼层${floor}实际创建阴点数量: ${createdCount}`);
        }
        
        // 检查阴点位置是否有效
        function isValidShadowPointPosition(x, y, floor = 0) {
            // 检查边界和数组有效性
            if (x < 0 || x >= mapFloors[floor][0].length || 
                y < 0 || y >= mapFloors[floor].length ||
                !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                return false;
            }
            
            // 检查是否在地板或道路上
            if (mapFloors[floor][y][x] !== TileType.FLOOR &&
                mapFloors[floor][y][x] !== TileType.MEDIUM_GROUND &&
                mapFloors[floor][y][x] !== TileType.HIGH_GROUND &&
                mapFloors[floor][y][x] !== TileType.LOW_GROUND) {
                return false;
            }
            
            // 检查周围是否有足够的空间（放宽条件）
            let floorCount = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                            (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                             mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                            floorCount++;
                        }
                    }
                }
            }
            
            // 确保周围有足够的地板空间（降低要求）
            return floorCount >= 5;
        }
        
        // 创建单个阴点
        function createShadowPoint(x, y, floor = 0) {
            const mapSize = mapFloors[floor].length;
            
            // 随机决定阴点的方向（垂直或水平）
            const isVertical = Math.random() < 0.7; // 70%概率为垂直
            const length = Math.floor(Math.random() * 3) + 2; // 2-4格长度
            
            if (isVertical) {
                // 创建垂直阴点
                for (let i = 0; i < length; i++) {
                    const ny = y + i;
                    if (ny >= 0 && ny < mapSize && mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                        if (mapFloors[floor][ny][x] === TileType.FLOOR ||
                            mapFloors[floor][ny][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][ny][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][ny][x] === TileType.LOW_GROUND) {
                            mapFloors[floor][ny][x] = TileType.SHADOW_POINT;
                        }
                    }
                }
            } else {
                // 创建水平阴点
                for (let i = 0; i < length; i++) {
                    const nx = x + i;
                    if (nx >= 0 && nx < mapSize && mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                        if (mapFloors[floor][y][nx] === TileType.FLOOR ||
                            mapFloors[floor][y][nx] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][nx] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][nx] === TileType.LOW_GROUND) {
                            mapFloors[floor][y][nx] = TileType.SHADOW_POINT;
                        }
                    }
                }
            }
        }
        
        // 主题切换功能
        function toggleTheme() {
            const body = document.body;
            const themeToggle = document.querySelector('.theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');
            
            if (body.getAttribute('data-theme') === 'light') {
                // 切换到深色主题
                body.removeAttribute('data-theme');
                themeIcon.textContent = '🌙';
                themeText.textContent = '深色';
                localStorage.setItem('theme', 'dark');
            } else {
                // 切换到浅色主题
                body.setAttribute('data-theme', 'light');
                themeIcon.textContent = '☀️';
                themeText.textContent = '浅色';
                localStorage.setItem('theme', 'light');
            }
            
            // 重新绘制地图以适应新主题
            if (typeof drawMap === 'function') {
                if (overlayMode) {
                    drawOverlayMap();
                } else {
                    drawMap();
                }
            }
            
            // 更新3D场景背景色（如果3D预览正在运行）
            if (scene3D) {
                const isLightTheme = body.getAttribute('data-theme') === 'light';
                scene3D.background = new THREE.Color(isLightTheme ? 0xf5f5f5 : 0x0a0a0a);
            }
        }
        
        // 初始化主题
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeToggle = document.querySelector('.theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');
            
            if (savedTheme === 'light') {
                document.body.setAttribute('data-theme', 'light');
                themeIcon.textContent = '☀️';
                themeText.textContent = '浅色';
            } else {
                // 默认深色主题
                themeIcon.textContent = '🌙';
                themeText.textContent = '深色';
            }
        }
        
        // 初始化
        window.addEventListener('DOMContentLoaded', function() {
            // 初始化主题
            initializeTheme();
            
            document.getElementById('generateBtn').addEventListener('click', generateMap);
            document.getElementById('randomBtn').addEventListener('click', function() {
                randomizeParameters();
                generateMap();
            });
            document.getElementById('exportBtn').addEventListener('click', exportMap);
            document.getElementById('exportUCCBtn').addEventListener('click', exportUCC);
            
            // 种子系统事件监听器
            document.getElementById('saveSeedBtn').addEventListener('click', saveCurrentSeed);
            document.getElementById('clearSeedsBtn').addEventListener('click', clearAllSeeds);
            document.getElementById('seedsPanelCloseBtn').addEventListener('click', hideSeedsPanel);
            
            // 加载保存的种子
            loadSeedsFromStorage();
            renderSeedsList();
        });

        // ==================== 3D预览功能 ====================
        
        // 打开3D预览
        function open3DPreview() {
            if (!mapFloors.length) {
                alert('请先生成地图！');
                return;
            }
            
            // 检查Three.js是否加载
            if (typeof THREE === 'undefined') {
                alert('Three.js库未能正确加载，请刷新页面重试！');
                return;
            }
            
            const container = document.getElementById('preview3DContainer');
            container.style.display = 'block';
            preview3DActive = true;
            
            try {
                // 更新状态
                document.getElementById('debug3DStatus').textContent = '正在初始化场景...';
                document.getElementById('controlStatus').textContent = '🔧 正在加载控制器...';
                
                // 初始化3D场景
                init3DScene();
                render3DMap();
                
                // 更新成功状态
                document.getElementById('debug3DStatus').textContent = '场景加载完成';
                console.log('3D预览初始化成功');
            } catch (error) {
                console.error('3D预览初始化失败:', error);
                document.getElementById('debug3DStatus').textContent = '初始化失败: ' + error.message;
                alert('3D预览初始化失败: ' + error.message);
                close3DPreview();
            }
        }
        
        // 关闭3D预览
        function close3DPreview() {
            const container = document.getElementById('preview3DContainer');
            container.style.display = 'none';
            preview3DActive = false;
            
            // 清理3D资源
            if (renderer3D) {
                renderer3D.dispose();
                renderer3D = null;
            }
            if (scene3D) {
                // 清理场景中的所有对象
                while(scene3D.children.length > 0) {
                    const child = scene3D.children[0];
                    scene3D.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
                scene3D = null;
            }
            camera3D = null;
            controls3D = null;
        }
        
        // 初始化3D场景
        function init3DScene() {
            const canvas3D = document.getElementById('preview3DCanvas');
            canvas3D.innerHTML = ''; // 清空容器
            
            // 创建场景
            scene3D = new THREE.Scene();
            
            // 根据当前主题设置背景颜色
            const isLightTheme = document.body.getAttribute('data-theme') === 'light';
            scene3D.background = new THREE.Color(isLightTheme ? 0xf5f5f5 : 0x0a0a0a);
            
            // 创建相机
            const mapSize = mapFloors[0].length;
            camera3D = new THREE.PerspectiveCamera(
                75, 
                canvas3D.clientWidth / canvas3D.clientHeight, 
                0.1, 
                1000
            );
            
            // 设置相机位置 - 从斜上方观察
            const cameraDistance = mapSize * 1.5;
            camera3D.position.set(cameraDistance, cameraDistance * 0.8, cameraDistance);
            mapCenter.set(mapSize / 2, 0, mapSize / 2);
            camera3D.lookAt(mapCenter);
            
            // 创建渲染器
            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(canvas3D.clientWidth, canvas3D.clientHeight);
            renderer3D.shadowMap.enabled = true;
            renderer3D.shadowMap.type = THREE.PCFSoftShadowMap;
            canvas3D.appendChild(renderer3D.domElement);
            
            // 添加轨道控制器
            try {
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
                    controls3D.enableDamping = true;
                    controls3D.dampingFactor = 0.1;
                    controls3D.target.set(mapSize / 2, 0, mapSize / 2);
                    controls3D.maxDistance = mapSize * 5;
                    controls3D.minDistance = 5;
                    
                    // 双击重置视角
                    renderer3D.domElement.addEventListener('dblclick', () => {
                        camera3D.position.set(cameraDistance, cameraDistance * 0.8, cameraDistance);
                        controls3D.target.set(mapSize / 2, 0, mapSize / 2);
                        controls3D.update();
                    });
                    
                    console.log('OrbitControls加载成功');
                    document.getElementById('controlStatus').textContent = '✅ OrbitControls已就绪';
                } else {
                    console.warn('OrbitControls未加载，使用基础控制');
                    addBasicControls();
                    document.getElementById('controlStatus').textContent = '⚠️ 使用基础控制';
                }
            } catch (error) {
                console.error('OrbitControls初始化失败:', error);
                addBasicControls();
                document.getElementById('controlStatus').textContent = '⚠️ 使用基础控制';
            }
            
            // 添加光照
            add3DLighting();
            
            // 处理窗口大小变化
            const resizeHandler = () => {
                if (preview3DActive && renderer3D && camera3D) {
                    camera3D.aspect = canvas3D.clientWidth / canvas3D.clientHeight;
                    camera3D.updateProjectionMatrix();
                    renderer3D.setSize(canvas3D.clientWidth, canvas3D.clientHeight);
                }
            };
            window.addEventListener('resize', resizeHandler);
            
            // 添加键盘和预设视角支持
            addKeyboardControls();
            addPresetViewControls();
            addTouchControls();
            
            // 动画循环
            function animate() {
                if (preview3DActive && renderer3D && scene3D && camera3D) {
                    requestAnimationFrame(animate);
                    
                    // 更新相机动画
                    updateCameraAnimation();
                    
                    // 更新帧率计数
                    updateFPSCounter();
                    
                    if (controls3D && controls3D.update) {
                        controls3D.update();
                    }
                    renderer3D.render(scene3D, camera3D);
                }
            }
            animate();
        }
        
        // 添加基础控制（OrbitControls的备用方案）
        function addBasicControls() {
            const canvas = renderer3D.domElement;
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            // 鼠标控制变量
            let rotationSpeed = 0.01;
            let zoomSpeed = 0.1;
            
            // 鼠标按下
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            // 鼠标移动
            canvas.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                // 旋转相机
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera3D.position);
                
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi += deltaY * rotationSpeed;
                
                // 限制垂直旋转角度
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera3D.position.setFromSpherical(spherical);
                camera3D.lookAt(mapFloors[0].length / 2, 0, mapFloors[0].length / 2);
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            // 鼠标抬起
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // 滚轮缩放
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                
                const direction = event.deltaY > 0 ? 1 : -1;
                const distance = camera3D.position.length();
                const newDistance = Math.max(5, Math.min(mapFloors[0].length * 5, distance + direction * zoomSpeed * distance));
                
                camera3D.position.normalize().multiplyScalar(newDistance);
            });
            
            // 双击重置
            canvas.addEventListener('dblclick', () => {
                const mapSize = mapFloors[0].length;
                const cameraDistance = mapSize * 1.5;
                camera3D.position.set(cameraDistance, cameraDistance * 0.8, cameraDistance);
                camera3D.lookAt(mapSize / 2, 0, mapSize / 2);
            });
        }
        
        // ==================== 增强控制功能 ====================
        
        // 添加键盘控制
        function addKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                if (!preview3DActive) return;
                
                const moveSpeed = 5;
                const rotateSpeed = 0.1;
                
                switch(event.code) {
                    case 'KeyR':
                        animateToView('perspective');
                        break;
                    case 'KeyF':
                        focusOnMap();
                        break;
                    case 'Digit1':
                        animateToView('top');
                        break;
                    case 'Digit2':
                        animateToView('isometric');
                        break;
                    case 'Digit3':
                        animateToView('perspective');
                        break;
                    case 'Digit4':
                        animateToView('walk');
                        break;
                    case 'Equal':
                    case 'NumpadAdd':
                        zoomCamera(-0.1);
                        break;
                    case 'Minus':
                    case 'NumpadSubtract':
                        zoomCamera(0.1);
                        break;
                    case 'ArrowUp':
                        moveCamera(0, 0, -moveSpeed);
                        break;
                    case 'ArrowDown':
                        moveCamera(0, 0, moveSpeed);
                        break;
                    case 'ArrowLeft':
                        moveCamera(-moveSpeed, 0, 0);
                        break;
                    case 'ArrowRight':
                        moveCamera(moveSpeed, 0, 0);
                        break;
                    case 'Escape':
                        close3DPreview();
                        break;
                }
                
                event.preventDefault();
            });
        }
        
        // 添加预设视角控制
        function addPresetViewControls() {
            document.getElementById('topViewBtn').addEventListener('click', () => animateToView('top'));
            document.getElementById('isometricViewBtn').addEventListener('click', () => animateToView('isometric'));
            document.getElementById('perspectiveViewBtn').addEventListener('click', () => animateToView('perspective'));
            document.getElementById('walkViewBtn').addEventListener('click', () => animateToView('walk'));
        }
        
        // 添加触摸控制
        function addTouchControls() {
            const canvas = renderer3D.domElement;
            
            // 触摸开始
            canvas.addEventListener('touchstart', (event) => {
                event.preventDefault();
                touches = {};
                
                for (let i = 0; i < event.touches.length; i++) {
                    const touch = event.touches[i];
                    touches[touch.identifier] = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                }
                
                // 双指触摸
                if (event.touches.length === 2) {
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    
                    touchStartDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    
                    touchStartCenter = {
                        x: (touch1.clientX + touch2.clientX) / 2,
                        y: (touch1.clientY + touch2.clientY) / 2
                    };
                }
            });
            
            // 触摸移动
            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    // 单指旋转
                    const touch = event.touches[0];
                    const prevTouch = touches[touch.identifier];
                    
                    if (prevTouch) {
                        const deltaX = touch.clientX - prevTouch.x;
                        const deltaY = touch.clientY - prevTouch.y;
                        
                        rotateCamera(deltaX * 0.01, deltaY * 0.01);
                        
                        touches[touch.identifier] = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                    }
                } else if (event.touches.length === 2) {
                    // 双指缩放和平移
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    
                    const currentCenter = {
                        x: (touch1.clientX + touch2.clientX) / 2,
                        y: (touch1.clientY + touch2.clientY) / 2
                    };
                    
                    // 缩放
                    if (touchStartDistance > 0) {
                        const scale = currentDistance / touchStartDistance;
                        const zoomDelta = (1 - scale) * 0.5;
                        zoomCamera(zoomDelta);
                    }
                    
                    // 平移
                    const panDeltaX = currentCenter.x - touchStartCenter.x;
                    const panDeltaY = currentCenter.y - touchStartCenter.y;
                    panCamera(panDeltaX * 0.01, panDeltaY * 0.01);
                    
                    touchStartDistance = currentDistance;
                    touchStartCenter = currentCenter;
                }
            });
            
            // 触摸结束
            canvas.addEventListener('touchend', (event) => {
                event.preventDefault();
                
                // 清理结束的触摸点
                for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    delete touches[touch.identifier];
                }
            });
        }
        
        // 动画到指定视角
        function animateToView(viewType) {
            if (!mapFloors.length || cameraAnimating) return;
            
            const mapSize = mapFloors[0].length;
            const distance = mapSize * 1.5;
            let newPosition = new THREE.Vector3();
            let newLookAt = mapCenter.clone();
            
            // 更新预设视角按钮状态
            document.querySelectorAll('.preset-view-btn').forEach(btn => btn.classList.remove('active'));
            
            switch(viewType) {
                case 'top':
                    newPosition.set(mapSize / 2, distance, mapSize / 2);
                    document.getElementById('topViewBtn').classList.add('active');
                    break;
                case 'isometric':
                    newPosition.set(distance, distance * 0.6, distance);
                    document.getElementById('isometricViewBtn').classList.add('active');
                    break;
                case 'perspective':
                    newPosition.set(distance, distance * 0.8, distance);
                    document.getElementById('perspectiveViewBtn').classList.add('active');
                    break;
                case 'walk':
                    newPosition.set(mapSize / 2, 3, mapSize / 4);
                    newLookAt.set(mapSize / 2, 0, mapSize * 0.75);
                    document.getElementById('walkViewBtn').classList.add('active');
                    break;
            }
            
            currentPresetView = viewType;
            smoothCameraTransition(newPosition, newLookAt);
        }
        
        // 平滑相机过渡
        function smoothCameraTransition(targetPos, targetLook, duration = 1000) {
            if (cameraAnimating) return;
            
            cameraAnimating = true;
            const startPos = camera3D.position.clone();
            const startLook = new THREE.Vector3();
            camera3D.getWorldDirection(startLook);
            startLook.add(camera3D.position);
            
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 使用缓动函数
                const easeProgress = easeInOutCubic(progress);
                
                // 插值位置
                camera3D.position.lerpVectors(startPos, targetPos, easeProgress);
                
                // 插值朝向
                const currentLook = new THREE.Vector3();
                currentLook.lerpVectors(startLook, targetLook, easeProgress);
                camera3D.lookAt(currentLook);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    cameraAnimating = false;
                }
            }
            
            animateCamera();
        }
        
        // 缓动函数
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        }
        
        // 聚焦到地图中心
        function focusOnMap() {
            smoothCameraTransition(camera3D.position, mapCenter);
        }
        
        // 缩放相机
        function zoomCamera(delta) {
            const direction = camera3D.position.clone().sub(mapCenter).normalize();
            const distance = camera3D.position.distanceTo(mapCenter);
            const newDistance = Math.max(5, Math.min(mapFloors[0].length * 5, distance + delta * distance));
            
            const newPosition = mapCenter.clone().add(direction.multiplyScalar(newDistance));
            camera3D.position.copy(newPosition);
        }
        
        // 移动相机
        function moveCamera(deltaX, deltaY, deltaZ) {
            const moveVector = new THREE.Vector3(deltaX, deltaY, deltaZ);
            camera3D.position.add(moveVector);
            mapCenter.add(moveVector);
        }
        
        // 旋转相机
        function rotateCamera(deltaX, deltaY) {
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(camera3D.position.clone().sub(mapCenter));
            
            spherical.theta -= deltaX;
            spherical.phi += deltaY;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
            
            camera3D.position.setFromSpherical(spherical).add(mapCenter);
            camera3D.lookAt(mapCenter);
        }
        
        // 平移相机
        function panCamera(deltaX, deltaY) {
            const panVector = new THREE.Vector3();
            camera3D.getWorldDirection(panVector);
            
            const right = new THREE.Vector3();
            right.crossVectors(panVector, camera3D.up).normalize();
            
            const up = new THREE.Vector3();
            up.crossVectors(right, panVector).normalize();
            
            const moveVector = new THREE.Vector3();
            moveVector.addScaledVector(right, -deltaX);
            moveVector.addScaledVector(up, deltaY);
            
            camera3D.position.add(moveVector);
            mapCenter.add(moveVector);
        }
        
        // 更新相机动画
        function updateCameraAnimation() {
            // 这里可以添加更多相机动画逻辑
        }
        
        // 更新帧率计数器
        function updateFPSCounter() {
            frameCount++;
            const now = Date.now();
            
            if (now - lastFPSUpdate >= 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastFPSUpdate));
                document.getElementById('fpsCounter').textContent = fps + ' FPS';
                frameCount = 0;
                lastFPSUpdate = now;
            }
        }
        
        // 添加3D光照
        function add3DLighting() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene3D.add(ambientLight);
            
            // 主要方向光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene3D.add(directionalLight);
            
            // 辅助光源
            const pointLight = new THREE.PointLight(0x6699ff, 0.3, 100);
            pointLight.position.set(-20, 30, 20);
            scene3D.add(pointLight);
        }
        
        // 渲染3D地图（优化版本 - 合并相邻方块）
        function render3DMap() {
            if (!scene3D || !mapFloors.length) return;
            
            const floorHeight = 4; // 每层的高度
            
            // 为每层创建优化的3D几何体
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const yOffset = floor * floorHeight;
                
                // 创建合并的几何体
                createMergedGeometry(currentMap, yOffset, floor);
            }
            
            // 计算性能统计
            const objectCount = scene3D.children.length;
            let totalTriangles = 0;
            
            scene3D.children.forEach(child => {
                if (child.geometry) {
                    const geometry = child.geometry;
                    if (geometry.index) {
                        totalTriangles += geometry.index.count / 3;
                    } else if (geometry.attributes.position) {
                        totalTriangles += geometry.attributes.position.count / 3;
                    }
                }
            });
            
            const perfMessage = `3D渲染完成 - 对象: ${objectCount}, 三角形: ${Math.floor(totalTriangles)}`;
            console.log(perfMessage);
            
            // 更新状态显示
            document.getElementById('debug3DStatus').textContent = 
                `已渲染 ${objectCount} 个对象，${Math.floor(totalTriangles)} 个三角形`;
        }
        
        // 创建合并几何体（性能优化的核心）
        function createMergedGeometry(mapData, yOffset, floor) {
            // 按材质类型分组瓦片
            const tileGroups = groupTilesByType(mapData, floor);
            
            // 为每种瓦片类型创建合并的几何体
            Object.keys(tileGroups).forEach(tileType => {
                const tiles = tileGroups[tileType];
                if (tiles.length === 0) return;
                
                const mergedMesh = createMergedMesh(tiles, parseInt(tileType), yOffset, floor);
                if (mergedMesh) {
                    scene3D.add(mergedMesh);
                }
            });
        }
        
        // 按瓦片类型分组
        function groupTilesByType(mapData, floor) {
            const groups = {};
            
            for (let z = 0; z < mapData.length; z++) {
                for (let x = 0; x < mapData[0].length; x++) {
                    const tileType = mapData[z][x];
                    
                    if (tileType !== TileType.VOID) {
                        if (!groups[tileType]) {
                            groups[tileType] = [];
                        }
                        groups[tileType].push({ x, z });
                    }
                }
            }
            
            return groups;
        }
        
        // 创建合并网格
        function createMergedMesh(tiles, tileType, yOffset, floor) {
            const { geometry: baseGeometry, material } = get3DTileProperties(tileType, floor);
            if (!baseGeometry || !material) return null;
            
            // 对于可以平铺合并的类型（地板、墙壁等），使用区域合并
            if (canMergeTiles(tileType)) {
                return createMergedPlanarMesh(tiles, tileType, yOffset, floor, material);
            } else {
                // 对于特殊形状的瓦片，使用实例化几何体
                return createInstancedMesh(tiles, baseGeometry, material, yOffset);
            }
        }
        
        // 判断瓦片是否可以平铺合并
        function canMergeTiles(tileType) {
            const mergableTiles = [
                TileType.FLOOR, 
                TileType.MEDIUM_GROUND,
                TileType.HIGH_GROUND,
                TileType.LOW_GROUND,
                TileType.ELEVATED,
                TileType.LOWERED,
                TileType.WATER,
                TileType.BOMBSITE_A,
                TileType.BOMBSITE_B,
                TileType.T_SPAWN,
                TileType.CT_SPAWN,
                TileType.WALL  // 墙壁也支持合并
            ];
            return mergableTiles.includes(tileType);
        }
        
        // 创建平铺合并网格（用于地板、包点、墙壁等）
        function createMergedPlanarMesh(tiles, tileType, yOffset, floor, material) {
            if (tiles.length === 0) return null;
            
            // 找到连续的矩形区域
            const rectangles = findRectangularRegions(tiles);
            
            const mergedGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            
            let vertexIndex = 0;
            
            rectangles.forEach(rect => {
                const { x, z, width, height } = rect;
                const { height: tileHeight } = getTileProperties(tileType);
                const isWall = tileType === TileType.WALL;
                
                if (isWall) {
                    // 为墙壁创建完整的立方体
                    vertexIndex = addBoxGeometry(vertices, normals, uvs, indices, 
                        x, yOffset, z, width, tileHeight, height, vertexIndex);
                } else {
                    // 为其他瓦片创建平面
                    vertexIndex = addPlaneGeometry(vertices, normals, uvs, indices,
                        x, yOffset, z, width, tileHeight, height, vertexIndex);
                }
            });
            
            mergedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            mergedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            mergedGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            mergedGeometry.setIndex(indices);
            
            const mesh = new THREE.Mesh(mergedGeometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            return mesh;
        }
        
        // 添加立方体几何体（用于墙壁）
        function addBoxGeometry(vertices, normals, uvs, indices, x, y, z, width, height, depth, startVertexIndex) {
            const faces = [
                // 前面
                [[x, y, z + depth], [x + width, y, z + depth], [x + width, y + height, z + depth], [x, y + height, z + depth]],
                // 后面  
                [[x + width, y, z], [x, y, z], [x, y + height, z], [x + width, y + height, z]],
                // 右面
                [[x + width, y, z + depth], [x + width, y, z], [x + width, y + height, z], [x + width, y + height, z + depth]],
                // 左面
                [[x, y, z], [x, y, z + depth], [x, y + height, z + depth], [x, y + height, z]],
                // 顶面
                [[x, y + height, z + depth], [x + width, y + height, z + depth], [x + width, y + height, z], [x, y + height, z]],
                // 底面
                [[x, y, z], [x + width, y, z], [x + width, y, z + depth], [x, y, z + depth]]
            ];
            
            const faceNormals = [
                [0, 0, 1],   // 前面
                [0, 0, -1],  // 后面
                [1, 0, 0],   // 右面
                [-1, 0, 0],  // 左面
                [0, 1, 0],   // 顶面
                [0, -1, 0]   // 底面
            ];
            
            faces.forEach((face, faceIndex) => {
                const startVertex = startVertexIndex;
                
                // 添加面的顶点
                face.forEach(vertex => {
                    vertices.push(...vertex);
                    normals.push(...faceNormals[faceIndex]);
                    uvs.push(0, 0); // 简化UV
                });
                
                // 添加面的索引（两个三角形）
                indices.push(
                    startVertex, startVertex + 1, startVertex + 2,
                    startVertex, startVertex + 2, startVertex + 3
                );
                
                startVertexIndex += 4;
            });
            
            return startVertexIndex;
        }
        
        // 添加平面几何体（用于地板等）
        function addPlaneGeometry(vertices, normals, uvs, indices, x, y, z, width, height, depth, startVertexIndex) {
            // 底面顶点
            vertices.push(
                x, y, z,
                x + width, y, z,
                x + width, y, z + depth,
                x, y, z + depth
            );
            
            // 顶面顶点  
            vertices.push(
                x, y + height, z,
                x + width, y + height, z,
                x + width, y + height, z + depth,
                x, y + height, z + depth
            );
            
            // 法线
            for (let i = 0; i < 4; i++) {
                normals.push(0, -1, 0); // 底面
            }
            for (let i = 0; i < 4; i++) {
                normals.push(0, 1, 0); // 顶面
            }
            
            // UV坐标
            uvs.push(0, 0, width, 0, width, depth, 0, depth);
            uvs.push(0, 0, width, 0, width, depth, 0, depth);
            
            // 索引
            // 底面
            indices.push(
                startVertexIndex, startVertexIndex + 1, startVertexIndex + 2,
                startVertexIndex, startVertexIndex + 2, startVertexIndex + 3
            );
            // 顶面
            indices.push(
                startVertexIndex + 4, startVertexIndex + 6, startVertexIndex + 5,
                startVertexIndex + 4, startVertexIndex + 7, startVertexIndex + 6
            );
            
            return startVertexIndex + 8;
        }
        
        // 查找矩形区域（贪心算法合并相邻瓦片）
        function findRectangularRegions(tiles) {
            const rectangles = [];
            const used = new Set();
            
            // 创建位置查找表
            const positionMap = new Map();
            tiles.forEach(tile => {
                positionMap.set(`${tile.x},${tile.z}`, tile);
            });
            
            tiles.forEach(tile => {
                const key = `${tile.x},${tile.z}`;
                if (used.has(key)) return;
                
                // 找到以当前瓦片为起点的最大矩形
                const rect = findMaxRectangle(tile, positionMap, used);
                if (rect) {
                    rectangles.push(rect);
                }
            });
            
            return rectangles;
        }
        
        // 查找最大矩形（从给定起点开始）
        function findMaxRectangle(startTile, positionMap, used) {
            let maxWidth = 1;
            let maxHeight = 1;
            
            // 向右扩展找最大宽度
            while (positionMap.has(`${startTile.x + maxWidth},${startTile.z}`) && 
                   !used.has(`${startTile.x + maxWidth},${startTile.z}`)) {
                maxWidth++;
            }
            
            // 向下扩展，检查每一行是否能保持相同宽度
            let canExpand = true;
            while (canExpand) {
                for (let x = 0; x < maxWidth; x++) {
                    const checkKey = `${startTile.x + x},${startTile.z + maxHeight}`;
                    if (!positionMap.has(checkKey) || used.has(checkKey)) {
                        canExpand = false;
                        break;
                    }
                }
                if (canExpand) {
                    maxHeight++;
                }
            }
            
            // 标记所有使用的瓦片
            for (let x = 0; x < maxWidth; x++) {
                for (let z = 0; z < maxHeight; z++) {
                    used.add(`${startTile.x + x},${startTile.z + z}`);
                }
            }
            
            return {
                x: startTile.x,
                z: startTile.z,
                width: maxWidth,
                height: maxHeight
            };
        }
        
        // 创建实例化网格（用于掩体、楼梯等特殊形状）
        function createInstancedMesh(tiles, baseGeometry, material, yOffset) {
            if (tiles.length === 0) return null;
            
            const instancedMesh = new THREE.InstancedMesh(baseGeometry, material, tiles.length);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            
            const matrix = new THREE.Matrix4();
            
            tiles.forEach((tile, index) => {
                matrix.setPosition(tile.x, yOffset, tile.z);
                instancedMesh.setMatrixAt(index, matrix);
            });
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            
            return instancedMesh;
        }
        
        // 获取瓦片属性
        function getTileProperties(tileType) {
            switch(tileType) {
                case TileType.FLOOR:
                case TileType.MEDIUM_GROUND:
                    return { height: 0.1 };
                case TileType.WALL:
                    return { height: 3 };
                case TileType.HIGH_GROUND:
                case TileType.ELEVATED:
                    return { height: 1.5 };
                case TileType.LOW_GROUND:
                case TileType.LOWERED:
                    return { height: 0.05 };
                case TileType.WATER:
                    return { height: 0.3 };
                case TileType.BOMBSITE_A:
                case TileType.BOMBSITE_B:
                case TileType.T_SPAWN:
                case TileType.CT_SPAWN:
                    return { height: 0.2 };
                default:
                    return { height: 0.1 };
            }
        }
        
        // 创建3D瓦片
        function create3DTile(tileType, x, y, z, floor) {
            const { geometry, material } = get3DTileProperties(tileType, floor);
            
            if (!geometry || !material) return null;
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            return mesh;
        }
        
        // 获取3D瓦片的几何体和材质
        function get3DTileProperties(tileType, floor) {
            let geometry, material;
            
            switch(tileType) {
                case TileType.FLOOR:
                case TileType.MEDIUM_GROUND:
                    geometry = new THREE.BoxGeometry(1, 0.1, 1);
                    material = new THREE.MeshLambertMaterial({ 
                        color: floor === 0 ? 0x4a4a4a : floor === 1 ? 0x5a5a5a : 0x6a6a6a 
                    });
                    break;
                    
                case TileType.WALL:
                    geometry = new THREE.BoxGeometry(1, 3, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0xb0b0b0 });
                    break;
                    
                case TileType.HIGH_GROUND:
                case TileType.ELEVATED:
                    geometry = new THREE.BoxGeometry(1, 1.5, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x6a6a4a });
                    break;
                    
                case TileType.LOW_GROUND:
                case TileType.LOWERED:
                    geometry = new THREE.BoxGeometry(1, 0.05, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x2a2a4a });
                    break;
                    
                case TileType.COVER:
                    geometry = new THREE.BoxGeometry(0.8, 1.2, 0.8);
                    material = new THREE.MeshLambertMaterial({ color: 0x303030 });
                    break;
                    
                case TileType.WATER:
                    geometry = new THREE.BoxGeometry(1, 0.3, 1);
                    material = new THREE.MeshLambertMaterial({ 
                        color: 0x2a4d69, 
                        transparent: true, 
                        opacity: 0.7 
                    });
                    break;
                    
                case TileType.STAIRS_UP:
                    geometry = new THREE.BoxGeometry(1, 0.8, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
                    break;
                    
                case TileType.STAIRS_DOWN:
                    geometry = new THREE.BoxGeometry(1, 0.6, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x6B5345 });
                    break;
                    
                case TileType.WINDOW:
                    geometry = new THREE.BoxGeometry(1, 2, 0.1);
                    material = new THREE.MeshLambertMaterial({ 
                        color: 0x6a8caf, 
                        transparent: true, 
                        opacity: 0.6 
                    });
                    break;
                    
                case TileType.BOMBSITE_A:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x5a5a00 });
                    break;
                    
                case TileType.BOMBSITE_B:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x5a3a00 });
                    break;
                    
                case TileType.T_SPAWN:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x3a2020 });
                    break;
                    
                case TileType.CT_SPAWN:
                    geometry = new THREE.BoxGeometry(1, 0.2, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x203a20 });
                    break;
                    
                case TileType.DOOR:
                    geometry = new THREE.BoxGeometry(1, 2.5, 0.2);
                    material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    break;
                    
                default:
                    geometry = new THREE.BoxGeometry(1, 0.1, 1);
                    material = new THREE.MeshLambertMaterial({ color: 0x404040 });
                    break;
            }
            
            return { geometry, material };
        }

        // 检查3D支持
        function check3DSupport() {
            const results = [];
            
            // 检查Three.js
            if (typeof THREE !== 'undefined') {
                results.push('✅ Three.js已加载');
            } else {
                results.push('❌ Three.js未加载');
            }
            
            // 检查WebGL支持
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    results.push('✅ WebGL支持');
                } else {
                    results.push('❌ WebGL不支持');
                }
            } catch (e) {
                results.push('❌ WebGL检查失败');
            }
            
            // 检查OrbitControls
            setTimeout(() => {
                if (typeof THREE !== 'undefined' && THREE.OrbitControls) {
                    results.push('✅ OrbitControls已加载');
                } else {
                    results.push('⚠️ OrbitControls未加载（将使用基础控制）');
                }
                console.log('3D支持检查结果:', results.join(', '));
            }, 1000);
            
            return results;
        }

        // 当DOM加载完成时，初始化所有事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            
            // 检查3D支持
            check3DSupport();
            
            // 3D预览按钮事件
            document.getElementById('preview3DBtn').addEventListener('click', open3DPreview);
            document.getElementById('close3DBtn').addEventListener('click', close3DPreview);
            
            // 生成初始地图
            generateMap();
        });
    </script>

    <!-- UCC导出使用说明弹窗 -->
    <div id="uccTutorialModal" class="ucc-tutorial-modal" style="display: none;">
        <div class="ucc-tutorial-modal-content">
            <div class="ucc-tutorial-modal-header">
                <h2>🎮 UCC导出使用说明</h2>
                <button class="ucc-tutorial-close" onclick="closeUccTutorial()">&times;</button>
            </div>
            <div class="ucc-tutorial-modal-body">
                <div class="ucc-tutorial-step">
                    <div class="ucc-tutorial-step-number">1</div>
                    <div class="ucc-tutorial-step-content">
                        <h3>创建UCC模板文件</h3>
                        <p>首先在游戏中创建一个UCC文件，命名为 <strong>mf5.ucc</strong></p>
                        <p>在文件中放置约 <strong>4000个方块</strong> 作为模板</p>
                    </div>
                </div>
                <div class="ucc-tutorial-step">
                    <div class="ucc-tutorial-step-number">2</div>
                    <div class="ucc-tutorial-step-content">
                        <h3>选择模板文件</h3>
                        <p>在网页中点击"导出UCC"按钮</p>
                        <p>系统会自动弹出文件选择对话框</p>
                        <p>选择您创建的 <strong>mf5.ucc</strong> 文件</p>
                    </div>
                </div>
                <div class="ucc-tutorial-step">
                    <div class="ucc-tutorial-step-number">3</div>
                    <div class="ucc-tutorial-step-content">
                        <h3>导出地图</h3>
                        <p>选择模板文件后，系统会自动处理地图数据</p>
                        <p>生成包含您地图的UCC文件并自动下载</p>
                    </div>
                </div>
                <div class="ucc-tutorial-tips">
                    <h4>💡 提示</h4>
                    <ul>
                        <li>模板文件只需要导入一次，后续导出会重复使用</li>
                        <li>确保模板文件包含足够的方块数量（约4000个）</li>
                        <li>导出的UCC文件可以直接在游戏中使用</li>
                    </ul>
                </div>
            </div>
            <div class="ucc-tutorial-modal-footer">
                <button class="btn btn--primary" onclick="closeUccTutorial()">我知道了</button>
                <button class="btn btn--secondary" onclick="closeUccTutorial(true)">不再显示</button>
            </div>
        </div>
    </div>
</body>
</html>
