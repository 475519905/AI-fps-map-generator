<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CFÈ£éÊ†ºÂ§öÂ±ÇÁ´ûÊäÄÂú∞ÂõæÁîüÊàêÂô®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            max-width: 1600px;
            width: 100%;
            border: 1px solid #333;
        }

        h1 {
            text-align: center;
            color: #f0f0f0;
            margin-bottom: 10px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 25px;
            font-size: 1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: bold;
            color: #999;
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
            background: #1a1a1a;
            color: #ccc;
            font-size: 13px;
            cursor: pointer;
        }

        select:hover {
            border-color: #4CAF50;
        }

        .value-display {
            color: #4CAF50;
            font-weight: bold;
            margin-left: 5px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex: 1;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-1px);
        }

        .export-btn {
            background: #2196F3;
        }

        .export-btn:hover {
            background: #1976D2;
        }

        .floor-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #333;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .overlay-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            margin-left: 20px;
        }
        
        .overlay-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .overlay-btn.active {
            background: linear-gradient(135deg, #764ba2, #667eea);
            border-color: #8a5ec7;
        }

        .floor-btn {
            padding: 10px 20px;
            background: #333;
            color: #999;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            min-width: 80px;
        }

        .floor-btn:hover {
            background: #444;
            color: #ccc;
        }

        .floor-btn.active {
            background: #4CAF50;
            color: white;
            border-color: #5CBF60;
        }

        #canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #333;
            border-radius: 4px;
            background: #000;
        }

        .map-header {
            background: linear-gradient(to right, #2c5f2d, #1a3d1a);
            color: white;
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .map-name {
            font-weight: bold;
            font-size: 16px;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 0.85em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #444;
            border-radius: 2px;
        }
        
        /* ÁßçÂ≠êÈù¢ÊùøÊ†∑Âºè */
        .seeds-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            width: 300px;
            background: #2a2a2a;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 15px;
            color: white;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .seeds-panel h3 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            text-align: center;
            font-size: 18px;
        }
        
        .seed-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .seed-controls button {
            flex: 1;
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .seed-controls button:hover {
            background: #45a049;
        }
        
        .seeds-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .seed-item {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .seed-item:hover {
            background: #4a4a4a;
            border-color: #4CAF50;
        }
        
        .seed-item.selected {
            background: #4CAF50;
            border-color: #45a049;
        }
        
        .seed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .seed-name {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .seed-date {
            font-size: 11px;
            color: #888;
        }
        
        .seed-params {
            font-size: 11px;
            color: #ccc;
            line-height: 1.3;
        }
        
        .seed-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
        .seed-actions button {
            padding: 4px 8px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: background 0.3s;
        }
        
        .seed-actions button:hover {
            background: #666;
        }
        
        .seed-actions button.delete {
            background: #d32f2f;
        }
        
        .seed-actions button.delete:hover {
            background: #b71c1c;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ CFÈ£éÊ†ºÂ§öÂ±ÇÁ´ûÊäÄÂú∞ÂõæÁîüÊàêÂô®</h1>
        <div class="subtitle">ÁîüÊàêÂ§öÂ±ÇÁàÜÁ†¥Ê®°ÂºèÁ´ûÊäÄÂú∞Âõæ</div>
        
        <div class="controls">
            <div class="control-group">
                <label>Âú∞ÂõæÂ∞∫ÂØ∏: <span class="value-display" id="sizeValue">60</span></label>
                <input type="range" id="mapSize" min="40" max="800" value="60" step="10">
            </div>
            
            <div class="control-group">
                <label>Âú∞ÂõæÂ±ÇÊï∞: <span class="value-display" id="floorsValue">2</span></label>
                <input type="range" id="floorCount" min="1" max="10" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ÊàøÈó¥Êï∞Èáè: <span class="value-display" id="roomValue">6</span></label>
                <input type="range" id="roomCount" min="3" max="100" value="6">
            </div>
            
            <div class="control-group">
                <label>ÊàøÈó¥Â§ßÂ∞è: <span class="value-display" id="roomSizeValue">‰∏≠</span></label>
                <input type="range" id="roomSize" min="0" max="4" value="2">
            </div>
            
            <div class="control-group">
                <label>ÊàøÈó¥‰ΩçÁΩÆ: </label>
                <select id="roomPosition">
                    <option value="random" selected>ÈöèÊú∫‰ΩçÁΩÆ</option>
                    <option value="inner">ÈÅìË∑ØÂÜÖ‰æß</option>
                    <option value="outer">ÈÅìË∑ØÂ§ñ‰æß</option>
                    <option value="mixed">Ê∑∑Âêà‰ΩçÁΩÆ</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Ëµ∞ÂªäÂÆΩÂ∫¶: <span class="value-display" id="corridorValue">2-4</span></label>
                <input type="range" id="corridorWidth" min="1" max="10" value="2">
            </div>
            
            <div class="control-group">
                <label>ÈÅìË∑ØÊõ≤ÊäòÂ∫¶: <span class="value-display" id="pathValue">‰∏≠</span></label>
                <input type="range" id="pathComplexity" min="0" max="4" value="2">
            </div>
            

            
            <div class="control-group">
                <label>Ëµ∞ÂªäÊ®°Âºè: </label>
                <select id="corridorRandom">
                    <option value="fixed">Âõ∫ÂÆöÂÆΩÂ∫¶</option>
                    <option value="random" selected>ÈöèÊú∫ÂÆΩÂ∫¶</option>
                    <option value="varied">ÂèòÂåñÂÆΩÂ∫¶</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Êé©‰ΩìÂØÜÂ∫¶: <span class="value-display" id="coverValue">20</span>%</label>
                <input type="range" id="coverDensity" min="10" max="100" value="20" step="5">
            </div>
            
            <div class="control-group">
                <label>Ê∞¥Âüü: <span class="value-display" id="waterValue">5</span>%</label>
                <input type="range" id="waterAmount" min="0" max="50" value="5" step="5">
            </div>
            
            <div class="control-group">
                <label>Ê•ºÊ¢ØÊï∞: <span class="value-display" id="stairsValue">3</span></label>
                <input type="range" id="stairsCount" min="1" max="20" value="3">
            </div>
            
            <div class="control-group">
                <label>Á™óÊà∑ÂØÜÂ∫¶: <span class="value-display" id="windowValue">30</span>%</label>
                <input type="range" id="windowDensity" min="10" max="100" value="30" step="10">
            </div>
            
            <div class="control-group">
                <label>È´ò‰ΩéÂ∑Æ: <span class="value-display" id="elevationValue">‰∏≠</span></label>
                <input type="range" id="elevation" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>ÁãôÂáªÈïøÈÅì: <span class="value-display" id="longValue">2</span></label>
                <input type="range" id="longLanes" min="0" max="20" value="2">
            </div>
            
            <div class="control-group">
                <label>‰∏≠Ë∑ØÊéßÂà∂: </label>
                <select id="midControl">
                    <option value="none">Êó†‰∏≠Ë∑Ø</option>
                    <option value="single" selected>Âçï‰∏≠Ë∑Ø</option>
                    <option value="double">Âèå‰∏≠Ë∑Ø</option>
                    <option value="complex">Â§çÊùÇ‰∏≠Ë∑Ø</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>ÊóãËΩ¨Êó∂Èó¥: <span class="value-display" id="rotateValue">‰∏≠</span></label>
                <input type="range" id="rotateTime" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>ÂûÇÁõ¥Â∫¶: <span class="value-display" id="verticalValue">20</span>%</label>
                <input type="range" id="verticality" min="0" max="100" value="20" step="10">
            </div>
            
            <div class="control-group">
                <label>ÂèØÁ†¥ÂùèÁâ©: <span class="value-display" id="breakValue">10</span>%</label>
                <input type="range" id="breakables" min="0" max="100" value="10" step="5">
            </div>
            
            <div class="control-group">
                <label>Âú∫Âú∞Â∏ÉÂ±Ä: </label>
                <select id="fieldLayout">
                    <option value="indoor" selected>Á∫ØÂÜÖÂú∫</option>
                    <option value="outdoor">Á∫ØÂ§ñÂú∫</option>
                    <option value="mixed">Ê∑∑ÂêàÂú∫Âú∞</option>
                    <option value="central_outdoor">‰∏≠Â§ÆÂ§ñÂú∫</option>
                    <option value="peripheral_outdoor">ËæπÁºòÂ§ñÂú∫</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Ê∏∏ÊàèÊ®°Âºè: </label>
                <select id="gameMode">
                    <option value="team" selected>Âõ¢ÈòüÁ´ûÊäÄ</option>
                    <option value="bomb">ÁàÜÁ†¥Ê®°Âºè</option>
                    <option value="zombie">ÁîüÂåñÊ®°Âºè</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Âú∞ÂõæÈ£éÊ†º: </label>
                <select id="mapStyle">
                    <option value="balanced" selected>Âπ≥Ë°°Âûã</option>
                    <option value="ct_sided">CT‰ºòÂäø</option>
                    <option value="t_sided">T‰ºòÂäø</option>
                    <option value="aim_heavy">Êû™Ê≥ïÂûã</option>
                    <option value="tactical">ÊàòÊúØÂûã</option>
                    <option value="rush">Âø´ÊîªÂûã</option>
                    <option value="black_town">ÈªëËâ≤ÂüéÈïá</option>
                    <option value="desert_gray">Ê≤ôÊº†ÁÅ∞</option>
                    <option value="new_year_plaza">Êñ∞Âπ¥ÂπøÂú∫</option>
                    <option value="white_house">ÁôΩÊàø</option>
                    <option value="transport_ship">ËøêËæìËàπ</option>
                    <option value="satellite_base">Âç´ÊòüÂü∫Âú∞</option>
                    <option value="harbor_dock">Ê∏ØÂè£Á†ÅÂ§¥</option>
                    <option value="subway_station">Âú∞ÈìÅÁ´ô</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Â§ñÂú∫ÊØî‰æã: <span class="value-display" id="outdoorValue">20</span>%</label>
                <input type="range" id="outdoorRatio" min="0" max="100" value="20" step="5">
            </div>
            
            <div class="control-group">
                <label>Â§ñÂú∫Â∞∫ÂØ∏: <span class="value-display" id="outdoorSizeValue">‰∏≠</span></label>
                <input type="range" id="outdoorSize" min="0" max="2" value="1" step="1">
            </div>
            
            <div class="control-group">
                <label>Â§ñÂú∫Èù¢ÁßØ: <span class="value-display" id="outdoorAreaValue">‰∏≠</span></label>
                <input type="range" id="outdoorArea" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>üîπ Â∏∏ËßÅÂú∞ÂΩ¢/Ê®°Âùó</label>
            </div>
            
            <div class="control-group">
                <label>Â§ßÈÅìÁîüÊàê: <span class="value-display" id="longLaneValue">‰∏≠</span></label>
                <input type="range" id="longLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>Â∞èÈÅìÁîüÊàê: <span class="value-display" id="shortLaneValue">‰∏≠</span></label>
                <input type="range" id="shortLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>‰∏≠Ë∑ØÁîüÊàê: <span class="value-display" id="midLaneValue">‰∏≠</span></label>
                <input type="range" id="midLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>È´òÂè∞ÁîüÊàê: <span class="value-display" id="platformValue">‰∏≠</span></label>
                <input type="range" id="platform" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ÊöóÈÅìÁîüÊàê: <span class="value-display" id="underpassValue">‰∏≠</span></label>
                <input type="range" id="underpass" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ËøûÊé•Ë∑ØÁîüÊàê: <span class="value-display" id="connectorValue">‰∏≠</span></label>
                <input type="range" id="connector" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ÊñúÂù°ÁîüÊàê: <span class="value-display" id="rampValue">‰∏≠</span></label>
                <input type="range" id="ramp" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ËΩ¨ÁÇπË∑ØÁ∫ø: <span class="value-display" id="rotationValue">‰∏≠</span></label>
                <input type="range" id="rotation" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ÂåÖÁÇπÊï∞Èáè: <span class="value-display" id="bombSiteValue">2</span></label>
                <input type="range" id="bombSiteCount" min="1" max="5" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>Èò¥ÁÇπÂØÜÂ∫¶: <span class="value-display" id="shadowPointValue">‰∏≠</span></label>
                <input type="range" id="shadowPoint" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ÊàøÈó¥Â°´ÂÖÖ: <span class="value-display" id="roomFillValue">Êó†</span></label>
                <input type="range" id="roomFill" min="0" max="4" value="0" step="1">
            </div>
            
            <div class="control-group">
                <label>ÁîüÊàêÂ§ßÂéÖ: </label>
                <select id="generateLobby">
                    <option value="none">Êó†Â§ßÂéÖ</option>
                    <option value="small" selected>Â∞èÂûãÂ§ßÂéÖ</option>
                    <option value="medium">‰∏≠ÂûãÂ§ßÂéÖ</option>
                    <option value="large">Â§ßÂûãÂ§ßÂéÖ</option>
                    <option value="central">‰∏≠Â§ÆÂ§ßÂéÖ</option>
                    <option value="circle">ÂúÜÂΩ¢Â§ßÂéÖ</option>
                    <option value="cross">ÂçÅÂ≠óÂ§ßÂéÖ</option>
                    <option value="square">ÊñπÂΩ¢Â§ßÂéÖ</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>ÊäïÊé∑Áâ©ÁÇπ: <span class="value-display" id="nadeValue">15</span></label>
                <input type="range" id="nadeSpots" min="5" max="100" value="15" step="5">
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="generateBtn">ÁîüÊàêÂú∞Âõæ</button>
                    <button id="randomBtn">ÈöèÊú∫ÁîüÊàê</button>
                    <button class="export-btn" id="exportBtn">ÂØºÂá∫</button>
                </div>
            </div>
        </div>
        
        <div class="map-header">
            <div class="map-name" id="mapName">Á´ûÊäÄÂú∞Âõæ</div>
            <div>Â§öÂ±ÇÁàÜÁ†¥Ê®°Âºè</div>
        </div>
        
        <div class="floor-selector" id="floorSelector"></div>
        
        <canvas id="canvas"></canvas>
        
        <div class="seeds-panel">
            <h3>ÁßçÂ≠êÊî∂Ëóè</h3>
            <div class="seed-controls">
                <button id="saveSeedBtn">üíæ ‰øùÂ≠òÂΩìÂâçÁßçÂ≠ê</button>
                <button id="clearSeedsBtn">üóëÔ∏è Ê∏ÖÁ©∫Êî∂Ëóè</button>
            </div>
            <div class="seeds-list" id="seedsList">
                <!-- ÁßçÂ≠êÂàóË°®Â∞ÜÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàê -->
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a4a4a;"></div>
                <span>‰∏≠Á≠âÂú∞</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a6a4a;"></div>
                <span>È´òÂú∞</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a2a4a;"></div>
                <span>‰ΩéÂú∞</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #b0b0b0;"></div>
                <span>Â¢ôÂ£Å</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #303030;"></div>
                <span>Êé©‰Ωì</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a4d69;"></div>
                <span>Ê∞¥Âüü</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8B7355;"></div>
                <span>Ê•ºÊ¢Ø(‰∏ä)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6B5345;"></div>
                <span>Ê•ºÊ¢Ø(‰∏ã)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a8caf;"></div>
                <span>Á™óÊà∑</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a5a00;"></div>
                <span>AÂåÖÁÇπ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a3a00;"></div>
                <span>BÂåÖÁÇπ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3a2020;"></div>
                <span>TÂá∫ÁîüÁÇπ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #202030;"></div>
                <span>CTÂá∫ÁîüÁÇπ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a8a6a;"></div>
                <span>Â§ñÂú∫Âú∞Èù¢</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a8a7a;"></div>
                <span>Â§ñÂú∫Âõ¥Â¢ô</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a7a8a;"></div>
                <span>Â§ßÂéÖ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a6a7a;"></div>
                <span>Â§ßÂéÖÂÖ•Âè£</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a6a8a;"></div>
                <span>Â§ßÂéÖ‰∏≠ÂøÉ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                <span>Âè†Âä†ËßÜÂõæ</span>
            </div>
        </div>
    </div>

    <script>
        // ÂÖ®Â±ÄÂèòÈáè
        let mapFloors = [];
        let currentFloor = 0;
        let totalFloors = 2;
        let overlayMode = false;
        
        // Âú∞ÂõæÂÖÉÁ¥†Á±ªÂûã
        const TileType = {
            VOID: 0,
            FLOOR: 1,
            WALL: 2,
            DOOR: 3,
            WINDOW: 4,
            COVER: 5,
            BOMBSITE_A: 6,
            BOMBSITE_B: 7,
            BOMBSITE_C: 40, // Êñ∞Â¢ûÂåÖÁÇπC
            BOMBSITE_D: 41, // Êñ∞Â¢ûÂåÖÁÇπD
            BOMBSITE_E: 42, // Êñ∞Â¢ûÂåÖÁÇπE
            T_SPAWN: 8,
            CT_SPAWN: 9,
            STAIRS_UP: 10,
            STAIRS_DOWN: 11,
            WATER: 12,
            BRIDGE: 13,
            ELEVATED: 14,      // È´òÂè∞
            LOWERED: 15,       // ‰ΩéÂú∞
            BREAKABLE: 16,     // ÂèØÁ†¥ÂùèÂ¢ô
            HIGH_GROUND: 29,   // È´òÂú∞
            LOW_GROUND: 30,    // ‰ΩéÂú∞
            MEDIUM_GROUND: 31, // ‰∏≠Á≠âÂú∞
            LONG_LANE: 17,     // ÁãôÂáªÈïøÈÅì
            MID_AREA: 18,      // ‰∏≠Ë∑ØÂå∫Âüü
            NADE_SPOT: 19,     // ÊäïÊé∑Áâ©ÁÇπ
            BOOST_SPOT: 20,    // Ë∑≥ÁÇπ‰ΩçÁΩÆ
            ONE_WAY: 21,       // ÂçïÂêë‰ΩçÁΩÆ
            OUTDOOR: 22,       // Â§ñÂú∫Âú∞Èù¢
            OUTDOOR_WALL: 23,  // Â§ñÂú∫Â¢ôÂ£Å/Âõ¥Â¢ô
            OUTDOOR_COVER: 24, // Â§ñÂú∫Êé©‰ΩìÔºàÈõÜË£ÖÁÆ±„ÄÅËΩ¶ËæÜÁ≠âÔºâ
            SKYBOX: 25,       // Â§©Á©∫ÁõíÂå∫Âüü
            LOBBY: 26,        // Â§ßÂéÖ
            LOBBY_ENTRANCE: 27, // Â§ßÂéÖÂÖ•Âè£
            LOBBY_CENTER: 28,  // Â§ßÂéÖ‰∏≠ÂøÉ
            // Â∏∏ËßÅÂú∞ÂΩ¢/Ê®°Âùó
            LONG_LANE: 32,     // Â§ßÈÅìÔºàÈïøÁõ¥ÈÄöÈÅìÔºâ
            SHORT_LANE: 33,    // Â∞èÈÅìÔºàÁ™ÑÈÄöÈÅìÔºâ
            MID_LANE: 34,      // ‰∏≠Ë∑ØÔºà‰∫§Ê±áÂå∫Ôºâ
            PLATFORM: 35,      // È´òÂè∞/Âπ≥Âè∞
            UNDERPASS: 36,     // ÊöóÈÅì/‰∏ãÊ∞¥ÈÅì
            CONNECTOR: 37,     // ËøûÊé•Ë∑Ø
            RAMP: 38,          // ÊñúÂù°
            ROTATION_PATH: 39, // ËΩ¨ÁÇπ/ËΩÆËΩ¨Ë∑ØÁ∫ø
            SHADOW_POINT: 43   // Èò¥ÁÇπÔºàÂûÇÁõ¥Â∞èÂ¢ô‰ΩìÔºâ
        };
        
        // Êõ¥Êñ∞ÊªëÂùóÊòæÁ§∫
        document.getElementById('mapSize').oninput = function() {
            document.getElementById('sizeValue').textContent = this.value;
        };
        
        document.getElementById('floorCount').oninput = function() {
            document.getElementById('floorsValue').textContent = this.value;
        };
        
        document.getElementById('roomCount').oninput = function() {
            document.getElementById('roomValue').textContent = this.value;
        };
        
        document.getElementById('corridorWidth').oninput = function() {
            const val = parseInt(this.value);
            const mode = document.getElementById('corridorRandom').value;
            if (mode === 'fixed') {
                document.getElementById('corridorValue').textContent = val + 1;
            } else if (mode === 'random') {
                document.getElementById('corridorValue').textContent = val + '-' + (val + 2);
            } else {
                document.getElementById('corridorValue').textContent = '1-' + (val + 2);
            }
        };
        
        document.getElementById('coverDensity').oninput = function() {
            document.getElementById('coverValue').textContent = this.value;
        };
        
        document.getElementById('waterAmount').oninput = function() {
            document.getElementById('waterValue').textContent = this.value;
        };
        
        document.getElementById('stairsCount').oninput = function() {
            document.getElementById('stairsValue').textContent = this.value;
        };
        
        document.getElementById('outdoorRatio').oninput = function() {
            document.getElementById('outdoorValue').textContent = this.value;
        };
        
        document.getElementById('outdoorSize').oninput = function() {
            const values = ['Â∞è', '‰∏≠', 'Â§ß'];
            document.getElementById('outdoorSizeValue').textContent = values[this.value];
        };
        
        document.getElementById('outdoorArea').oninput = function() {
            const values = ['ÊûÅÂ∞è', 'Â∞è', '‰∏≠', 'Â§ß', 'ÊûÅÂ§ß'];
            document.getElementById('outdoorAreaValue').textContent = values[this.value];
        };
        
        // Â∏∏ËßÅÂú∞ÂΩ¢/Ê®°ÂùóÂèÇÊï∞‰∫ã‰ª∂ÁõëÂê¨Âô®
        document.getElementById('longLane').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('longLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('shortLane').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('shortLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('midLane').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('midLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('platform').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('platformValue').textContent = values[this.value];
        };
        
        document.getElementById('underpass').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('underpassValue').textContent = values[this.value];
        };
        
        document.getElementById('connector').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('connectorValue').textContent = values[this.value];
        };
        
        document.getElementById('ramp').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('rampValue').textContent = values[this.value];
        };
        
        document.getElementById('rotation').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('rotationValue').textContent = values[this.value];
        };
        
        document.getElementById('bombSiteCount').oninput = function() {
            document.getElementById('bombSiteValue').textContent = this.value;
        };
        
        document.getElementById('shadowPoint').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('shadowPointValue').textContent = values[this.value];
        };
        
        document.getElementById('pathComplexity').oninput = function() {
            const values = ['Áõ¥Á∫ø', 'ÂæÆÂºØ', '‰∏≠Á≠â', 'Êõ≤Êäò', 'Ëø∑ÂÆ´'];
            document.getElementById('pathValue').textContent = values[this.value];
        };
        

        
        document.getElementById('elevation').oninput = function() {
            const values = ['‰Ωé', '‰∏≠', 'È´ò'];
            document.getElementById('elevationValue').textContent = values[this.value];
        };
        
        document.getElementById('roomSize').oninput = function() {
            const values = ['ÊûÅÂ∞è', 'Â∞è', '‰∏≠', 'Â§ß', 'ÊûÅÂ§ß'];
            document.getElementById('roomSizeValue').textContent = values[this.value];
        };
        
        document.getElementById('roomFill').oninput = function() {
            const values = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('roomFillValue').textContent = values[this.value];
        };
        
        document.getElementById('longLanes').oninput = function() {
            document.getElementById('longValue').textContent = this.value;
        };
        
        document.getElementById('rotateTime').oninput = function() {
            const values = ['Áü≠', '‰∏≠', 'Èïø'];
            document.getElementById('rotateValue').textContent = values[this.value];
        };
        
        document.getElementById('verticality').oninput = function() {
            document.getElementById('verticalValue').textContent = this.value;
        };
        
        document.getElementById('breakables').oninput = function() {
            document.getElementById('breakValue').textContent = this.value;
        };
        
        document.getElementById('nadeSpots').oninput = function() {
            document.getElementById('nadeValue').textContent = this.value;
        };
        
        // Ê∏∏ÊàèÊ®°ÂºèÈÄâÊã©‰∫ã‰ª∂
        document.getElementById('gameMode').onchange = function() {
            const gameMode = this.value;
            applyGameMode(gameMode);
        };
        
        // Âú∞ÂõæÈ£éÊ†ºÈÄâÊã©‰∫ã‰ª∂
        document.getElementById('mapStyle').onchange = function() {
            const mapStyle = this.value;
            applyMapStyle(mapStyle);
        };
        
        // ÈöèÊú∫ÁîüÊàêÂèÇÊï∞
        function randomizeParameters() {
            // Âú∞ÂõæÂ∞∫ÂØ∏ÂíåÊ•ºÂ±ÇÊï∞‰øùÊåÅ‰∏çÂèòÔºå‰∏çÈöèÊú∫Âåñ
            
            // ÈöèÊú∫ÊàøÈó¥Êï∞Èáè (3-100)
            
            // ÈöèÊú∫ÊàøÈó¥Êï∞Èáè (3-100)
            const roomCount = Math.floor(Math.random() * 98) + 3;
            document.getElementById('roomCount').value = roomCount;
            document.getElementById('roomValue').textContent = roomCount;
            
            // ÈöèÊú∫ÊàøÈó¥Â§ßÂ∞è (0-4)
            const roomSize = Math.floor(Math.random() * 5);
            document.getElementById('roomSize').value = roomSize;
            const roomSizeTexts = ['ÊûÅÂ∞è', 'Â∞è', '‰∏≠', 'Â§ß', 'ÊûÅÂ§ß'];
            document.getElementById('roomSizeValue').textContent = roomSizeTexts[roomSize];
            
            // ÈöèÊú∫ÊàøÈó¥‰ΩçÁΩÆ
            const roomPositions = ['random', 'inner', 'outer', 'mixed'];
            const roomPosition = roomPositions[Math.floor(Math.random() * roomPositions.length)];
            document.getElementById('roomPosition').value = roomPosition;
            
            // ÈöèÊú∫Ëµ∞ÂªäÂÆΩÂ∫¶ (1-10)
            const corridorWidth = Math.floor(Math.random() * 10) + 1;
            document.getElementById('corridorWidth').value = corridorWidth;
            const corridorMode = document.getElementById('corridorRandom').value;
            if (corridorMode === 'fixed') {
                document.getElementById('corridorValue').textContent = corridorWidth + 1;
            } else if (corridorMode === 'random') {
                document.getElementById('corridorValue').textContent = corridorWidth + '-' + (corridorWidth + 2);
            } else {
                document.getElementById('corridorValue').textContent = '1-' + (corridorWidth + 2);
            }
            
            // ÈöèÊú∫ÈÅìË∑ØÊõ≤ÊäòÂ∫¶ (0-4)
            const pathComplexity = Math.floor(Math.random() * 5);
            document.getElementById('pathComplexity').value = pathComplexity;
            const complexityTexts = ['ÁÆÄÂçï', 'ËæÉÁÆÄÂçï', '‰∏≠', 'ËæÉÂ§çÊùÇ', 'Â§çÊùÇ'];
            document.getElementById('pathValue').textContent = complexityTexts[pathComplexity];
            

            
            // ÈöèÊú∫Ëµ∞ÂªäÊ®°Âºè
            const corridorModes = ['fixed', 'random', 'varied'];
            const corridorModeRandom = corridorModes[Math.floor(Math.random() * corridorModes.length)];
            document.getElementById('corridorRandom').value = corridorModeRandom;
            
            // ÈöèÊú∫Êé©‰ΩìÂØÜÂ∫¶ (10-100)
            const coverDensity = Math.floor(Math.random() * 91) + 10;
            document.getElementById('coverDensity').value = coverDensity;
            document.getElementById('coverValue').textContent = coverDensity;
            
            // ÈöèÊú∫Ê∞¥Âüü (0-50)
            const waterAmount = Math.floor(Math.random() * 51);
            document.getElementById('waterAmount').value = waterAmount;
            document.getElementById('waterValue').textContent = waterAmount;
            
            // ÈöèÊú∫Ê•ºÊ¢ØÊï∞ (1-20)
            const stairsCount = Math.floor(Math.random() * 20) + 1;
            document.getElementById('stairsCount').value = stairsCount;
            document.getElementById('stairsValue').textContent = stairsCount;
            
            // ÈöèÊú∫Á™óÊà∑ÂØÜÂ∫¶ (10-100)
            const windowDensity = Math.floor(Math.random() * 91) + 10;
            document.getElementById('windowDensity').value = windowDensity;
            document.getElementById('windowValue').textContent = windowDensity;
            
            // ÈöèÊú∫È´ò‰ΩéÂ∑Æ (0-2)
            const elevation = Math.floor(Math.random() * 3);
            document.getElementById('elevation').value = elevation;
            const elevationTexts = ['Êó†', '‰∏≠', 'È´ò'];
            document.getElementById('elevationValue').textContent = elevationTexts[elevation];
            
            // ÈöèÊú∫ÁãôÂáªÈïøÈÅì (0-20)
            const longLanes = Math.floor(Math.random() * 21);
            document.getElementById('longLanes').value = longLanes;
            document.getElementById('longValue').textContent = longLanes;
            
            // ÈöèÊú∫‰∏≠Ë∑ØÊéßÂà∂
            const midControls = ['none', 'single', 'double', 'complex'];
            const midControl = midControls[Math.floor(Math.random() * midControls.length)];
            document.getElementById('midControl').value = midControl;
            
            // ÈöèÊú∫ÊóãËΩ¨Êó∂Èó¥ (0-2)
            const rotateTime = Math.floor(Math.random() * 3);
            document.getElementById('rotateTime').value = rotateTime;
            const rotateTexts = ['Áü≠', '‰∏≠', 'Èïø'];
            document.getElementById('rotateValue').textContent = rotateTexts[rotateTime];
            
            // ÈöèÊú∫ÂûÇÁõ¥Â∫¶ (0-100)
            const verticality = Math.floor(Math.random() * 101);
            document.getElementById('verticality').value = verticality;
            document.getElementById('verticalValue').textContent = verticality;
            
            // ÈöèÊú∫ÂèØÁ†¥ÂùèÁâ© (0-100)
            const breakables = Math.floor(Math.random() * 101);
            document.getElementById('breakables').value = breakables;
            document.getElementById('breakValue').textContent = breakables;
            
            // ÈöèÊú∫Âú∫Âú∞Â∏ÉÂ±Ä
            const fieldLayouts = ['indoor', 'outdoor', 'mixed', 'central_outdoor', 'peripheral_outdoor'];
            const fieldLayout = fieldLayouts[Math.floor(Math.random() * fieldLayouts.length)];
            document.getElementById('fieldLayout').value = fieldLayout;
            
            // ÈöèÊú∫Ê∏∏ÊàèÊ®°Âºè
            const gameModes = ['team', 'bomb', 'zombie'];
            const gameMode = gameModes[Math.floor(Math.random() * gameModes.length)];
            document.getElementById('gameMode').value = gameMode;
            applyGameMode(gameMode);
            
            // ÈöèÊú∫Âú∞ÂõæÈ£éÊ†º
            const mapStyles = ['balanced', 'ct_sided', 't_sided', 'aim_heavy', 'tactical', 'rush', 
                              'black_town', 'desert_gray', 'new_year_plaza', 'white_house', 
                              'transport_ship', 'satellite_base', 'harbor_dock', 'subway_station'];
            const mapStyle = mapStyles[Math.floor(Math.random() * mapStyles.length)];
            document.getElementById('mapStyle').value = mapStyle;
            applyMapStyle(mapStyle);
            
            // ÈöèÊú∫Â§ñÂú∫ÊØî‰æã (0-100)
            const outdoorRatio = Math.floor(Math.random() * 101);
            document.getElementById('outdoorRatio').value = outdoorRatio;
            document.getElementById('outdoorValue').textContent = outdoorRatio;
            
            // ÈöèÊú∫Â§ñÂú∫Â∞∫ÂØ∏ (0-2)
            const outdoorSize = Math.floor(Math.random() * 3);
            document.getElementById('outdoorSize').value = outdoorSize;
            const outdoorSizeTexts = ['Â∞è', '‰∏≠', 'Â§ß'];
            document.getElementById('outdoorSizeValue').textContent = outdoorSizeTexts[outdoorSize];
            
            // ÈöèÊú∫Â§ñÂú∫Èù¢ÁßØ (0-4)
            const outdoorArea = Math.floor(Math.random() * 5);
            document.getElementById('outdoorArea').value = outdoorArea;
            const outdoorAreaTexts = ['ÊûÅÂ∞è', 'Â∞è', '‰∏≠', 'Â§ß', 'ÊûÅÂ§ß'];
            document.getElementById('outdoorAreaValue').textContent = outdoorAreaTexts[outdoorArea];
            
            // ÈöèÊú∫ÁîüÊàêÂ§ßÂéÖ
            const lobbyTypes = ['none', 'small', 'medium', 'large', 'central', 'circle', 'cross', 'square'];
            const lobbyType = lobbyTypes[Math.floor(Math.random() * lobbyTypes.length)];
            document.getElementById('generateLobby').value = lobbyType;
            
            // ÈöèÊú∫Â∏∏ËßÅÂú∞ÂΩ¢/Ê®°ÂùóÂèÇÊï∞
            const longLane = Math.floor(Math.random() * 5);
            document.getElementById('longLane').value = longLane;
            const longLaneTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('longLaneValue').textContent = longLaneTexts[longLane];
            
            const shortLane = Math.floor(Math.random() * 5);
            document.getElementById('shortLane').value = shortLane;
            const shortLaneTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('shortLaneValue').textContent = shortLaneTexts[shortLane];
            
            const midLane = Math.floor(Math.random() * 5);
            document.getElementById('midLane').value = midLane;
            const midLaneTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('midLaneValue').textContent = midLaneTexts[midLane];
            
            const platform = Math.floor(Math.random() * 5);
            document.getElementById('platform').value = platform;
            const platformTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('platformValue').textContent = platformTexts[platform];
            
            const underpass = Math.floor(Math.random() * 5);
            document.getElementById('underpass').value = underpass;
            const underpassTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('underpassValue').textContent = underpassTexts[underpass];
            
            const connector = Math.floor(Math.random() * 5);
            document.getElementById('connector').value = connector;
            const connectorTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('connectorValue').textContent = connectorTexts[connector];
            
            const ramp = Math.floor(Math.random() * 5);
            document.getElementById('ramp').value = ramp;
            const rampTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('rampValue').textContent = rampTexts[ramp];
            
            const rotation = Math.floor(Math.random() * 5);
            document.getElementById('rotation').value = rotation;
            const rotationTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('rotationValue').textContent = rotationTexts[rotation];
            
            // ÈöèÊú∫ÂåÖÁÇπÊï∞Èáè (1-5)
            const bombSiteCount = Math.floor(Math.random() * 5) + 1;
            document.getElementById('bombSiteCount').value = bombSiteCount;
            document.getElementById('bombSiteValue').textContent = bombSiteCount;
            
            // ÈöèÊú∫Èò¥ÁÇπÂØÜÂ∫¶ (0-4)
            const shadowPoint = Math.floor(Math.random() * 5);
            document.getElementById('shadowPoint').value = shadowPoint;
            const shadowPointTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('shadowPointValue').textContent = shadowPointTexts[shadowPoint];
            
            // ÈöèÊú∫ÊàøÈó¥Â°´ÂÖÖ (0-4)
            const roomFill = Math.floor(Math.random() * 5);
            document.getElementById('roomFill').value = roomFill;
            const roomFillTexts = ['Êó†', 'Â∞ë', '‰∏≠', 'Â§ö', 'ÊûÅÂ§ö'];
            document.getElementById('roomFillValue').textContent = roomFillTexts[roomFill];
            
            // ÈöèÊú∫ÊäïÊé∑Áâ©ÁÇπ (5-100)
            const nadeSpots = Math.floor(Math.random() * 96) + 5;
            document.getElementById('nadeSpots').value = nadeSpots;
            document.getElementById('nadeValue').textContent = nadeSpots;
        }
        
        // ÂàùÂßãÂåñÂú∞Âõæ
        function initMap(size, floors) {
            mapFloors = [];
            totalFloors = floors;
            
            for (let f = 0; f < floors; f++) {
                mapFloors[f] = [];
                for (let y = 0; y < size; y++) {
                    mapFloors[f][y] = [];
                    for (let x = 0; x < size; x++) {
                        mapFloors[f][y][x] = TileType.VOID;
                    }
                }
            }
        }
        
        // ÁîüÊàêÊàøÈó¥ÔºàÊîØÊåÅÂÜÖÂ§ñÂú∫Ôºâ
        function generateRooms(size, roomCount, floor) {
            const rooms = [];
            // Ê†πÊçÆÊàøÈó¥Â§ßÂ∞èÂèÇÊï∞Ë∞ÉÊï¥ÊàøÈó¥Â∞∫ÂØ∏
            const roomSizeParam = parseInt(document.getElementById('roomSize').value);
            const roomSizeMultipliers = [0.2, 0.4, 0.8, 1.5, 2.5]; // ÊûÅÂ∞è„ÄÅÂ∞è„ÄÅ‰∏≠„ÄÅÂ§ß„ÄÅÊûÅÂ§ß - Â¢ûÂä†Â∑ÆÂºÇ
            const roomSizeMultiplier = roomSizeMultipliers[roomSizeParam];
            
            const minRoomSize = Math.max(2, Math.floor(size / 25 * roomSizeMultiplier)); // ÊúÄÂ∞èÊàøÈó¥Â∞∫ÂØ∏
            const maxRoomSize = Math.max(minRoomSize + 1, Math.floor(size / 4 * roomSizeMultiplier)); // ÊúÄÂ§ßÊàøÈó¥Â∞∫ÂØ∏ÔºåÁßªÈô§Á°¨ÁºñÁ†ÅÈôêÂà∂
            const fieldLayout = document.getElementById('fieldLayout').value;
            const outdoorRatio = parseInt(document.getElementById('outdoorRatio').value) / 100;
            const roomPosition = document.getElementById('roomPosition').value; // ÊàøÈó¥ÁîüÊàê‰ΩçÁΩÆ
            
            // ÂÖàÂàõÂª∫Â§ñÂú∫Âå∫Âüü
            if (floor === 0 && fieldLayout !== 'indoor') {
                createOutdoorAreas(size, fieldLayout, outdoorRatio);
            }
            
            // ËÆ°ÁÆóÊàøÈó¥Èó¥Ë∑ùÔºàÁ°Æ‰øùÊàøÈó¥Áã¨Á´ãÔºâ
            const minSpacing = Math.max(1, Math.floor(size / 50)); // Ëøõ‰∏ÄÊ≠•ÂáèÂ∞èÈó¥Ë∑ù
            
            for (let i = 0; i < roomCount * 100; i++) { // Ëøõ‰∏ÄÊ≠•Â¢ûÂä†Â∞ùËØïÊ¨°Êï∞
                const width = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                const height = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                
                // Ê†πÊçÆÊàøÈó¥ÁîüÊàê‰ΩçÁΩÆÂèÇÊï∞ÂÜ≥ÂÆöÊàøÈó¥‰ΩçÁΩÆ
                let x, y;
                const centerX = Math.floor(size / 2);
                const centerY = Math.floor(size / 2);
                const roadRadius = Math.floor(size / 3); // ÂÅáËÆæÈÅìË∑ØÂú®‰∏≠ÂøÉÂå∫Âüü
                
                switch(roomPosition) {
                    case 'inner':
                        // ÈÅìË∑ØÂÜÖ‰æßÔºàÈù†Ëøë‰∏≠ÂøÉÔºâ
                        const innerRadius = Math.floor(size / 4);
                        const angle = Math.random() * 2 * Math.PI;
                        const distance = Math.random() * innerRadius;
                        x = Math.floor(centerX + Math.cos(angle) * distance);
                        y = Math.floor(centerY + Math.sin(angle) * distance);
                        break;
                    case 'outer':
                        // ÈÅìË∑ØÂ§ñ‰æßÔºàËøúÁ¶ª‰∏≠ÂøÉÔºâ
                        const outerRadius = Math.floor(size / 2.5);
                        const outerAngle = Math.random() * 2 * Math.PI;
                        const outerDistance = outerRadius + Math.random() * (size / 2 - outerRadius);
                        x = Math.floor(centerX + Math.cos(outerAngle) * outerDistance);
                        y = Math.floor(centerY + Math.sin(outerAngle) * outerDistance);
                        break;
                    case 'mixed':
                        // Ê∑∑Âêà‰ΩçÁΩÆ
                        if (Math.random() > 0.5) {
                            // ÂÜÖ‰æß
                            const mixedAngle = Math.random() * 2 * Math.PI;
                            const mixedDistance = Math.random() * (size / 3);
                            x = Math.floor(centerX + Math.cos(mixedAngle) * mixedDistance);
                            y = Math.floor(centerY + Math.sin(mixedAngle) * mixedDistance);
                        } else {
                            // Â§ñ‰æß
                            const mixedOuterAngle = Math.random() * 2 * Math.PI;
                            const mixedOuterDistance = (size / 3) + Math.random() * (size / 2 - size / 3);
                            x = Math.floor(centerX + Math.cos(mixedOuterAngle) * mixedOuterDistance);
                            y = Math.floor(centerY + Math.sin(mixedOuterAngle) * mixedOuterDistance);
                        }
                        break;
                    default: // 'random'
                        // ÈöèÊú∫‰ΩçÁΩÆ
                        x = Math.floor(Math.random() * (size - width - minSpacing * 2)) + minSpacing;
                        y = Math.floor(Math.random() * (size - height - minSpacing * 2)) + minSpacing;
                        break;
                }
                
                // Á°Æ‰øùÊàøÈó¥Âú®ËæπÁïåÂÜÖ
                x = Math.max(minSpacing, Math.min(x, size - width - minSpacing));
                y = Math.max(minSpacing, Math.min(y, size - height - minSpacing));
                
                // È¢ùÂ§ñÊ£ÄÊü•ÔºöÁ°Æ‰øùÊàøÈó¥ÂÆåÂÖ®Âú®Âú∞ÂõæËåÉÂõ¥ÂÜÖ
                if (x < 0 || y < 0 || x + width > size || y + height > size) {
                    continue; // Ë∑≥ËøáËøô‰∏™ÊàøÈó¥ÔºåÂ∞ùËØï‰∏ã‰∏Ä‰∏™
                }
                
                // Ë∞ÉËØïÔºöÊòæÁ§∫ÊàøÈó¥‰ΩçÁΩÆ‰ø°ÊÅØ
                if (rooms.length < 3) {
                    console.log(`ÊàøÈó¥${rooms.length + 1}: ‰ΩçÁΩÆ(${x},${y}), Â∞∫ÂØ∏(${width}x${height}), ‰ΩçÁΩÆÁ±ªÂûã: ${roomPosition}`);
                }
                
                // Ê£ÄÊü•‰∏éÁé∞ÊúâÊàøÈó¥ÁöÑÈáçÂè†ÂíåÈó¥Ë∑ù
                let canPlace = true;
                for (let room of rooms) {
                    // Ê£ÄÊü•ÈáçÂè†ÔºàÂáèÂ∞ëÈó¥Ë∑ùË¶ÅÊ±ÇÔºâ
                    const expandedX = room.x - Math.floor(minSpacing / 2);
                    const expandedY = room.y - Math.floor(minSpacing / 2);
                    const expandedWidth = room.width + Math.floor(minSpacing / 2) * 2;
                    const expandedHeight = room.height + Math.floor(minSpacing / 2) * 2;
                    
                    if (x < expandedX + expandedWidth && x + width > expandedX &&
                        y < expandedY + expandedHeight && y + height > expandedY) {
                        canPlace = false;
                        break;
                    }
                }
                
                // Ê£ÄÊü•ÊòØÂê¶‰∏éÂ§ñÂú∫ÈáçÂè†ÔºàÂ§ñÂú∫‰ºòÂÖàÔºâ
                if (canPlace && floor === 0) {
                    for (let cy = y - 1; cy < y + height + 1; cy++) {
                        for (let cx = x - 1; cx < x + width + 1; cx++) {
                            if (cy >= 0 && cy < size && cx >= 0 && cx < size) {
                            if (mapFloors[floor][cy] && mapFloors[floor][cy][cx] === TileType.OUTDOOR) {
                                    canPlace = false;
                                break;
                            }
                        }
                        }
                        if (!canPlace) break;
                    }
                }
                
                if (canPlace) {
                    rooms.push({ x, y, width, height, floor, isIndoor: true });
                    
                    // ÁªòÂà∂ÊàøÈó¥ÔºàÂÜÖÂú∫Ôºâ- Á°Æ‰øùÂ¢ôÂ£ÅÂÆåÊï¥
                    for (let ry = y; ry < y + height; ry++) {
                        for (let rx = x; rx < x + width; rx++) {
                            if (ry === y || ry === y + height - 1 || rx === x || rx === x + width - 1) {
                                // ÊàøÈó¥ËæπÁïåÂ¢ôÂ£Å
                                        mapFloors[floor][ry][rx] = TileType.WALL;
                                } else {
                                // ÊàøÈó¥ÂÜÖÈÉ®Âú∞Êùø
                                mapFloors[floor][ry][rx] = TileType.FLOOR;
                            }
                        }
                    }
                    
                    // Âú®ÊàøÈó¥Âë®Âõ¥Ê∑ªÂä†ÁºìÂÜ≤Âå∫ÔºàÂáèÂ∞ëÁºìÂÜ≤Âå∫Â§ßÂ∞èÔºâ
                    addRoomBuffer(x, y, width, height, floor, size, Math.floor(minSpacing / 2));
                    
                    if (rooms.length >= roomCount) break;
                }
            }
            
            // Ë∞ÉËØï‰ø°ÊÅØÔºöÊòæÁ§∫ÂÆûÈôÖÁîüÊàêÁöÑÊàøÈó¥Êï∞Èáè
            console.log(`ÁõÆÊ†áÊàøÈó¥Êï∞Èáè: ${roomCount}, ÂÆûÈôÖÁîüÊàêÊàøÈó¥Êï∞Èáè: ${rooms.length}`);
            console.log(`ÊàøÈó¥Â∞∫ÂØ∏ËåÉÂõ¥: ${minRoomSize}-${maxRoomSize}, Èó¥Ë∑ù: ${minSpacing}`);
            console.log(`Âú∞ÂõæÂ§ßÂ∞è: ${size}x${size}, ÊàøÈó¥Â§ßÂ∞èÂÄçÊï∞: ${roomSizeMultiplier}`);
            console.log(`ÊàøÈó¥Â§ßÂ∞èÂèÇÊï∞: ${roomSizeParam} (${['ÊûÅÂ∞è', 'Â∞è', '‰∏≠', 'Â§ß', 'ÊûÅÂ§ß'][roomSizeParam]})`);
            console.log(`Â∞ùËØïÊ¨°Êï∞: ${roomCount * 100}, ÊàêÂäüÁéá: ${(rooms.length / roomCount * 100).toFixed(1)}%`);
            
            return rooms;
        }
        
        // ÂàõÂª∫Â§ñÂú∫Âå∫Âüü
        function createOutdoorAreas(size, layout, ratio) {
            const outdoorSize = parseInt(document.getElementById('outdoorSize').value);
            const outdoorArea = parseInt(document.getElementById('outdoorArea').value);
            const sizeMultiplier = [0.5, 1.0, 1.5][outdoorSize]; // Â∞è„ÄÅ‰∏≠„ÄÅÂ§ß
            const areaMultiplier = [0.3, 0.6, 1.0, 1.5, 2.0][outdoorArea]; // ÊûÅÂ∞è„ÄÅÂ∞è„ÄÅ‰∏≠„ÄÅÂ§ß„ÄÅÊûÅÂ§ß
            const outdoorTiles = Math.floor(size * size * ratio * sizeMultiplier * areaMultiplier);
            
            switch(layout) {
                case 'outdoor':
                    // ÂÖ®Â§ñÂú∫
                    for (let y = 0; y < size; y++) {
                        for (let x = 0; x < size; x++) {
                            mapFloors[0][y][x] = TileType.OUTDOOR;
                        }
                    }
                    break;
                    
                case 'central_outdoor':
                    // ‰∏≠Â§ÆÂ§ñÂú∫ÔºàËßÑÂàôÁü©ÂΩ¢Ôºâ
                    const centerX = Math.floor(size / 2);
                    const centerY = Math.floor(size / 2);
                    const areaWidth = Math.floor(size * Math.sqrt(ratio));
                    const areaHeight = Math.floor(size * Math.sqrt(ratio));
                    
                    const startX = Math.max(0, centerX - Math.floor(areaWidth / 2));
                    const endX = Math.min(size - 1, centerX + Math.floor(areaWidth / 2));
                    const startY = Math.max(0, centerY - Math.floor(areaHeight / 2));
                    const endY = Math.min(size - 1, centerY + Math.floor(areaHeight / 2));
                    
                    for (let y = startY; y <= endY; y++) {
                        for (let x = startX; x <= endX; x++) {
                                    mapFloors[0][y][x] = TileType.OUTDOOR;
                        }
                    }
                    break;
                    
                case 'peripheral_outdoor':
                    // ËæπÁºòÂ§ñÂú∫ÔºàËßÑÂàôËæπÊ°ÜÔºâ
                    const margin = Math.floor((1 - Math.sqrt(1 - ratio)) * size / 2);
                    
                    for (let y = 0; y < size; y++) {
                        for (let x = 0; x < size; x++) {
                            if (x < margin || x >= size - margin || 
                                y < margin || y >= size - margin) {
                                mapFloors[0][y][x] = TileType.OUTDOOR;
                            }
                        }
                    }
                    break;
                    
                case 'mixed':
                default:
                    // Ê∑∑ÂêàÂú∫Âú∞ÔºàËßÑÂàôÁü©ÂΩ¢Âå∫ÂüüÔºâ
                    const numOutdoorAreas = 2 + Math.floor(Math.random() * 2); // 2-3‰∏™Âå∫Âüü
                    const areaSize = Math.floor(Math.sqrt(outdoorTiles / numOutdoorAreas));
                    
                    for (let i = 0; i < numOutdoorAreas; i++) {
                        // Á°Æ‰øùÂå∫Âüü‰∏çÈáçÂè†
                        let attempts = 0;
                        let placed = false;
                        
                        // ÈôêÂà∂Âå∫ÂüüÂ§ßÂ∞èÔºåÈÅøÂÖçË∂ÖÂá∫ËæπÁïå
                        const maxAreaSize = Math.min(areaSize, Math.floor(size / 4));
                        
                        while (!placed && attempts < 50) {
                            const cx = Math.floor(Math.random() * (size - maxAreaSize * 2)) + maxAreaSize;
                            const cy = Math.floor(Math.random() * (size - maxAreaSize * 2)) + maxAreaSize;
                        
                            // Ê£ÄÊü•ÊòØÂê¶‰∏éÁé∞ÊúâÂ§ñÂú∫Âå∫ÂüüÈáçÂè†
                            let overlaps = false;
                            for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                if (x >= 0 && x < size && y >= 0 && y < size) {
                                        if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                                            overlaps = true;
                                            break;
                                        }
                                    }
                                }
                                if (overlaps) break;
                            }
                            
                            if (!overlaps) {
                                // ÂàõÂª∫ËßÑÂàôÁü©ÂΩ¢Â§ñÂú∫Âå∫Âüü
                                for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                    for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                        if (x >= 0 && x < size && y >= 0 && y < size) {
                                        mapFloors[0][y][x] = TileType.OUTDOOR;
                                    }
                                }
                            }
                                placed = true;
                            }
                            attempts++;
                        }
                        
                        // Â¶ÇÊûúÊó†Ê≥ïÊîæÁΩÆÔºåÂú®ËßíËêΩÂàõÂª∫Â∞èÂå∫Âüü
                        if (!placed) {
                            const cornerSize = Math.min(maxAreaSize, 10); // ÈôêÂà∂ËßíËêΩÂå∫ÂüüÂ§ßÂ∞è
                            const cornerX = (i % 2 === 0) ? cornerSize : size - cornerSize - 1;
                            const cornerY = (i < 2) ? cornerSize : size - cornerSize - 1;
                            
                            for (let y = cornerY - cornerSize; y <= cornerY + cornerSize; y++) {
                                for (let x = cornerX - cornerSize; x <= cornerX + cornerSize; x++) {
                                    if (x >= 0 && x < size && y >= 0 && y < size) {
                                        mapFloors[0][y][x] = TileType.OUTDOOR;
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
            
            // Âú®Â§ñÂú∫Ê∑ªÂä†‰∏Ä‰∫õÊé©‰ΩìÂíåÁâπÂæÅ
            addOutdoorFeatures(size);
        }
        
        // ÁîüÊàêÂ§ßÂéÖ
        function generateLobby(size, floor) {
            const lobbyType = document.getElementById('generateLobby').value;
            
            if (lobbyType === 'none') return;
            
            let lobbyWidth, lobbyHeight, lobbyX, lobbyY;
            
            switch(lobbyType) {
                case 'small':
                    lobbyWidth = 8;
                    lobbyHeight = 6;
                    break;
                case 'medium':
                    lobbyWidth = 12;
                    lobbyHeight = 8;
                    break;
                case 'large':
                    lobbyWidth = 16;
                    lobbyHeight = 10;
                    break;
                case 'central':
                    lobbyWidth = 14;
                    lobbyHeight = 12;
                    break;
                case 'circle':
                    lobbyWidth = 12;
                    lobbyHeight = 12;
                    break;
                case 'cross':
                    lobbyWidth = 15;
                    lobbyHeight = 15;
                    break;
                case 'square':
                    lobbyWidth = 14;
                    lobbyHeight = 14;
                    break;
                default:
                    return;
            }
            
            // Á°ÆÂÆöÂ§ßÂéÖ‰ΩçÁΩÆ
            if (lobbyType === 'central') {
                // ‰∏≠Â§ÆÂ§ßÂéÖ
                lobbyX = Math.floor((size - lobbyWidth) / 2);
                lobbyY = Math.floor((size - lobbyHeight) / 2);
            } else {
                // ÈöèÊú∫‰ΩçÁΩÆÔºå‰ΩÜÈÅøÂÖç‰∏éÂ§ñÂú∫ÈáçÂè†
                let attempts = 0;
                do {
                    lobbyX = Math.floor(Math.random() * (size - lobbyWidth - 4)) + 2;
                    lobbyY = Math.floor(Math.random() * (size - lobbyHeight - 4)) + 2;
                    attempts++;
                } while (hasOutdoorOverlap(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) && attempts < 50);
                
                if (attempts >= 50) return; // Â¶ÇÊûúÊâæ‰∏çÂà∞ÂêàÈÄÇ‰ΩçÁΩÆÔºåË∑≥Ëøá
            }
            
            // Á°Æ‰øùÂ§ßÂéÖÂÆåÂÖ®Âú®Âú∞ÂõæËåÉÂõ¥ÂÜÖ
            if (lobbyX < 0 || lobbyY < 0 || lobbyX + lobbyWidth > size || lobbyY + lobbyHeight > size) {
                return; // Â¶ÇÊûúÂ§ßÂéÖË∂ÖÂá∫ËæπÁïåÔºåË∑≥Ëøá
            }
            
            // Ê†πÊçÆÂ§ßÂéÖÁ±ªÂûãÂàõÂª∫‰∏çÂêåÂΩ¢Áä∂
            switch(lobbyType) {
                case 'circle':
                    createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'cross':
                    createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'square':
                    createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                default:
                    createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
            }
            
            // Ê∑ªÂä†Â§ßÂéÖÂÖ•Âè£
            addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
            
            // ËøûÊé•Â§ßÂéÖÂà∞ÂÖ∂‰ªñÂå∫Âüü
            connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
        }
        
        // ÂàõÂª∫Áü©ÂΩ¢Â§ßÂéÖ
        function createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // Â¢ôÂ£Å
                        mapFloors[floor][y][x] = TileType.WALL;
                    } else {
                        // Â§ßÂéÖÂÜÖÈÉ®
                        if (x === Math.floor(lobbyX + lobbyWidth / 2) && 
                            y === Math.floor(lobbyY + lobbyHeight / 2)) {
                            mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
        }
        
        // ÂàõÂª∫ÂúÜÂΩ¢Â§ßÂéÖ
        function createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const radius = Math.min(lobbyWidth, lobbyHeight) / 2 - 1;
            
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    
                    if (distance <= radius) {
                        // Â§ßÂéÖÂÜÖÈÉ®
                        if (distance <= 1) {
                            mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    } else if (distance <= radius + 1) {
                        // Â¢ôÂ£Å
                        mapFloors[floor][y][x] = TileType.WALL;
                    }
                }
            }
        }
        
        // ÂàõÂª∫ÂçÅÂ≠óÂ§ßÂéÖ
        function createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const armWidth = 3;
            const armLength = Math.min(lobbyWidth, lobbyHeight) / 2 - 2;
            
            // Ê∏ÖÁ©∫Âå∫Âüü
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    mapFloors[floor][y][x] = TileType.VOID;
                }
            }
            
            // ÂàõÂª∫ÂçÅÂ≠óÂΩ¢Áä∂
            // Ê∞¥Âπ≥ËáÇ
            for (let y = centerY - armWidth; y <= centerY + armWidth; y++) {
                for (let x = centerX - armLength; x <= centerX + armLength; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (x === centerX - armLength || x === centerX + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // ÂûÇÁõ¥ËáÇ
            for (let y = centerY - armLength; y <= centerY + armLength; y++) {
                for (let x = centerX - armWidth; x <= centerX + armWidth; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (y === centerY - armLength || y === centerY + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // ‰∏≠ÂøÉÁÇπ
            mapFloors[floor][centerY][centerX] = TileType.LOBBY_CENTER;
            
            // Ê∑ªÂä†Â§ñÈÉ®Â¢ôÂ£Å
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (mapFloors[floor][y][x] === TileType.VOID) {
                        // Ê£ÄÊü•ÊòØÂê¶‰∏éÂ§ßÂéÖÂÜÖÈÉ®Áõ∏ÈÇª
                        let adjacentToLobby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= lobbyX && nx < lobbyX + lobbyWidth && 
                                    ny >= lobbyY && ny < lobbyY + lobbyHeight) {
                                    if (mapFloors[floor][ny][nx] === TileType.LOBBY || 
                                        mapFloors[floor][ny][nx] === TileType.LOBBY_CENTER) {
                                        adjacentToLobby = true;
                                        break;
                                    }
                                }
                            }
                            if (adjacentToLobby) break;
                        }
                        if (adjacentToLobby) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        }
                    }
                }
            }
        }
        
        // ÂàõÂª∫ÊñπÂΩ¢Â§ßÂéÖ
        function createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const innerSize = Math.min(lobbyWidth, lobbyHeight) - 4;
            
            // ÂàõÂª∫Â§ñÈÉ®ÊñπÂΩ¢
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // Â§ñÈÉ®Â¢ôÂ£Å
                        mapFloors[floor][y][x] = TileType.WALL;
                    } else {
                        // ÂÜÖÈÉ®Âå∫Âüü
                        const innerX = Math.floor((lobbyWidth - innerSize) / 2);
                        const innerY = Math.floor((lobbyHeight - innerSize) / 2);
                        
                        if (x >= lobbyX + innerX && x < lobbyX + innerX + innerSize &&
                            y >= lobbyY + innerY && y < lobbyY + innerY + innerSize) {
                            // ÂÜÖÈÉ®ÊñπÂΩ¢
                            if (x === lobbyX + innerX || x === lobbyX + innerX + innerSize - 1 ||
                                y === lobbyY + innerY || y === lobbyY + innerY + innerSize - 1) {
                                // ÂÜÖÈÉ®Â¢ôÂ£Å
                                mapFloors[floor][y][x] = TileType.WALL;
                            } else {
                                // ÂÜÖÈÉ®Á©∫Èó¥
                                if (x === centerX && y === centerY) {
                                    mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                                } else {
                                    mapFloors[floor][y][x] = TileType.LOBBY;
                                }
                            }
                        } else {
                            // ‰∏≠Èó¥Âå∫ÂüüÔºàËµ∞ÂªäÔºâ
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
        }
        
        // Ê£ÄÊü•ÊòØÂê¶‰∏éÂ§ñÂú∫ÈáçÂè†
        function hasOutdoorOverlap(x, y, width, height, floor) {
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length &&
                        mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                        if (mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Ê∑ªÂä†Â§ßÂéÖÂÖ•Âè£
        function addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const entranceCount = 2 + Math.floor(Math.random() * 2); // 2-3‰∏™ÂÖ•Âè£
            
            for (let i = 0; i < entranceCount; i++) {
                let entranceX, entranceY;
                
                // ÈöèÊú∫ÈÄâÊã©ÂÖ•Âè£‰ΩçÁΩÆÔºàÂõõËæπÔºâ
                const side = Math.floor(Math.random() * 4);
                
                switch(side) {
                    case 0: // ‰∏äËæπ
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY;
                        break;
                    case 1: // ‰∏ãËæπ
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY + lobbyHeight - 1;
                        break;
                    case 2: // Â∑¶Ëæπ
                        entranceX = lobbyX;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                    case 3: // Âè≥Ëæπ
                        entranceX = lobbyX + lobbyWidth - 1;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                }
                
                // ÂàõÂª∫ÂÖ•Âè£
                mapFloors[floor][entranceY][entranceX] = TileType.LOBBY_ENTRANCE;
                
                // ÂàõÂª∫ÂÖ•Âè£ÈÄöÈÅì
                createEntrancePath(entranceX, entranceY, floor);
            }
        }
        
        // ÂàõÂª∫ÂÖ•Âè£ÈÄöÈÅì
        function createEntrancePath(entranceX, entranceY, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const pathLength = 3 + Math.floor(Math.random() * 3); // 3-5Ê†ºÈïø
            
            for (let [dx, dy] of directions) {
                let canCreatePath = true;
                
                // Ê£ÄÊü•Ë∑ØÂæÑÊñπÂêëÊòØÂê¶ÂèØË°å
                for (let i = 1; i <= pathLength; i++) {
                    const nx = entranceX + dx * i;
                    const ny = entranceY + dy * i;
                    
                    if (nx < 0 || nx >= mapFloors[floor][0].length || 
                        ny < 0 || ny >= mapFloors[floor].length ||
                        !mapFloors[floor][ny] || mapFloors[floor][ny][nx] === undefined) {
                        canCreatePath = false;
                        break;
                    }
                    
                    if (mapFloors[floor][ny][nx] !== TileType.VOID && 
                        mapFloors[floor][ny][nx] !== TileType.OUTDOOR) {
                        canCreatePath = false;
                        break;
                    }
                }
                
                if (canCreatePath) {
                    // ÂàõÂª∫ÈÄöÈÅì
                    for (let i = 1; i <= pathLength; i++) {
                        const nx = entranceX + dx * i;
                        const ny = entranceY + dy * i;
                        mapFloors[floor][ny][nx] = TileType.FLOOR;
                    }
                    break; // Âè™ÂàõÂª∫‰∏Ä‰∏™ÊñπÂêëÁöÑÈÄöÈÅì
                }
            }
        }
        
        // ËøûÊé•Â§ßÂéÖÂà∞ÂÖ∂‰ªñÂå∫Âüü
        function connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            // ÊâæÂà∞ÊúÄËøëÁöÑÊàøÈó¥ÊàñËµ∞Âªä
            let nearestArea = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (!mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                        continue;
                    }
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN) {
                        
                        const dist = Math.abs(x - (lobbyX + lobbyWidth/2)) + 
                                   Math.abs(y - (lobbyY + lobbyHeight/2));
                        
                        if (dist < minDist && dist > 5) { // Ë∑ùÁ¶ªÂ§ß‰∫é5ÊâçÈúÄË¶ÅËøûÊé•
                            minDist = dist;
                            nearestArea = {x, y};
                        }
                    }
                }
            }
            
            // Â¶ÇÊûúÊâæÂà∞‰∫ÜÈúÄË¶ÅËøûÊé•ÁöÑÂå∫ÂüüÔºåÂàõÂª∫Ëµ∞Âªä
            if (nearestArea && minDist < 20) {
                const lobbyCenterX = Math.floor(lobbyX + lobbyWidth / 2);
                const lobbyCenterY = Math.floor(lobbyY + lobbyHeight / 2);
                
                createSimpleCorridor(lobbyCenterX, lobbyCenterY, nearestArea.x, nearestArea.y, floor);
            }
        }
        
        // Ê£ÄÊü•‰ΩçÁΩÆÊòØÂê¶Èù†Â¢ôÊàñÈù†Èó®
        function isNearWallOrDoor(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // ‰∏ä‰∏ãÂ∑¶Âè≥Âõõ‰∏™ÊñπÂêë
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const adjacentTile = mapFloors[floor][ny][nx];
                    
                    // Ê£ÄÊü•ÊòØÂê¶Èù†Â¢ô
                    if (adjacentTile === TileType.WALL) {
                        return true;
                    }
                    
                    // Ê£ÄÊü•ÊòØÂê¶Èù†Èó®ÔºàÈó®ÈÄöÂ∏∏ÊòØÂú∞ÊùøÔºå‰ΩÜËøûÊé•ÊàøÈó¥Ôºâ
                    if (adjacentTile === TileType.FLOOR || 
                        adjacentTile === TileType.MEDIUM_GROUND ||
                        adjacentTile === TileType.HIGH_GROUND ||
                        adjacentTile === TileType.LOW_GROUND) {
                        // Ê£ÄÊü•Ëøô‰∏™Âú∞ÊùøÊòØÂê¶ËøûÊé•ÊàøÈó¥ÔºàÂç≥Âë®Âõ¥ÊúâÂ¢ôÂ£ÅÔºâ
                        if (isDoorway(nx, ny, floor)) {
                            return true;
                        }
                    }
                    
                    // Ê£ÄÊü•ÊòØÂê¶Èù†Á™óÊà∑
                    if (adjacentTile === TileType.WINDOW) {
                        return true;
                    }
                    
                    // Ê£ÄÊü•ÊòØÂê¶Èù†Â§ßÂéÖÂÖ•Âè£
                    if (adjacentTile === TileType.LOBBY_ENTRANCE) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Ê£ÄÊü•‰ΩçÁΩÆÊòØÂê¶ÊòØÈó®Âè£
        function isDoorway(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            let wallCount = 0;
            let voidCount = 0;
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const tile = mapFloors[floor][ny][nx];
                    if (tile === TileType.WALL) {
                        wallCount++;
                    } else if (tile === TileType.VOID) {
                        voidCount++;
                    }
                }
            }
            
            // Â¶ÇÊûúÂë®Âõ¥ÊúâÂ¢ôÂ£ÅÂíåÁ©∫Âú∞ÔºåËØ¥ÊòéËøôÊòØÈó®Âè£
            return wallCount >= 1 && voidCount >= 1;
        }
        
        // Ê∑ªÂä†Â§ñÂú∫ÁâπÂæÅ
        function addOutdoorFeatures(size) {
            // Ê∑ªÂä†ËßÑÂàôÁöÑÂ§ñÂú∫Êé©‰ΩìÔºàÈõÜË£ÖÁÆ±„ÄÅËΩ¶ËæÜÁ≠âÔºâ- Âè™ÁîüÊàêÂú®Èù†Â¢ô‰ΩçÁΩÆ
            const coverCount = Math.floor(size * size * 0.01); // 1%ÁöÑÂØÜÂ∫¶
            let placedCount = 0;
            let attempts = 0;
            
            while (placedCount < coverCount && attempts < coverCount * 10) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR && isOutdoorCoverPosition(x, y, size)) {
                    // ÂàõÂª∫ËßÑÂàôÁü©ÂΩ¢Êé©‰Ωì
                    const coverWidth = 2 + Math.floor(Math.random() * 2); // 2-3Ê†ºÂÆΩ
                    const coverHeight = 2; // Âõ∫ÂÆö2Ê†ºÈ´ò
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊúâË∂≥Â§üÁ©∫Èó¥
                    let canPlace = true;
                            for (let dy = 0; dy < coverHeight; dy++) {
                                for (let dx = 0; dx < coverWidth; dx++) {
                            if (y + dy >= size - 1 || x + dx >= size - 1) {
                                canPlace = false;
                                break;
                            }
                            if (mapFloors[0][y + dy][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        if (!canPlace) break;
                    }
                    
                    if (canPlace) {
                        for (let dy = 0; dy < coverHeight; dy++) {
                            for (let dx = 0; dx < coverWidth; dx++) {
                                            mapFloors[0][y + dy][x + dx] = TileType.OUTDOOR_COVER;
                                        }
                                    }
                        placedCount++;
                    }
                }
                attempts++;
            }
            
            // Âú®Â§ñÂú∫ËæπÁºòÊ∑ªÂä†ËßÑÂàôÂõ¥Â¢ô
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // Ê£ÄÊü•ÊòØÂê¶‰∏éÂ§ñÂú∫ËæπÁºòÁõ∏ÈÇª
                        let isEdge = false;
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                mapFloors[0][ny][nx] === TileType.VOID) {
                                        isEdge = true;
                                break;
                            }
                        }
                        
                        if (isEdge && Math.random() < 0.9) { // ÊèêÈ´òÂõ¥Â¢ôÁîüÊàêÊ¶ÇÁéá
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // Á°Æ‰øùÂ§ñÂú∫ÊúâÂÆåÊï¥ÁöÑÂõ¥Â¢ôËæπÁïå
            createOutdoorWallBoundary(size);
            
            // Ê∑ªÂä†ËßÑÂàôÁöÑÈÅìË∑ØËøûÊé•
            addOutdoorPaths(size);
        }
        
        // Ê£ÄÊü•Â§ñÂú∫Êé©‰Ωì‰ΩçÁΩÆÊòØÂê¶ÂêàÈÄÇÔºàÈù†Â¢ôÊàñËæπÁºòÔºâ
        function isOutdoorCoverPosition(x, y, size) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // Ê£ÄÊü•ÊòØÂê¶Èù†Â§ñÂú∫ËæπÁºò
                if (nx < 0 || nx >= size || ny < 0 || ny >= size) {
                    return true;
                }
                
                // Ê£ÄÊü•ËæπÁïåÂíåÊï∞ÁªÑÊúâÊïàÊÄß
                if (nx < 0 || nx >= size || ny < 0 || ny >= size ||
                    !mapFloors[0][ny] || mapFloors[0][ny][nx] === undefined) {
                    continue;
                }
                
                // Ê£ÄÊü•ÊòØÂê¶Èù†Â§ñÂú∫Âõ¥Â¢ô
                if (mapFloors[0][ny][nx] === TileType.OUTDOOR_WALL) {
                    return true;
                }
                
                // Ê£ÄÊü•ÊòØÂê¶Èù†ÂÜÖÂú∫ËæπÁïåÔºàÂ¢ôÂ£ÅÔºâ
                if (mapFloors[0][ny][nx] === TileType.WALL) {
                    return true;
                }
                
                // Ê£ÄÊü•ÊòØÂê¶Èù†Á©∫Âú∞ÔºàÂ§ñÂú∫ËæπÁºòÔºâ
                if (mapFloors[0][ny][nx] === TileType.VOID) {
                    return true;
                }
                
                // Ê£ÄÊü•ÊòØÂê¶Èù†ÈÅìË∑ØÔºàÂú∞ÊùøÔºâ
                if (mapFloors[0][ny][nx] === TileType.FLOOR) {
                    return true;
                }
            }
            
            return false;
        }
        
        // ÂàõÂª∫Â§ñÂú∫Âõ¥Â¢ôËæπÁïå
        function createOutdoorWallBoundary(size) {
            // Êâ´ÊèèÂ§ñÂú∫Âå∫ÂüüÔºåÁ°Æ‰øùËæπÁïåÂÆåÊï¥
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // Ê£ÄÊü•Âõõ‰∏™ÊñπÂêë
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        let needsWall = false;
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            // Â¶ÇÊûúÈÇªÊé•Âú∞ÂõæËæπÁïåÊàñÁ©∫Âú∞ÔºåÈúÄË¶ÅÂõ¥Â¢ô
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                (mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined &&
                                 mapFloors[0][ny][nx] === TileType.VOID)) {
                                needsWall = true;
                                break;
                            }
                        }
                        
                        // Â¶ÇÊûúÂΩìÂâçÊòØÂ§ñÂú∫‰∏îÈúÄË¶ÅÂõ¥Â¢ôÔºå‰ΩÜËøòÊ≤°ÊúâÂõ¥Â¢ôÔºåÂàôÊ∑ªÂä†Âõ¥Â¢ô
                        if (needsWall && mapFloors[0][y][x] === TileType.OUTDOOR) {
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // Ê∑ªÂä†Â§ñÂú∫ÂÜÖÈÉ®ÁöÑÂõ¥Â¢ôÁªìÊûÑÔºàÂ¶ÇÂàÜÈöîÂ¢ôÔºâ
            addOutdoorInternalWalls(size);
        }
        
        // Ê∑ªÂä†Â§ñÂú∫ÂÜÖÈÉ®Âõ¥Â¢ô
        function addOutdoorInternalWalls(size) {
            // Âú®Â§ñÂú∫Âå∫ÂüüÊ∑ªÂä†‰∏Ä‰∫õÂÜÖÈÉ®Âõ¥Â¢ôÔºåÂàõÈÄ†ÊàòÊúØÊé©‰Ωì
            const wallCount = Math.floor(size * 0.5); // Ê†πÊçÆÂú∞ÂõæÂ§ßÂ∞èÂÜ≥ÂÆöÂõ¥Â¢ôÊï∞ÈáèÔºåÊîØÊåÅÊõ¥Â§ßÂú∞Âõæ
            
            for (let i = 0; i < wallCount; i++) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // ÈöèÊú∫ÈÄâÊã©Âõ¥Â¢ôÊñπÂêëÔºàÊ∞¥Âπ≥ÊàñÂûÇÁõ¥Ôºâ
                    const isHorizontal = Math.random() > 0.5;
                    const wallLength = 3 + Math.floor(Math.random() * 4); // 3-6Ê†ºÈïø
                    
                    if (isHorizontal) {
                        // ÂàõÂª∫Ê∞¥Âπ≥Âõ¥Â¢ô
                        let canPlace = true;
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx >= size || 
                                !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                                mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dx = 0; dx < wallLength; dx++) {
                                if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                    mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    } else {
                        // ÂàõÂª∫ÂûÇÁõ¥Âõ¥Â¢ô
                        let canPlace = true;
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dy = 0; dy < wallLength; dy++) {
                                if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                    mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    }
                }
            }
            
            // Ê∑ªÂä†LÂΩ¢Âõ¥Â¢ôÔºàËßíËêΩÊé©‰ΩìÔºâ
            addOutdoorCornerWalls(size);
        }
        
        // Ê∑ªÂä†Â§ñÂú∫ËßíËêΩÂõ¥Â¢ô
        function addOutdoorCornerWalls(size) {
            const cornerCount = Math.floor(size * 0.2); // ËßíËêΩÂõ¥Â¢ôÊï∞ÈáèÔºåÊîØÊåÅÊõ¥Â§ßÂú∞Âõæ
            
            for (let i = 0; i < cornerCount; i++) {
                const x = Math.floor(Math.random() * (size - 6)) + 3;
                const y = Math.floor(Math.random() * (size - 6)) + 3;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // Ê£ÄÊü•Âë®Âõ¥ÊòØÂê¶ÊúâË∂≥Â§üÁ©∫Èó¥ÂàõÂª∫LÂΩ¢Âõ¥Â¢ô
                    const wallLength = 3;
                    let canPlace = true;
                    
                    // Ê£ÄÊü•Ê∞¥Âπ≥ÊÆµ
                    for (let dx = 0; dx < wallLength; dx++) {
                        if (x + dx >= size || 
                            !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                            mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    // Ê£ÄÊü•ÂûÇÁõ¥ÊÆµ
                    if (canPlace) {
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                    }
                    
                    if (canPlace) {
                        // ÂàõÂª∫LÂΩ¢Âõ¥Â¢ô
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                            }
                        }
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // ÁîüÊàêÈ´ò‰ΩéÂ∑ÆÂå∫Âüü - Êï¥ÊÆµÈÅìË∑ØÂçáÈ´òÊàñÈôç‰Ωé
        function generateElevationAreas(size, floor) {
            const elevation = parseInt(document.getElementById('elevation').value);
            if (elevation === 0) return; // Êó†È´ò‰ΩéÂ∑Æ
            
            // ÊâæÂà∞ÊâÄÊúâËøûÁª≠ÁöÑÈÅìË∑ØÊÆµ
            const roadSegments = findRoadSegments(size, floor);
            
            // Ê†πÊçÆÈ´ò‰ΩéÂ∑ÆËÆæÁΩÆÂÜ≥ÂÆöË¶ÅÊîπÂèòÁöÑÈÅìË∑ØÊÆµÊï∞Èáè
            const elevationIntensity = elevation * 0.4; // 0.4 = 40%ÁöÑÈÅìË∑ØÊÆµ‰ºöÊúâÈ´ò‰ΩéÂ∑Æ
            const segmentsToElevate = Math.floor(roadSegments.length * elevationIntensity);
            
            // ÈöèÊú∫ÈÄâÊã©ÈÅìË∑ØÊÆµËøõË°åÈ´ò‰ΩéÂ∑ÆÂ§ÑÁêÜ
            const shuffledSegments = [...roadSegments].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < Math.min(segmentsToElevate, shuffledSegments.length); i++) {
                const segment = shuffledSegments[i];
                const isHighGround = Math.random() > 0.5; // 50%Ê¶ÇÁéáÊòØÈ´òÂú∞Ôºå50%Ê¶ÇÁéáÊòØ‰ΩéÂú∞
                
                // Â∞ÜÊï¥‰∏™ÈÅìË∑ØÊÆµÊ†áËÆ∞‰∏∫È´òÂú∞Êàñ‰ΩéÂú∞
                for (const point of segment) {
                    if (mapFloors[floor][point.y][point.x] === TileType.FLOOR) {
                        mapFloors[floor][point.y][point.x] = isHighGround ? TileType.HIGH_GROUND : TileType.LOW_GROUND;
                    }
                }
            }
            
            // Â∞ÜÂâ©‰ΩôÁöÑÂú∞ÊùøÂíåÈÅìË∑ØÂå∫ÂüüÊ†áËÆ∞‰∏∫‰∏≠Á≠âÂú∞
            markMediumGround(size, floor);
        }
        
        // ÊâæÂà∞ËøûÁª≠ÁöÑÈÅìË∑ØÊÆµ
        function findRoadSegments(size, floor) {
            const visited = Array(size).fill().map(() => Array(size).fill(false));
            const segments = [];
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (!visited[y][x] && 
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        const segment = [];
                        floodFillRoad(x, y, size, floor, visited, segment);
                        
                        // Âè™‰øùÁïôË∂≥Â§üÂ§ßÁöÑÈÅìË∑ØÊÆµÔºàËá≥Â∞ë5‰∏™ËøûÁª≠ÁÇπÔºâ
                        if (segment.length >= 5) {
                            segments.push(segment);
                        }
                    }
                }
            }
            
            return segments;
        }
        
        // Ê¥™Ê∞¥Â°´ÂÖÖÁÆóÊ≥ïÊâæÂà∞ËøûÁª≠ÁöÑÈÅìË∑ØÊÆµ
        function floodFillRoad(x, y, size, floor, visited, segment) {
            if (x < 0 || x >= size || y < 0 || y >= size || 
                visited[y][x] || 
                !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined ||
                mapFloors[floor][y][x] !== TileType.FLOOR) {
                return;
            }
            
            visited[y][x] = true;
            segment.push({x, y});
            
            // ÂêëÂõõ‰∏™ÊñπÂêëÊâ©Â±ï
            floodFillRoad(x + 1, y, size, floor, visited, segment);
            floodFillRoad(x - 1, y, size, floor, visited, segment);
            floodFillRoad(x, y + 1, size, floor, visited, segment);
            floodFillRoad(x, y - 1, size, floor, visited, segment);
        }
        
        // ÂàõÂª∫È´ò‰ΩéÂ∑ÆÂå∫Âüü
        function createElevationArea(centerX, centerY, size, elevationType, floor) {
            const halfSize = Math.floor(size / 2);
            
            for (let y = centerY - halfSize; y <= centerY + halfSize; y++) {
                for (let x = centerX - halfSize; x <= centerX + halfSize; x++) {
                    if (x >= 0 && x < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length &&
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        
                        // Âè™ÂØπÂú∞Èù¢ÂíåÈÅìË∑ØÂ∫îÁî®È´ò‰ΩéÂ∑Æ
                        if (mapFloors[floor][y][x] === TileType.FLOOR) {
                            mapFloors[floor][y][x] = elevationType;
                        }
                    }
                }
            }
        }
        
        // Ê†áËÆ∞‰∏≠Á≠âÂú∞
        function markMediumGround(size, floor) {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // Âè™ÂØπÂú∞Èù¢ÂíåÈÅìË∑ØÊ†áËÆ∞‰∏∫‰∏≠Á≠âÂú∞Ôºå‰øùÊåÅÂÖ∂‰ªñÂÖÉÁ¥†‰∏çÂèò
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        mapFloors[floor][y][x] = TileType.MEDIUM_GROUND;
                    }
                }
            }
        }
        
        // Ê∑ªÂä†Â§ñÂú∫ÈÅìË∑Ø
        function addOutdoorPaths(size) {
            // Âú®Â§ñÂú∫Âå∫Âüü‰πãÈó¥ÂàõÂª∫ËßÑÂàôÁöÑÈÅìË∑ØËøûÊé•
            const pathCount = Math.floor(size / 20) + Math.floor(Math.random() * 5); // Ê†πÊçÆÂú∞ÂõæÂ§ßÂ∞èË∞ÉÊï¥ÈÅìË∑ØÊï∞Èáè
            
            for (let i = 0; i < pathCount; i++) {
                // ÊâæÂà∞‰∏§‰∏™Â§ñÂú∫Âå∫ÂüüÁöÑ‰∏≠ÂøÉÁÇπ
                let outdoorAreas = [];
                
                // Êâ´ÊèèÂ§ñÂú∫Âå∫Âüü
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                            mapFloors[0][y][x] === TileType.OUTDOOR) {
                            // Ê£ÄÊü•ÊòØÂê¶ÊòØÊñ∞Âå∫ÂüüÁöÑ‰∏≠ÂøÉ
                            let isCenter = true;
                            for (let dy = -3; dy <= 3; dy++) {
                                for (let dx = -3; dx <= 3; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < size && nx >= 0 && nx < size &&
                                        mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined) {
                                        if (mapFloors[0][ny][nx] !== TileType.OUTDOOR && 
                                            mapFloors[0][ny][nx] !== TileType.OUTDOOR_COVER) {
                                            isCenter = false;
                                        }
                                    }
                                }
                            }
                            if (isCenter) {
                                outdoorAreas.push({x, y});
                            }
                        }
                    }
                }
                
                // ËøûÊé•‰∏çÂêåÁöÑÂ§ñÂú∫Âå∫Âüü
                if (outdoorAreas.length >= 2) {
                    const area1 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    let area2;
                    do {
                        area2 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    } while (area2 === area1);
                    
                    // ÂàõÂª∫Áõ¥Á∫øÈÅìË∑ØËøûÊé•
                    createStraightPath(area1.x, area1.y, area2.x, area2.y);
                }
            }
        }
        
        // ÂàõÂª∫ÈÅìË∑ØÔºàÁõ¥Á∫øÔºâ
        function createStraightPath(x1, y1, x2, y2) {
            
            // Áõ¥Á∫øÈÅìË∑Ø
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // ÂàõÂª∫ÈÅìË∑ØÔºà2Ê†ºÂÆΩÔºâ
                for (let w = -1; w <= 1; w++) {
                    for (let h = -1; h <= 1; h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[0][0].length && 
                            ny >= 0 && ny < mapFloors[0].length) {
                            if (mapFloors[0][ny][nx] === TileType.OUTDOOR) {
                                mapFloors[0][ny][nx] = TileType.FLOOR; // ÈÅìË∑Ø‰ΩøÁî®Âú∞ÊùøÁ±ªÂûã
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        

        
        // Âú®ÊàøÈó¥Âë®Âõ¥Ê∑ªÂä†ÁºìÂÜ≤Âå∫ÔºàÁ°Æ‰øùÁã¨Á´ãÊÄßÔºâ
        function addRoomBuffer(x, y, width, height, floor, size, minSpacing) {
            // Âú®ÊàøÈó¥Âë®Âõ¥ÂàõÂª∫ÁºìÂÜ≤Âå∫ÔºåÁ°Æ‰øùÊàøÈó¥‰πãÈó¥ÊúâË∂≥Â§üÁ©∫Èó¥
            for (let by = y - minSpacing; by < y + height + minSpacing; by++) {
                for (let bx = x - minSpacing; bx < x + width + minSpacing; bx++) {
                    if (bx >= 0 && bx < size && by >= 0 && by < size) {
                        // Â¶ÇÊûúÁºìÂÜ≤Âå∫‰ΩçÁΩÆÊòØÁ©∫Âú∞Ôºå‰øùÊåÅ‰∏∫Á©∫Âú∞
                        if (mapFloors[floor][by][bx] === TileType.VOID) {
                            // ‰øùÊåÅ‰∏∫Á©∫Âú∞Ôºå‰∏çÊ∑ªÂä†‰ªª‰ΩïË£ÖÈ•∞
                        }
                    }
                }
            }
        }
        
        // Ê£ÄÊü•ÊòØÂê¶ÈÇªÊé•Â§ñÂú∫
        function isAdjacentToOutdoor(x, y, floor) {
            if (floor !== 0) return false;
            
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                    return true;
                }
            }
            return false;
        }
        
        // ËøûÊé•ÊàøÈó¥ÔºàÊîπËøõÁâàÔºöÈöèÊú∫Ëµ∞ÂªäÂÆΩÂ∫¶ÔºåÁ°Æ‰øùÊâÄÊúâÊàøÈó¥ËøûÈÄöÔºâ
        function connectRooms(rooms, floor, baseCorridorWidth) {
            if (rooms.length < 2) return;
            
            const corridorMode = document.getElementById('corridorRandom').value;
            
            // ‰ΩøÁî®ÊúÄÂ∞èÁîüÊàêÊ†ëÁÆóÊ≥ïÁ°Æ‰øùÊâÄÊúâÊàøÈó¥ËøûÈÄö
            const connected = new Set([0]); // ‰ªéÁ¨¨‰∏Ä‰∏™ÊàøÈó¥ÂºÄÂßã
            const unconnected = new Set();
            for (let i = 1; i < rooms.length; i++) {
                unconnected.add(i);
            }
            
            // ËøûÊé•ÊâÄÊúâÊàøÈó¥
            while (unconnected.size > 0) {
                let minDist = Infinity;
                let bestConnected = -1;
                let bestUnconnected = -1;
                
                // ÊâæÂà∞ÊúÄËøëÁöÑÊú™ËøûÊé•ÊàøÈó¥ÂØπ
                for (let c of connected) {
                    for (let u of unconnected) {
                        const room1 = rooms[c];
                        const room2 = rooms[u];
                        const dist = Math.abs(room1.x + room1.width/2 - room2.x - room2.width/2) + 
                                   Math.abs(room1.y + room1.height/2 - room2.y - room2.height/2);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            bestConnected = c;
                            bestUnconnected = u;
                        }
                    }
                }
                
                if (bestConnected !== -1 && bestUnconnected !== -1) {
                    // Ê†πÊçÆÊ®°ÂºèÂÜ≥ÂÆöËµ∞ÂªäÂÆΩÂ∫¶
                    let corridorWidth = baseCorridorWidth;
                    if (corridorMode === 'random') {
                        corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                    } else if (corridorMode === 'varied') {
                        corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                    } else {
                        corridorWidth = baseCorridorWidth + 1;
                    }
                    
                    // ÂàõÂª∫Ëµ∞ÂªäËøûÊé•‰∏§‰∏™ÊàøÈó¥
                    createCorridorBetweenRooms(rooms[bestConnected], rooms[bestUnconnected], floor, corridorWidth);
                    
                    // Â∞ÜÊàøÈó¥Ê†áËÆ∞‰∏∫Â∑≤ËøûÊé•
                    connected.add(bestUnconnected);
                    unconnected.delete(bestUnconnected);
                }
            }
            
            // Ê∑ªÂä†È¢ùÂ§ñÁöÑËøûÊé•Â¢ûÂä†Ë∑ØÁ∫øÂ§öÊ†∑ÊÄßÔºà20%Ê¶ÇÁéáÔºåÂáèÂ∞ëËøáÂ∫¶ËøûÊé•Ôºâ
            for (let i = 0; i < rooms.length; i++) {
                for (let j = i + 1; j < rooms.length; j++) {
                    if (Math.random() < 0.2) {
                        let corridorWidth = baseCorridorWidth;
                        if (corridorMode === 'random') {
                            corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                        } else if (corridorMode === 'varied') {
                            corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                        }
                        createCorridorBetweenRooms(rooms[i], rooms[j], floor, corridorWidth);
                    }
                }
                    }
        
        // Ê∏ÖÁêÜÂ≠§Á´ãÁöÑÊàøÈó¥ÔºàÁ°Æ‰øùÊâÄÊúâÊàøÈó¥ÈÉΩÂèØËææÔºâ
        function cleanupIsolatedRooms(rooms, floor) {
            // Ê£ÄÊü•ÊØè‰∏™ÊàøÈó¥ÊòØÂê¶ÈÉΩÊúâÈó®Êàñ‰∏éËµ∞ÂªäËøûÊé•
            for (let room of rooms) {
                let hasAccess = false;
                
                // Ê£ÄÊü•ÊàøÈó¥ËæπÁïåÊòØÂê¶ÊúâÂºÄÂè£
                const directions = [
                    { x: room.x - 1, y: room.y + Math.floor(room.height / 2) }, // Â∑¶
                    { x: room.x + room.width, y: room.y + Math.floor(room.height / 2) }, // Âè≥
                    { x: room.x + Math.floor(room.width / 2), y: room.y - 1 }, // ‰∏ä
                    { x: room.x + Math.floor(room.width / 2), y: room.y + room.height } // ‰∏ã
                ];
                
                for (let dir of directions) {
                    if (dir.x >= 0 && dir.x < mapFloors[floor][0].length && 
                        dir.y >= 0 && dir.y < mapFloors[floor].length) {
                        if (mapFloors[floor][dir.y][dir.x] === TileType.FLOOR) {
                            hasAccess = true;
                            break;
                        }
                    }
                }
                
                // Â¶ÇÊûúÊ≤°ÊúâËÆøÈóÆË∑ØÂæÑÔºåÂàõÂª∫‰∏Ä‰∏™Èó®
                if (!hasAccess) {
                    createRoomDoor(room, floor);
                }
            }
        }
        
        // ‰∏∫ÊàøÈó¥ÂàõÂª∫Èó®
        function createRoomDoor(room, floor) {
            // ÈöèÊú∫ÈÄâÊã©‰∏ÄÈù¢Â¢ôÂàõÂª∫Èó®
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0 }, // Â∑¶
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0 }, // Âè≥
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1 }, // ‰∏ä
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1 } // ‰∏ã
            ];
            
            const side = sides[Math.floor(Math.random() * sides.length)];
            
            // ÂàõÂª∫Èó®
            if (side.x >= 0 && side.x < mapFloors[floor][0].length && 
                side.y >= 0 && side.y < mapFloors[floor].length) {
                mapFloors[floor][side.y][side.x] = TileType.FLOOR;
                
                // ÂàõÂª∫Èó®Â§ñÁöÑËµ∞Âªä
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        mapFloors[floor][corridorY][corridorX] = TileType.FLOOR;
                    }
                    }
                }
            }
            
            // Á°Æ‰øùÊØè‰∏™ÊàøÈó¥ÈÉΩÊúâÈó®
            ensureRoomDoors(rooms, floor);
            
            // Ê∑ªÂä†Ëµ∞ÂªäÂ¢ôÂ£Å
            addCorridorWalls(floor);
            
            // Ê∏ÖÁêÜÂ≠§Á´ãÁöÑÊàøÈó¥ÔºàÁ°Æ‰øùÊâÄÊúâÊàøÈó¥ÈÉΩÂèØËææÔºâ
            cleanupIsolatedRooms(rooms, floor);
        }
        
        // ÂàõÂª∫‰∏§‰∏™ÊàøÈó¥‰πãÈó¥ÁöÑËµ∞ÂªäÔºàÊîØÊåÅÊõ≤ÊäòÂ∫¶ÂíåÂºØÊõ≤Â∫¶Ôºâ
        function createCorridorBetweenRooms(room1, room2, floor, width) {
            const x1 = Math.floor(room1.x + room1.width / 2);
            const y1 = Math.floor(room1.y + room1.height / 2);
            const x2 = Math.floor(room2.x + room2.width / 2);
            const y2 = Math.floor(room2.y + room2.height / 2);
            
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            switch(pathComplexity) {
                case 0: // Áõ¥Á∫ø
                    createStraightCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 1: // ÂæÆÂºØ
                    createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 2: // ‰∏≠Á≠âÔºàLÂΩ¢Ôºâ
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 3: // Êõ≤Êäò
                    createZigzagCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 4: // Ëø∑ÂÆ´
                    createMazeLikeCorridor(x1, y1, x2, y2, floor, width);
                    break;
                default:
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
            }
        }
        
        // Áõ¥Á∫øËµ∞ÂªäÔºàÊúÄÁü≠Ë∑ØÂæÑÔºâ
        function createStraightCorridor(x1, y1, x2, y2, floor, width) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // ÁªòÂà∂ÂÆΩÂ∫¶ÁöÑËµ∞Âªä
                for (let w = -Math.floor(width/2); w <= Math.floor(width/2); w++) {
                    for (let h = -Math.floor(width/2); h <= Math.floor(width/2); h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[floor][0].length && 
                            ny >= 0 && ny < mapFloors[floor].length) {
                            if (mapFloors[floor][ny][nx] === TileType.VOID || 
                                mapFloors[floor][ny][nx] === TileType.WALL) {
                                mapFloors[floor][ny][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        
        // ÂæÆÂºØËµ∞ÂªäÔºàÂ∏¶Â∞èÂºßÂ∫¶Ôºâ
        function createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width) {
            
            const midX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 6) - 3;
            const midY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 6) - 3;
            
            createStraightCorridor(x1, y1, midX, midY, floor, width);
            createStraightCorridor(midX, midY, x2, y2, floor, width);
        }
        
        // LÂΩ¢Ëµ∞ÂªäÔºàÁªèÂÖ∏90Â∫¶ËΩ¨ÂºØÔºâ
        function createLShapedCorridor(x1, y1, x2, y2, floor, width) {
            if (Math.random() > 0.5) {
                // ÂÖàÊ∞¥Âπ≥ÂêéÂûÇÁõ¥
                createHorizontalCorridor(x1, x2, y1, floor, width);
                createVerticalCorridor(x2, y1, y2, floor, width);
            } else {
                // ÂÖàÂûÇÁõ¥ÂêéÊ∞¥Âπ≥
                createVerticalCorridor(x1, y1, y2, floor, width);
                createHorizontalCorridor(x1, x2, y2, floor, width);
            }
        }
        
        // Êõ≤ÊäòËµ∞ÂªäÔºàÂ§ö‰∏™ËΩ¨ÂºØÔºâ
        function createZigzagCorridor(x1, y1, x2, y2, floor, width) {
            // Ê£ÄÊü•Êõ≤ÊäòÂ∫¶ËÆæÁΩÆ
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // Â¶ÇÊûúÊõ≤ÊäòÂ∫¶‰∏∫0ÔºàÁõ¥Á∫øÔºâÔºåÂàô‰ΩøÁî®Áõ¥Á∫øËµ∞Âªä
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // ËæπÁïåÊ£ÄÊü•
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            const points = [];
            points.push({x: x1, y: y1});
            
            // Ê∑ªÂä†2-3‰∏™‰∏≠Èó¥ÁÇπ
            const numPoints = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                // Ê∑ªÂä†ÈöèÊú∫ÂÅèÁßªÔºàÁ°Æ‰øùÂú®ËæπÁïåÂÜÖÔºâ
                const offsetX = Math.floor(Math.random() * 10) - 5;
                const offsetY = Math.floor(Math.random() * 10) - 5;
                
                points.push({
                    x: Math.max(1, Math.min(Math.floor(baseX + offsetX), mapWidth - 2)),
                    y: Math.max(1, Math.min(Math.floor(baseY + offsetY), mapHeight - 2))
                });
            }
            
            points.push({x: x2, y: y2});
            
            // ËøûÊé•ÊâÄÊúâÁÇπ
            for (let i = 0; i < points.length - 1; i++) {
                if (i % 2 === 0) {
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i].y, floor, width);
                    createVerticalCorridor(points[i+1].x, points[i].y, points[i+1].y, floor, width);
                } else {
                    createVerticalCorridor(points[i].x, points[i].y, points[i+1].y, floor, width);
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i+1].y, floor, width);
                }
            }
        }
        
        // Ëø∑ÂÆ´ÂºèËµ∞ÂªäÔºàÂ§çÊùÇË∑ØÂæÑÔºâ
        function createMazeLikeCorridor(x1, y1, x2, y2, floor, width) {
            // Ê£ÄÊü•Êõ≤ÊäòÂ∫¶ËÆæÁΩÆ
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // Â¶ÇÊûúÊõ≤ÊäòÂ∫¶‰∏∫0ÔºàÁõ¥Á∫øÔºâÔºåÂàô‰ΩøÁî®Áõ¥Á∫øËµ∞Âªä
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // ËæπÁïåÊ£ÄÊü•
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            x1 = Math.max(1, Math.min(x1, mapWidth - 2));
            y1 = Math.max(1, Math.min(y1, mapHeight - 2));
            x2 = Math.max(1, Math.min(x2, mapWidth - 2));
            y2 = Math.max(1, Math.min(y2, mapHeight - 2));
            
            // ÂàõÂª∫‰∏ªË∑ØÂæÑ
            createZigzagCorridor(x1, y1, x2, y2, floor, width);
            
            // Ê∑ªÂä†1-2Êù°È¢ùÂ§ñË∑ØÂæÑ
            const extraPaths = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < extraPaths; i++) {
                // ÂàõÂª∫ÂÅèÁßªËµ∑ÁÇπÂíåÁªàÁÇπÔºàÁ°Æ‰øùÂú®ËæπÁïåÂÜÖÔºâ
                const offsetX1 = Math.max(1, Math.min(x1 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY1 = Math.max(1, Math.min(y1 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                const offsetX2 = Math.max(1, Math.min(x2 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY2 = Math.max(1, Math.min(y2 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                
                // ‰ΩøÁî®ËæÉÁ™ÑÁöÑÂÆΩÂ∫¶
                const narrowWidth = Math.max(1, width - 1);
                
                // ÈöèÊú∫ÈÄâÊã©Ë∑ØÂæÑÁ±ªÂûã
                if (Math.random() > 0.5) {
                    createLShapedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                } else {
                    createSlightlyCurvedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                }
            }
            
            // Ê∑ªÂä†‰∏Ä‰∫õËøûÊé•Ê®™ÈÅì
            const crossPaths = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < crossPaths; i++) {
                const crossX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossLength = 5 + Math.floor(Math.random() * 10);
                
                if (Math.random() > 0.5) {
                    // Ê∞¥Âπ≥Ê®™ÈÅì
                    const startX = Math.max(0, crossX - Math.floor(crossLength/2));
                    const endX = Math.min(mapWidth - 1, crossX + Math.floor(crossLength/2));
                    
                    if (crossY >= 0 && crossY < mapHeight) {
                        for (let x = startX; x <= endX; x++) {
                            if (mapFloors[floor][crossY][x] === TileType.VOID) {
                                mapFloors[floor][crossY][x] = TileType.FLOOR;
                            }
                        }
                    }
                } else {
                    // ÂûÇÁõ¥Ê®™ÈÅì
                    const startY = Math.max(0, crossY - Math.floor(crossLength/2));
                    const endY = Math.min(mapHeight - 1, crossY + Math.floor(crossLength/2));
                    
                    if (crossX >= 0 && crossX < mapWidth) {
                        for (let y = startY; y <= endY; y++) {
                            if (mapFloors[floor][y][crossX] === TileType.VOID) {
                                mapFloors[floor][y][crossX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        

        
        // ÂàõÂª∫Ê∞¥Âπ≥Ëµ∞Âªä
        function createHorizontalCorridor(x1, x2, y, floor, width) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const halfWidth = Math.floor(width / 2);
            
            for (let x = minX; x <= maxX; x++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const ny = y + w;
                    if (ny >= 0 && ny < mapFloors[floor].length && 
                        x >= 0 && x < mapFloors[floor][0].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                            if (mapFloors[floor][ny][x] === TileType.VOID || 
                                mapFloors[floor][ny][x] === TileType.WALL) {
                                mapFloors[floor][ny][x] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // ÂàõÂª∫ÂûÇÁõ¥Ëµ∞Âªä
        function createVerticalCorridor(x, y1, y2, floor, width) {
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            const halfWidth = Math.floor(width / 2);
            
            for (let y = minY; y <= maxY; y++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const nx = x + w;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length) {
                        if (mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                            if (mapFloors[floor][y][nx] === TileType.VOID || 
                                mapFloors[floor][y][nx] === TileType.WALL) {
                                mapFloors[floor][y][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // Á°Æ‰øùÊØè‰∏™ÊàøÈó¥ÈÉΩÊúâËá≥Â∞ë‰∏Ä‰∏™Èó®
        function ensureRoomDoors(rooms, floor) {
            for (let room of rooms) {
                let hasDoor = false;
                
                // Ê£ÄÊü•ÊàøÈó¥ËæπÁïåÊòØÂê¶ÊúâÂºÄÂè£
                // ‰∏äËæπ
                for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                    if (mapFloors[floor][room.y][x] === TileType.FLOOR) {
                        hasDoor = true;
                        break;
                    }
                }
                
                // ‰∏ãËæπ
                if (!hasDoor) {
                    for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                        if (mapFloors[floor][room.y + room.height - 1][x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // Â∑¶Ëæπ
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // Âè≥Ëæπ
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x + room.width - 1] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // Â¶ÇÊûúÊ≤°ÊúâÈó®ÔºåÂàõÂª∫‰∏Ä‰∏™
                if (!hasDoor) {
                    // ÈöèÊú∫ÈÄâÊã©‰∏ÄÈù¢Â¢ôÂàõÂª∫Èó®
                    const side = Math.floor(Math.random() * 4);
                    const doorWidth = 2; // Èó®ÁöÑÂÆΩÂ∫¶
                    
                    switch(side) {
                        case 0: // ‰∏ä
                            const topX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (topX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y][topX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 1: // ‰∏ã
                            const bottomX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (bottomX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y + room.height - 1][bottomX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 2: // Â∑¶
                            const leftY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (leftY + i < room.y + room.height - 1) {
                                    mapFloors[floor][leftY + i][room.x] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 3: // Âè≥
                            const rightY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (rightY + i < room.y + room.height - 1) {
                                    mapFloors[floor][rightY + i][room.x + room.width - 1] = TileType.FLOOR;
                                }
                            }
                            break;
                    }
                }
            }
        }
        
        // Ê∑ªÂä†Ëµ∞ÂªäÂ¢ôÂ£Å
        function addCorridorWalls(floor) {
            const tempMap = JSON.parse(JSON.stringify(mapFloors[floor]));
            
            for (let y = 1; y < mapFloors[floor].length - 1; y++) {
                for (let x = 1; x < mapFloors[floor][0].length - 1; x++) {
                    if (tempMap[y][x] === TileType.FLOOR || 
                        tempMap[y][x] === TileType.MEDIUM_GROUND ||
                        tempMap[y][x] === TileType.HIGH_GROUND ||
                        tempMap[y][x] === TileType.LOW_GROUND ||
                        tempMap[y][x] === TileType.T_SPAWN ||
                        tempMap[y][x] === TileType.CT_SPAWN ||
                        tempMap[y][x] === TileType.BOMBSITE_A ||
                        tempMap[y][x] === TileType.BOMBSITE_B) {
                        
                        // Ê£ÄÊü•Âõõ‰∏™ÊñπÂêë
                        const directions = [[-1, 0], [0, -1], [0, 1], [1, 0]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < mapFloors[floor].length && 
                                nx >= 0 && nx < mapFloors[floor][0].length) {
                                if (tempMap[ny][nx] === TileType.VOID && 
                                    mapFloors[floor][ny][nx] === TileType.VOID) {
                                    mapFloors[floor][ny][nx] = TileType.WALL;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Ê∑ªÂä†Ê•ºÊ¢ØÔºàÊîπËøõÁâàÔºöÁ°Æ‰øù‰∏éÈÅìË∑ØËøûÊé•Ôºâ
        function addStairs(rooms, stairsCount) {
            if (totalFloors <= 1) return;
            
            // ‰∏∫ÊØèÂØπÁõ∏ÈÇªÊ•ºÂ±ÇÂàõÂª∫Ê•ºÊ¢Ø
            for (let floor = 0; floor < totalFloors - 1; floor++) {
                let stairsPlaced = 0;
                
                // Êî∂ÈõÜÊâÄÊúâÈÅìË∑Ø‰ΩçÁΩÆ
                const roadPositions = [];
                for (let y = 0; y < mapFloors[floor].length; y++) {
                    for (let x = 0; x < mapFloors[floor][0].length; x++) {
                        if (mapFloors[floor][y][x] === TileType.FLOOR ||
                            mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][x] === TileType.LOW_GROUND) {
                            roadPositions.push({ x, y });
                        }
                    }
                }
                
                // Â¶ÇÊûúÊ≤°ÊúâÈÅìË∑ØÔºå‰ΩøÁî®ÈªòËÆ§‰ΩçÁΩÆ
                if (roadPositions.length === 0) {
                    roadPositions.push(
                        { x: Math.floor(mapFloors[0][0].length / 2), y: Math.floor(mapFloors[0].length / 2) }
                    );
                }
                
                // Êâì‰π±ÈÅìË∑Ø‰ΩçÁΩÆÈ°∫Â∫è
                roadPositions.sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < Math.min(stairsCount, roadPositions.length); i++) {
                    const roadPos = roadPositions[i];
                    
                    // Âú®ÈÅìË∑ØÈôÑËøëÂØªÊâæÂêàÈÄÇÁöÑ‰ΩçÁΩÆ
                    let found = false;
                    for (let dy = -3; dy <= 3 && !found; dy++) {
                        for (let dx = -3; dx <= 3 && !found; dx++) {
                            const x = roadPos.x + dx;
                            const y = roadPos.y + dy;
                            
                            // Ê£ÄÊü•‰ΩçÁΩÆÊòØÂê¶ÊúâÊïàÔºà2x2Âå∫ÂüüÔºâ
                            if (x >= 1 && x < mapFloors[0][0].length - 2 &&
                                y >= 1 && y < mapFloors[0].length - 2) {
                                
                                // Ê£ÄÊü•ÂΩìÂâçÂ±ÇÊòØÂê¶ÂèØ‰ª•ÊîæÁΩÆÊ•ºÊ¢Ø
                                let canPlaceLower = true;
                                let canPlaceUpper = true;
                                
                                for (let sy = 0; sy < 2; sy++) {
                                    for (let sx = 0; sx < 2; sx++) {
                                        // Ê£ÄÊü•‰∏ãÂ±Ç
                                        if (mapFloors[floor][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceLower = false;
                                        }
                                        // Ê£ÄÊü•‰∏äÂ±Ç
                                        if (mapFloors[floor + 1][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceUpper = false;
                                        }
                                    }
                                }
                                
                                // Ê£ÄÊü•ÊòØÂê¶‰∏éÈÅìË∑ØÁõ∏ÈÇª
                                let hasRoadAdjacent = false;
                                for (let sy = -1; sy <= 2; sy++) {
                                    for (let sx = -1; sx <= 2; sx++) {
                                        const nx = x + sx;
                                        const ny = y + sy;
                                        if (nx >= 0 && nx < mapFloors[floor][0].length &&
                                            ny >= 0 && ny < mapFloors[floor].length) {
                                            if (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                                mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.LOW_GROUND) {
                                                hasRoadAdjacent = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (hasRoadAdjacent) break;
                                }
                                
                                if ((canPlaceLower || canPlaceUpper) && hasRoadAdjacent) {
                                    // Âú®‰∏ãÂ±ÇÂàõÂª∫Âêë‰∏äÁöÑÊ•ºÊ¢Ø
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // Â¶ÇÊûúÊòØÁ©∫Âú∞ÔºåÂÖàÂàõÂª∫Âú∞Êùø
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // ÁÑ∂ÂêéËÆæÁΩÆ‰∏∫Ê•ºÊ¢ØÔºàÊîØÊåÅÊâÄÊúâÂú∞Èù¢Á±ªÂûãÔºâ
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.FLOOR ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.LOW_GROUND) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.STAIRS_UP;
                                            }
                                        }
                                    }
                                    
                                    // Âú®‰∏äÂ±ÇÁöÑÁõ∏Âêå‰ΩçÁΩÆÂàõÂª∫Âêë‰∏ãÁöÑÊ•ºÊ¢Ø
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // Â¶ÇÊûúÊòØÁ©∫Âú∞ÔºåÂÖàÂàõÂª∫Âú∞Êùø
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // ÁÑ∂ÂêéËÆæÁΩÆ‰∏∫Ê•ºÊ¢Ø
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.FLOOR) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.STAIRS_DOWN;
                                            }
                                        }
                                    }
                                    
                                    // Á°Æ‰øùÊ•ºÊ¢ØÂë®Âõ¥ÊúâÂ¢ôÂ£Å
                                    ensureStairWalls(x, y, floor);
                                    ensureStairWalls(x, y, floor + 1);
                                    
                                    stairsPlaced++;
                                    found = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Á°Æ‰øùÊ•ºÊ¢ØÂë®Âõ¥ÊúâÈÄÇÂΩìÁöÑÂ¢ôÂ£Å
        function ensureStairWalls(x, y, floor) {
            // Ê£ÄÊü•Ê•ºÊ¢ØÂë®Âõ¥3x3Âå∫Âüü
            for (let dy = -1; dy <= 2; dy++) {
                for (let dx = -1; dx <= 2; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // Ë∑≥ËøáÊ•ºÊ¢ØÊú¨Ë∫´Ôºà2x2‰∏≠ÂøÉÂå∫ÂüüÔºâ
                    if (dx >= 0 && dx <= 1 && dy >= 0 && dy <= 1) {
                        continue;
                    }
                    
                    // Â¶ÇÊûúÊòØËæπÁïå‰ΩçÁΩÆ‰∏îÊòØÁ©∫Âú∞ÔºåÊ∑ªÂä†Â¢ôÂ£Å
                    if (nx >= 0 && nx < mapFloors[floor][0].length &&
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny][nx] === TileType.VOID) {
                            // Ê£ÄÊü•ÊòØÂê¶‰∏éÈÅìË∑ØÁõ∏ÈÇªÔºåÂ¶ÇÊûúÊòØÂàô‰∏çÊ∑ªÂä†Â¢ôÂ£Å
                            let hasRoadAdjacent = false;
                            for (let sy = -1; sy <= 1; sy++) {
                                for (let sx = -1; sx <= 1; sx++) {
                                    const checkX = nx + sx;
                                    const checkY = ny + sy;
                                    if (checkX >= 0 && checkX < mapFloors[floor][0].length &&
                                        checkY >= 0 && checkY < mapFloors[floor].length) {
                                        if (mapFloors[floor][checkY][checkX] === TileType.FLOOR ||
                                            mapFloors[floor][checkY][checkX] === TileType.MEDIUM_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.HIGH_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.LOW_GROUND) {
                                            hasRoadAdjacent = true;
                                            break;
                                        }
                                    }
                                }
                                if (hasRoadAdjacent) break;
                            }
                            
                            // Âè™Âú®Ê≤°ÊúâÈÅìË∑ØÁõ∏ÈÇªÁöÑËæπÁºòÊ∑ªÂä†Â¢ôÂ£Å
                            if (!hasRoadAdjacent && (Math.abs(dx) === 1 || Math.abs(dy) === 1)) {
                                mapFloors[floor][ny][nx] = TileType.WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // ËøûÊé•Ê•ºÊ¢ØÂà∞ÊúÄËøëÁöÑÊàøÈó¥ÊàñËµ∞Âªä
        function connectStairToRooms(stairX, stairY, floor) {
            // Êü•ÊâæÊúÄËøëÁöÑÂú∞ÊùøÂå∫Âüü
            let nearestFloor = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_A ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_B) {
                        
                        const dist = Math.abs(x - stairX) + Math.abs(y - stairY);
                        if (dist < minDist && dist > 3) { // Ë∑ùÁ¶ªÂ§ß‰∫é3ÊâçÈúÄË¶ÅËøûÊé•
                            minDist = dist;
                            nearestFloor = { x, y };
                        }
                    }
                }
            }
            
            // Â¶ÇÊûúÊâæÂà∞‰∫ÜÈúÄË¶ÅËøûÊé•ÁöÑÂú∞ÊùøÔºåÂàõÂª∫Ëµ∞Âªä
            if (nearestFloor && minDist < 15) {
                createSimpleCorridor(stairX + 1, stairY + 1, nearestFloor.x, nearestFloor.y, floor);
            }
        }
        
        // ÂàõÂª∫ÁÆÄÂçïËµ∞ÂªäËøûÊé•‰∏§ÁÇπ
        function createSimpleCorridor(x1, y1, x2, y2, floor) {
            // ÂÖàÊ∞¥Âπ≥ÂêéÂûÇÁõ¥
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            
            // Ê∞¥Âπ≥ÊÆµ
            for (let x = minX; x <= maxX; x++) {
                if (mapFloors[floor][y1][x] === TileType.VOID) {
                    mapFloors[floor][y1][x] = TileType.FLOOR;
                }
                // Ê∑ªÂä†Â¢ôÂ£Å
                if (y1 > 0 && mapFloors[floor][y1 - 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 - 1][x] = TileType.WALL;
                }
                if (y1 < mapFloors[floor].length - 1 && mapFloors[floor][y1 + 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 + 1][x] = TileType.WALL;
                }
            }
            
            // ÂûÇÁõ¥ÊÆµ
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            for (let y = minY; y <= maxY; y++) {
                if (mapFloors[floor][y][x2] === TileType.VOID) {
                    mapFloors[floor][y][x2] = TileType.FLOOR;
                }
                // Ê∑ªÂä†Â¢ôÂ£Å
                if (x2 > 0 && mapFloors[floor][y][x2 - 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 - 1] = TileType.WALL;
                }
                if (x2 < mapFloors[floor][0].length - 1 && mapFloors[floor][y][x2 + 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 + 1] = TileType.WALL;
                }
            }
        }
        
        // Ê∑ªÂä†ÁâπÊÆäÂÖÉÁ¥†
        function addSpecialElements(rooms, coverDensity, waterAmount, windowDensity) {
            // ËÆæÁΩÆÂá∫ÁîüÁÇπÂíåÂåÖÁÇπ
            if (rooms.length >= 3) {
                const firstFloorRooms = rooms.filter(r => r.floor === 0);
                if (firstFloorRooms.length >= 3) {
                    // TÂá∫ÁîüÁÇπ
                    const tRoom = firstFloorRooms[0];
                    for (let y = tRoom.y + 1; y < tRoom.y + tRoom.height - 1; y++) {
                        for (let x = tRoom.x + 1; x < tRoom.x + tRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.T_SPAWN;
                            }
                        }
                    }
                    
                    // CTÂá∫ÁîüÁÇπ
                    const ctRoom = firstFloorRooms[firstFloorRooms.length - 1];
                    for (let y = ctRoom.y + 1; y < ctRoom.y + ctRoom.height - 1; y++) {
                        for (let x = ctRoom.x + 1; x < ctRoom.x + ctRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.CT_SPAWN;
                            }
                        }
                    }
                    
                    // ÁîüÊàêÂåÖÁÇπ
                    const bombSiteCount = parseInt(document.getElementById('bombSiteCount').value);
                    const availableRooms = firstFloorRooms.slice(2); // Ë∑≥ËøáÂá∫ÁîüÁÇπÊàøÈó¥
                    
                    // Á°Æ‰øùÊúâË∂≥Â§üÁöÑÊàøÈó¥
                    const maxBombSites = Math.min(bombSiteCount, availableRooms.length);
                    
                    for (let i = 0; i < maxBombSites; i++) {
                        const roomIndex = Math.floor((i + 1) * availableRooms.length / (maxBombSites + 1));
                        const bombRoom = availableRooms[roomIndex];
                        
                        if (bombRoom) {
                            const centerX = Math.floor(bombRoom.x + bombRoom.width / 2);
                            const centerY = Math.floor(bombRoom.y + bombRoom.height / 2);
                            
                            // Ê†πÊçÆÂåÖÁÇπÁ¥¢ÂºïÈÄâÊã©TileType
                            const bombSiteType = i === 0 ? TileType.BOMBSITE_A : 
                                               i === 1 ? TileType.BOMBSITE_B :
                                               i === 2 ? TileType.BOMBSITE_C :
                                               i === 3 ? TileType.BOMBSITE_D :
                                               TileType.BOMBSITE_E;
                            
                            // ÂàõÂª∫ÂåÖÁÇπÂå∫Âüü
                            for (let y = centerY - 2; y <= centerY + 2; y++) {
                                for (let x = centerX - 2; x <= centerX + 2; x++) {
                                    if (y > bombRoom.y && y < bombRoom.y + bombRoom.height - 1 &&
                                        x > bombRoom.x && x < bombRoom.x + bombRoom.width - 1) {
                                        if (mapFloors[0][y][x] === TileType.FLOOR || 
                                            mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                                            mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                                            mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                            mapFloors[0][y][x] = bombSiteType;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Ê∑ªÂä†Êé©‰ΩìÔºàÂè™ÁîüÊàêÂú®Èù†Â¢ôÊàñÈù†Èó®‰ΩçÁΩÆÔºåÊØèÊÆµÈÅìË∑ØÊúÄÂ§ö3‰∏™Ôºâ
            for (let floor = 0; floor < totalFloors; floor++) {
                // ÊâæÂà∞ÊâÄÊúâÈÅìË∑ØÊÆµ
                const roadSegments = findRoadSegments(mapFloors[floor][0].length, floor);
                
                // ‰∏∫ÊØè‰∏™ÈÅìË∑ØÊÆµÊ∑ªÂä†Êé©‰Ωì
                for (const segment of roadSegments) {
                    const maxCoversPerSegment = 3; // ÊØèÊÆµÈÅìË∑ØÊúÄÂ§ö3‰∏™Êé©‰Ωì
                    const segmentCoverCount = Math.min(
                        Math.floor(segment.length * coverDensity / 1000), 
                        maxCoversPerSegment
                    );
                    
                    let placedCount = 0;
                    let attempts = 0;
                    const maxAttempts = segment.length * 2; // ÈôêÂà∂Â∞ùËØïÊ¨°Êï∞
                    
                    // ÈöèÊú∫Êâì‰π±ÈÅìË∑ØÊÆµ‰∏≠ÁöÑÁÇπ
                    const shuffledPoints = [...segment].sort(() => Math.random() - 0.5);
                    
                    for (const point of shuffledPoints) {
                        if (placedCount >= segmentCoverCount || attempts >= maxAttempts) break;
                        
                        const x = point.x;
                        const y = point.y;
                        
                        if ((mapFloors[floor][y][x] === TileType.FLOOR || 
                             mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                             mapFloors[floor][y][x] === TileType.LOW_GROUND) && 
                            isNearWallOrDoor(x, y, floor)) {
                        mapFloors[floor][y][x] = TileType.COVER;
                            placedCount++;
                        }
                        attempts++;
                    }
                }
            }
            
            // Ê∑ªÂä†Ê∞¥ÂüüÔºàÂè™Âú®Á¨¨‰∏ÄÂ±ÇÔºâ- ‰ΩøÁî®Ê¥™Ê∞¥Â°´ÂÖÖÂàõÂª∫ËøûÁª≠Ê∞¥Âüü
            if (waterAmount > 0) {
                createWaterAreas(waterAmount);
            }
            
            // Ê∑ªÂä†Èò¥ÁÇπÔºàÂûÇÁõ¥Â∞èÂ¢ô‰ΩìÔºâ
            const shadowPointDensity = parseInt(document.getElementById('shadowPoint').value);
            if (shadowPointDensity > 0) {
                // Âú®ÊâÄÊúâÊ•ºÂ±ÇÊ∑ªÂä†Èò¥ÁÇπ
                for (let floor = 0; floor < totalFloors; floor++) {
                    addShadowPoints(shadowPointDensity, floor);
                }
            }
            
            // Ê∑ªÂä†Á™óÊà∑
            for (let floor = 0; floor < totalFloors; floor++) {
                const windowCount = Math.floor(mapFloors[floor].length * mapFloors[floor][0].length * windowDensity / 1000);
                for (let i = 0; i < windowCount; i++) {
                    const x = Math.floor(Math.random() * (mapFloors[floor][0].length - 2)) + 1;
                    const y = Math.floor(Math.random() * (mapFloors[floor].length - 2)) + 1;
                    if (mapFloors[floor][y][x] === TileType.WALL) {
                        // Ê£ÄÊü•ÊòØÂê¶ÂêàÈÄÇÊîæÁ™óÊà∑
                        let hasFloorNearby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                if (ny >= 0 && ny < mapFloors[floor].length && 
                                    nx >= 0 && nx < mapFloors[floor][0].length &&
                                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                                    (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                     mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                                    hasFloorNearby = true;
                                }
                            }
                        }
                        if (hasFloorNearby) {
                            mapFloors[floor][y][x] = TileType.WINDOW;
                        }
                    }
                }
            }
        }
        
        // Ê∏∏ÊàèÊ®°ÂºèÈÖçÁΩÆ
        const gameModes = {
            team: {
                name: "Âõ¢ÈòüÁ´ûÊäÄ",
                description: "Âõ¢ÈòüÁ´ûÊäÄÊ®°Âºè",
                spawnPoints: { t: 2, ct: 2 },
                objectives: ["elimination"],
                features: ["cover", "water", "stairs", "windows"]
            },
            bomb: {
                name: "ÁàÜÁ†¥Ê®°Âºè", 
                description: "ÁàÜÁ†¥Ê®°Âºè",
                spawnPoints: { t: 5, ct: 5 },
                objectives: ["bomb_a", "bomb_b"],
                features: ["cover", "water", "stairs", "windows", "bombsites"]
            },
            zombie: {
                name: "ÁîüÂåñÊ®°Âºè",
                description: "ÁîüÂåñÊ®°Âºè", 
                spawnPoints: { human: 8, zombie: 2 },
                objectives: ["survival"],
                features: ["cover", "water", "stairs", "windows", "safe_zones"]
            }
        };

        // Âú∞ÂõæÈ£éÊ†ºÈÖçÁΩÆ
        const mapStyles = {
            balanced: {
                name: "Âπ≥Ë°°Âûã",
                description: "Âπ≥Ë°°ÂûãÂú∞Âõæ",
                layout: "balanced",
                coverDensity: 1.0,
                waterAmount: 1.0,
                complexity: 1.0
            },
            ct_sided: {
                name: "CT‰ºòÂäø",
                description: "CT‰ºòÂäøÂú∞Âõæ",
                layout: "ct_sided", 
                coverDensity: 0.8,
                waterAmount: 1.2,
                complexity: 1.1
            },
            t_sided: {
                name: "T‰ºòÂäø",
                description: "T‰ºòÂäøÂú∞Âõæ",
                layout: "t_sided",
                coverDensity: 1.2,
                waterAmount: 0.8,
                complexity: 0.9
            },
            aim_heavy: {
                name: "Êû™Ê≥ïÂûã",
                description: "Êû™Ê≥ïÂûãÂú∞Âõæ",
                layout: "aim_heavy",
                coverDensity: 0.6,
                waterAmount: 0.5,
                complexity: 0.8
            },
            tactical: {
                name: "ÊàòÊúØÂûã",
                description: "ÊàòÊúØÂûãÂú∞Âõæ",
                layout: "tactical",
                coverDensity: 1.3,
                waterAmount: 1.1,
                complexity: 1.2
            },
            rush: {
                name: "Âø´ÊîªÂûã",
                description: "Âø´ÊîªÂûãÂú∞Âõæ",
                layout: "rush",
                coverDensity: 0.7,
                waterAmount: 0.6,
                complexity: 0.7
            },
            black_town: {
                name: "ÈªëËâ≤ÂüéÈïá",
                description: "ÈªëËâ≤ÂüéÈïáÈ£éÊ†º",
                layout: "urban",
                coverDensity: 1.1,
                waterAmount: 0.3,
                complexity: 1.0,
                theme: "dark_urban"
            },
            desert_gray: {
                name: "Ê≤ôÊº†ÁÅ∞",
                description: "Ê≤ôÊº†ÁÅ∞È£éÊ†º",
                layout: "desert",
                coverDensity: 0.8,
                waterAmount: 0.1,
                complexity: 0.9,
                theme: "desert"
            },
            new_year_plaza: {
                name: "Êñ∞Âπ¥ÂπøÂú∫",
                description: "Êñ∞Âπ¥ÂπøÂú∫È£éÊ†º",
                layout: "plaza",
                coverDensity: 1.0,
                waterAmount: 0.5,
                complexity: 1.1,
                theme: "festival"
            },
            white_house: {
                name: "ÁôΩÊàø",
                description: "ÁôΩÊàøÈ£éÊ†º",
                layout: "mansion",
                coverDensity: 1.2,
                waterAmount: 0.4,
                complexity: 1.3,
                theme: "luxury"
            },
            transport_ship: {
                name: "ËøêËæìËàπ",
                description: "ËøêËæìËàπÈ£éÊ†º",
                layout: "ship",
                coverDensity: 0.9,
                waterAmount: 0.8,
                complexity: 1.0,
                theme: "naval"
            },
            satellite_base: {
                name: "Âç´ÊòüÂü∫Âú∞",
                description: "Âç´ÊòüÂü∫Âú∞È£éÊ†º",
                layout: "military",
                coverDensity: 1.1,
                waterAmount: 0.2,
                complexity: 1.2,
                theme: "military"
            },
            harbor_dock: {
                name: "Ê∏ØÂè£Á†ÅÂ§¥",
                description: "Ê∏ØÂè£Á†ÅÂ§¥È£éÊ†º",
                layout: "harbor",
                coverDensity: 1.0,
                waterAmount: 1.5,
                complexity: 1.1,
                theme: "harbor"
            },
            subway_station: {
                name: "Âú∞ÈìÅÁ´ô",
                description: "Âú∞ÈìÅÁ´ôÈ£éÊ†º",
                layout: "underground",
                coverDensity: 1.3,
                waterAmount: 0.1,
                complexity: 1.4,
                theme: "underground"
            }
        };

        // Â∫îÁî®Ê∏∏ÊàèÊ®°ÂºèËÆæÁΩÆ
        function applyGameMode(gameMode) {
            const mode = gameModes[gameMode];
            if (!mode) return;
            
            // Êõ¥Êñ∞Âú∞ÂõæÊ†áÈ¢ò
            document.getElementById('mapName').textContent = mode.name + "Âú∞Âõæ";
            
            // Êõ¥Êñ∞Ê®°ÂºèÊèèËø∞
            const modeDescription = document.querySelector('.map-header div:last-child');
            if (modeDescription) {
                modeDescription.textContent = mode.description;
            }
            
            return mode;
        }

        // Â∫îÁî®Âú∞ÂõæÈ£éÊ†ºËÆæÁΩÆ
        function applyMapStyle(mapStyle) {
            const style = mapStyles[mapStyle];
            if (!style) return;
            
            // Ê†πÊçÆÈ£éÊ†ºË∞ÉÊï¥ÂèÇÊï∞
            const coverDensitySlider = document.getElementById('coverDensity');
            const waterAmountSlider = document.getElementById('waterAmount');
            const pathComplexitySlider = document.getElementById('pathComplexity');
            
            if (coverDensitySlider && style.coverDensity) {
                const currentValue = parseInt(coverDensitySlider.value);
                const newValue = Math.round(currentValue * style.coverDensity);
                coverDensitySlider.value = Math.min(100, Math.max(10, newValue));
                document.getElementById('coverValue').textContent = coverDensitySlider.value;
            }
            
            if (waterAmountSlider && style.waterAmount) {
                const currentValue = parseInt(waterAmountSlider.value);
                const newValue = Math.round(currentValue * style.waterAmount);
                waterAmountSlider.value = Math.min(50, Math.max(0, newValue));
                document.getElementById('waterValue').textContent = waterAmountSlider.value;
            }
            
            if (pathComplexitySlider && style.complexity) {
                const currentValue = parseInt(pathComplexitySlider.value);
                const newValue = Math.round(currentValue * style.complexity);
                pathComplexitySlider.value = Math.min(4, Math.max(0, newValue));
                document.getElementById('pathValue').textContent = getComplexityText(pathComplexitySlider.value);
            }
            
            return style;
        }

        // Ëé∑ÂèñÂ§çÊùÇÂ∫¶ÊñáÊú¨
        function getComplexityText(value) {
            const texts = ['ÁÆÄÂçï', 'ËæÉÁÆÄÂçï', '‰∏≠', 'ËæÉÂ§çÊùÇ', 'Â§çÊùÇ'];
            return texts[value] || '‰∏≠';
        }
        
        // ÁîüÊàêÂú∞Âõæ
        function generateMap() {
            // Ëé∑ÂèñÊ∏∏ÊàèÊ®°ÂºèÂíåÂú∞ÂõæÈ£éÊ†º
            const gameMode = document.getElementById('gameMode').value;
            const mapStyle = document.getElementById('mapStyle').value;
            
            // Â∫îÁî®Ê∏∏ÊàèÊ®°ÂºèËÆæÁΩÆ
            const modeConfig = applyGameMode(gameMode);
            
            // Â∫îÁî®Âú∞ÂõæÈ£éÊ†ºËÆæÁΩÆ
            const styleConfig = applyMapStyle(mapStyle);
            
            const size = parseInt(document.getElementById('mapSize').value);
            const floors = parseInt(document.getElementById('floorCount').value);
            const roomCount = parseInt(document.getElementById('roomCount').value);
            const corridorWidth = parseInt(document.getElementById('corridorWidth').value);
            const coverDensity = parseInt(document.getElementById('coverDensity').value);
            const waterAmount = parseInt(document.getElementById('waterAmount').value);
            const stairsCount = parseInt(document.getElementById('stairsCount').value);
            const windowDensity = parseInt(document.getElementById('windowDensity').value);
            
            // ÂàùÂßãÂåñÂú∞Âõæ
            initMap(size, floors);
            
            // ÁîüÊàêÊØèÂ±ÇÁöÑÊàøÈó¥
            const allRooms = [];
            for (let floor = 0; floor < floors; floor++) {
                const rooms = generateRooms(size, roomCount, floor);
                connectRooms(rooms, floor, corridorWidth);
                
                // ÁîüÊàêÂ§ßÂéÖÔºàÂè™Âú®Á¨¨‰∏ÄÂ±ÇÔºâ
                if (floor === 0) {
                    generateLobby(size, floor);
                }
                
                // ÁîüÊàêÈ´ò‰ΩéÂ∑ÆÂå∫Âüü
                generateElevationAreas(size, floor);
                
                // Ê∑ªÂä†ÊàøÈó¥Â°´ÂÖÖÔºàÂú®ÊàøÈó¥ÂÜÖÈÉ®ÂàõÂª∫Êõ¥Â§öÂ∞èÊàøÈó¥Ôºâ
                addRoomFilling(rooms, floor);
                
                allRooms.push(...rooms);
            }
            
            // Ê∑ªÂä†Ê•ºÊ¢Ø
            addStairs(allRooms, stairsCount);
            
            // Ê∑ªÂä†ÁâπÊÆäÂÖÉÁ¥†
            addSpecialElements(allRooms, coverDensity, waterAmount, windowDensity);
            
            // ÂàõÂª∫Ê•ºÂ±ÇÈÄâÊã©Âô®
            createFloorSelector();
            
            // ÈáçÁΩÆÂà∞Á¨¨‰∏ÄÂ±Ç
            currentFloor = 0;
            
            // ÁªòÂà∂Âè†Âä†ËßÜÂõæÂú∞Âõæ
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const cellSize = 10;
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // Ê∏ÖÁ©∫ÁîªÂ∏É
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ‰ªéÂ∫ïÂ±ÇÂà∞È°∂Â±ÇÁªòÂà∂Ôºå‰ΩøÁî®ÈÄèÊòéÂ∫¶
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25); // È´òÂ±ÇÊõ¥ÈÄèÊòé
                const offset = floor * 2; // ÊØèÂ±ÇÂÅèÁßªÔºåÂàõÂª∫3DÊïàÊûú
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let color = '#000';
                            
                            // Ê†πÊçÆÊ•ºÂ±ÇË∞ÉÊï¥È¢úËâ≤
                            switch(tile) {
                                case TileType.FLOOR: 
                                    color = floor === 0 ? 'rgba(74, 74, 74, ' : 
                                           floor === 1 ? 'rgba(90, 90, 90, ' : 
                                           floor === 2 ? 'rgba(106, 106, 106, ' : 
                                           'rgba(122, 122, 122, ';
                                    break;
                                case TileType.WALL: 
                                    color = floor === 0 ? 'rgba(176, 176, 176, ' : 
                                           floor === 1 ? 'rgba(160, 160, 176, ' : 
                                           floor === 2 ? 'rgba(144, 144, 176, ' : 
                                           'rgba(128, 128, 176, ';
                                    break;
                                case TileType.DOOR: 
                                    color = 'rgba(96, 96, 96, '; 
                                    break;
                                case TileType.WINDOW: 
                                    color = 'rgba(106, 140, 175, '; 
                                    break;
                                case TileType.COVER: 
                                    color = 'rgba(48, 48, 48, '; 
                                    break;
                                case TileType.BOMBSITE_A: 
                                    color = 'rgba(90, 90, 0, '; 
                                    break;
                                case TileType.BOMBSITE_B: 
                                    color = 'rgba(90, 58, 0, '; 
                                    break;
                                case TileType.T_SPAWN: 
                                    color = 'rgba(58, 32, 32, '; 
                                    break;
                                case TileType.CT_SPAWN: 
                                    color = 'rgba(32, 32, 48, '; 
                                    break;
                                case TileType.STAIRS_UP: 
                                    color = 'rgba(139, 115, 85, '; 
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    color = 'rgba(107, 83, 69, '; 
                                    break;
                                case TileType.WATER: 
                                    color = 'rgba(42, 77, 105, '; 
                                    break;
                                case TileType.BRIDGE: 
                                    color = 'rgba(90, 90, 90, '; 
                                    break;
                            }
                            
                            // Ê∑ªÂä†ÈÄèÊòéÂ∫¶
                            color += opacity + ')';
                            
                            ctx.fillStyle = color;
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // ÁªòÂà∂Â¢ôÂ£ÅËæπÊ°Ü
                            if (tile === TileType.WALL) {
                                ctx.strokeStyle = 'rgba(128, 128, 128, ' + (opacity * 0.5) + ')';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(
                                    x * cellSize + offset, 
                                    y * cellSize + offset, 
                                    cellSize, 
                                    cellSize
                                );
                            }
                            
                            // ÁªòÂà∂Ê•ºÊ¢ØÁÆ≠Â§¥ÂíåÊ•ºÂ±ÇÊ†áËÆ∞
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                ctx.font = '8px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? '‚Üë' : '‚Üì';
                                ctx.fillText(
                                    arrow + (floor + 1), 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + 3 + offset
                                );
                            }
                        }
                    }
                }
                
                // ÁªòÂà∂Ê•ºÂ±ÇÊ†áÁ≠æ
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`F${floor + 1}`, 10 + offset, 20 + offset);
            }
            
            // ÁªòÂà∂ËØ¥Êòé
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('Âè†Âä†ËßÜÂõæÊ®°Âºè', canvas.width - 10, 20);
            
            // ÁªòÂà∂Ê•ºÂ±ÇÂõæ‰æã
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.fillRect(10, 40 + i * 20, 15, 15);
                ctx.fillStyle = '#ccc';
                ctx.fillText(`Á¨¨${i + 1}Â±Ç`, 30, 50 + i * 20);
            }
            
            // ÁªòÂà∂ÂåÖÁÇπÊ†áËÆ∞ÔºàÊâÄÊúâÂ±ÇÔºâ
            const overlayBombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + overlayBombFontSize + 'px Arial';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                ctx.fillStyle = 'rgba(255, 215, 0, ' + opacity + ')';
                
                // AÂåÖÁÇπ
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_A) {
                            ctx.strokeText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // BÂåÖÁÇπ
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_B) {
                            ctx.strokeText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
            }
        }
            drawMap();
        }
        
        // ÂàõÂª∫Ê•ºÂ±ÇÈÄâÊã©Âô®
        function createFloorSelector() {
            const selector = document.getElementById('floorSelector');
            selector.innerHTML = '';
            
            // Ê∑ªÂä†Ê•ºÂ±ÇÊåâÈíÆ
            for (let i = 0; i < totalFloors; i++) {
                const btn = document.createElement('button');
                btn.className = 'floor-btn';
                btn.textContent = `Á¨¨${i + 1}Â±Ç`;
                btn.onclick = function() {
                    overlayMode = false;
                    currentFloor = i;
                    updateFloorButtons();
                    drawMap();
                };
                if (i === 0 && !overlayMode) {
                    btn.classList.add('active');
                }
                selector.appendChild(btn);
            }
            
            // Ê∑ªÂä†Âè†Âä†ËßÜÂõæÊåâÈíÆ
            if (totalFloors > 1) {
                const overlayBtn = document.createElement('button');
                overlayBtn.className = 'overlay-btn';
                overlayBtn.textContent = 'üî≤ Âè†Âä†ËßÜÂõæ';
                overlayBtn.onclick = function() {
                    overlayMode = !overlayMode;
                    updateFloorButtons();
                    
                    if (overlayMode) {
                        overlayBtn.classList.add('active');
                        drawOverlayMap();
                    } else {
                        overlayBtn.classList.remove('active');
                        drawMap();
                    }
                };
                selector.appendChild(overlayBtn);
            }
        }
        
        // Êõ¥Êñ∞Ê•ºÂ±ÇÊåâÈíÆÁä∂ÊÄÅ
        function updateFloorButtons() {
            const buttons = document.querySelectorAll('.floor-btn');
            const overlayBtn = document.querySelector('.overlay-btn');
            
            buttons.forEach((btn, index) => {
                if (!overlayMode && index === currentFloor) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            if (overlayBtn) {
                if (overlayMode) {
                    overlayBtn.classList.add('active');
                } else {
                    overlayBtn.classList.remove('active');
                }
            }
        }
        
        // ÁªòÂà∂Âú∞Âõæ
        function drawMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // ÂêØÁî®ÊäóÈîØÈΩøÂíåÂπ≥ÊªëÊïàÊûú
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[currentFloor]) return;
            
            const map = mapFloors[currentFloor];
            const mapSize = parseInt(document.getElementById('mapSize').value);
            
            // Ê†πÊçÆÂú∞ÂõæÂ∞∫ÂØ∏Âä®ÊÄÅË∞ÉÊï¥ÊñπÂùóÂ§ßÂ∞èÔºå‰ΩøÁî®Êõ¥Â∞èÁöÑÂ∞∫ÂØ∏ÂáèÂ∞ëÂÉèÁ¥†ÊÑü
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // ÈôêÂà∂ÁîªÂ∏ÉÊúÄÂ§ßÂ∞∫ÂØ∏ÔºåÈÅøÂÖçËøáÂ§ß
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // Ê∏ÖÁ©∫ÁîªÂ∏É
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ÁªòÂà∂Âú∞Âõæ
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[0].length; x++) {
                    const tile = map[y][x];
                    let color = '#000';
                    
                    switch(tile) {
                        case TileType.FLOOR: color = '#4a4a4a'; break;
                        case TileType.WALL: color = '#b0b0b0'; break;
                        case TileType.DOOR: color = '#606060'; break;
                        case TileType.WINDOW: color = '#6a8caf'; break;
                        case TileType.COVER: color = '#303030'; break;
                        case TileType.HIGH_GROUND: color = '#6a6a4a'; break;    // È´òÂú∞ÔºàÊµÖÈªÑÁÅ∞Ôºâ
                        case TileType.LOW_GROUND: color = '#2a2a4a'; break;     // ‰ΩéÂú∞ÔºàÊ∑±ËìùÁÅ∞Ôºâ
                        case TileType.MEDIUM_GROUND: color = '#4a4a4a'; break;  // ‰∏≠Á≠âÂú∞ÔºàÊ†áÂáÜÁÅ∞Ôºâ
                        case TileType.BOMBSITE_A: color = '#5a5a00'; break;
                        case TileType.BOMBSITE_B: color = '#5a3a00'; break;
                        case TileType.BOMBSITE_C: color = '#5a1a00'; break; // ÂåÖÁÇπCÔºàÊ∑±Ê©ôÔºâ
                        case TileType.BOMBSITE_D: color = '#3a5a00'; break; // ÂåÖÁÇπDÔºàÊ∑±ÁªøÔºâ
                        case TileType.BOMBSITE_E: color = '#1a5a00'; break; // ÂåÖÁÇπEÔºàÊ∑±ÈùíÔºâ
                        case TileType.T_SPAWN: color = '#3a2020'; break;
                        case TileType.CT_SPAWN: color = '#202030'; break;
                        case TileType.STAIRS_UP: color = '#8B7355'; break;
                        case TileType.STAIRS_DOWN: color = '#6B5345'; break;
                        case TileType.WATER: color = '#2a4d69'; break;
                        case TileType.BRIDGE: color = '#5a5a5a'; break;
                        case TileType.OUTDOOR: color = '#7a8a6a'; break;           // Â§ñÂú∫Âú∞Èù¢ÔºàÊµÖÁªøÁÅ∞Ôºâ
                        case TileType.OUTDOOR_WALL: color = '#8a8a7a'; break;     // Â§ñÂú∫Âõ¥Â¢ôÔºàÊµÖÁÅ∞Ôºâ
                        case TileType.OUTDOOR_COVER: color = '#4a5a4a'; break;    // Â§ñÂú∫Êé©‰ΩìÔºàÊ∑±ÁªøÁÅ∞Ôºâ
                        case TileType.LOBBY: color = '#6a7a8a'; break;            // Â§ßÂéÖ
                        case TileType.LOBBY_ENTRANCE: color = '#8a6a7a'; break;   // Â§ßÂéÖÂÖ•Âè£
                        case TileType.LOBBY_CENTER: color = '#7a6a8a'; break;     // Â§ßÂéÖ‰∏≠ÂøÉ
                        // Â∏∏ËßÅÂú∞ÂΩ¢/Ê®°ÂùóÈ¢úËâ≤
                        case TileType.LONG_LANE: color = '#8a4a4a'; break;        // Â§ßÈÅìÔºàÊ∑±Á∫¢ÁÅ∞Ôºâ
                        case TileType.SHORT_LANE: color = '#4a8a4a'; break;       // Â∞èÈÅìÔºàÊ∑±ÁªøÁÅ∞Ôºâ
                        case TileType.MID_LANE: color = '#4a4a8a'; break;         // ‰∏≠Ë∑ØÔºàÊ∑±ËìùÁÅ∞Ôºâ
                        case TileType.PLATFORM: color = '#8a8a4a'; break;         // È´òÂè∞ÔºàÊ∑±ÈªÑÁÅ∞Ôºâ
                        case TileType.UNDERPASS: color = '#4a8a8a'; break;        // ÊöóÈÅìÔºàÊ∑±ÈùíÁÅ∞Ôºâ
                        case TileType.CONNECTOR: color = '#8a4a8a'; break;        // ËøûÊé•Ë∑ØÔºàÊ∑±Á¥´ÁÅ∞Ôºâ
                        case TileType.RAMP: color = '#6a6a6a'; break;             // ÊñúÂù°Ôºà‰∏≠ÁÅ∞Ôºâ
                        case TileType.ROTATION_PATH: color = '#5a5a5a'; break;    // ËΩ¨ÁÇπË∑ØÁ∫øÔºàÊ∑±ÁÅ∞Ôºâ
                        case TileType.SHADOW_POINT: color = '#8a6a4a'; break;      // Èò¥ÁÇπÔºàÊ∑±Ê£ïÁÅ∞Ôºâ
                    }
                    
                    if (tile !== TileType.VOID) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        
                        // ÁßªÈô§Â¢ôÂ£ÅËæπÊ°ÜÔºå‰∏ç‰ΩøÁî®Ê†ºÂ≠ê
                        
                        // ÁªòÂà∂Ê•ºÊ¢ØÁÆ≠Â§¥
                        if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                            ctx.fillStyle = '#fff';
                            const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                            ctx.font = fontSize + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(tile === TileType.STAIRS_UP ? '‚Üë' : '‚Üì', 
                                x * cellSize + cellSize/2, y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3));
                        }
                    }
                }
            }
            
            // ÁªòÂà∂ÂåÖÁÇπÊ†áËÆ∞
            const bombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + bombFontSize + 'px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            // ÂåÖÁÇπÊ†áËÆ∞Êò†Â∞Ñ
            const bombSiteMarkers = {
                [TileType.BOMBSITE_A]: 'A',
                [TileType.BOMBSITE_B]: 'B',
                [TileType.BOMBSITE_C]: 'C',
                [TileType.BOMBSITE_D]: 'D',
                [TileType.BOMBSITE_E]: 'E'
            };
            
            // ÁªòÂà∂ÊâÄÊúâÂåÖÁÇπÊ†áËÆ∞
            for (const [tileType, marker] of Object.entries(bombSiteMarkers)) {
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[0].length; x++) {
                        if (map[y][x] === parseInt(tileType)) {
                            ctx.strokeText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                            ctx.fillText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                        y = map.length;
                        break;
                        }
                    }
                }
            }
        }
        
        // ÁªòÂà∂Âè†Âä†ËßÜÂõæ
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // ÂêØÁî®ÊäóÈîØÈΩøÂíåÂπ≥ÊªëÊïàÊûú
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const mapSize = parseInt(document.getElementById('mapSize').value);
            
            // Ê†πÊçÆÂú∞ÂõæÂ∞∫ÂØ∏Âä®ÊÄÅË∞ÉÊï¥ÊñπÂùóÂ§ßÂ∞èÔºå‰ΩøÁî®Êõ¥Â∞èÁöÑÂ∞∫ÂØ∏ÂáèÂ∞ëÂÉèÁ¥†ÊÑü
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // ÈôêÂà∂ÁîªÂ∏ÉÊúÄÂ§ßÂ∞∫ÂØ∏ÔºåÈÅøÂÖçËøáÂ§ß
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // Ê∏ÖÁ©∫ÁîªÂ∏É
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ‰ªéÂ∫ïÂ±ÇÂà∞È°∂Â±ÇÁªòÂà∂
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let baseColor = [0, 0, 0];
                            
                            switch(tile) {
                                case TileType.FLOOR: 
                                    baseColor = [74 + floor * 16, 74 + floor * 16, 74 + floor * 16];
                                    break;
                                case TileType.WALL: 
                                    baseColor = [176 - floor * 16, 176 - floor * 16, 176];
                                    break;
                                case TileType.HIGH_GROUND: 
                                    baseColor = [106, 106, 74]; // È´òÂú∞ÔºàÊµÖÈªÑÁÅ∞Ôºâ
                                    break;
                                case TileType.LOW_GROUND: 
                                    baseColor = [42, 42, 74]; // ‰ΩéÂú∞ÔºàÊ∑±ËìùÁÅ∞Ôºâ
                                    break;
                                case TileType.MEDIUM_GROUND: 
                                    baseColor = [74, 74, 74]; // ‰∏≠Á≠âÂú∞ÔºàÊ†áÂáÜÁÅ∞Ôºâ
                                    break;
                                case TileType.COVER: 
                                    baseColor = [48, 48, 48];
                                    break;
                                case TileType.BOMBSITE_A: 
                                    baseColor = [90, 90, 0];
                                    break;
                                case TileType.BOMBSITE_B: 
                                    baseColor = [90, 58, 0];
                                    break;
                                case TileType.BOMBSITE_C: 
                                    baseColor = [90, 26, 0]; // ÂåÖÁÇπCÔºàÊ∑±Ê©ôÔºâ
                                    break;
                                case TileType.BOMBSITE_D: 
                                    baseColor = [58, 90, 0]; // ÂåÖÁÇπDÔºàÊ∑±ÁªøÔºâ
                                    break;
                                case TileType.BOMBSITE_E: 
                                    baseColor = [26, 90, 0]; // ÂåÖÁÇπEÔºàÊ∑±ÈùíÔºâ
                                    break;
                                case TileType.T_SPAWN: 
                                    baseColor = [58, 32, 32];
                                    break;
                                case TileType.CT_SPAWN: 
                                    baseColor = [32, 32, 48];
                                    break;
                                case TileType.STAIRS_UP: 
                                    baseColor = [139, 115, 85];
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    baseColor = [107, 83, 69];
                                    break;
                                case TileType.WATER: 
                                    baseColor = [42, 77, 105];
                                    break;
                                case TileType.WINDOW:
                                    baseColor = [106, 140, 175];
                                    break;
                                // Â∏∏ËßÅÂú∞ÂΩ¢/Ê®°ÂùóÈ¢úËâ≤
                                case TileType.LONG_LANE:
                                    baseColor = [138, 74, 74]; // Â§ßÈÅìÔºàÊ∑±Á∫¢ÁÅ∞Ôºâ
                                    break;
                                case TileType.SHORT_LANE:
                                    baseColor = [74, 138, 74]; // Â∞èÈÅìÔºàÊ∑±ÁªøÁÅ∞Ôºâ
                                    break;
                                case TileType.MID_LANE:
                                    baseColor = [74, 74, 138]; // ‰∏≠Ë∑ØÔºàÊ∑±ËìùÁÅ∞Ôºâ
                                    break;
                                case TileType.PLATFORM:
                                    baseColor = [138, 138, 74]; // È´òÂè∞ÔºàÊ∑±ÈªÑÁÅ∞Ôºâ
                                    break;
                                case TileType.UNDERPASS:
                                    baseColor = [74, 138, 138]; // ÊöóÈÅìÔºàÊ∑±ÈùíÁÅ∞Ôºâ
                                    break;
                                case TileType.CONNECTOR:
                                    baseColor = [138, 74, 138]; // ËøûÊé•Ë∑ØÔºàÊ∑±Á¥´ÁÅ∞Ôºâ
                                    break;
                                case TileType.RAMP:
                                    baseColor = [106, 106, 106]; // ÊñúÂù°Ôºà‰∏≠ÁÅ∞Ôºâ
                                    break;
                                case TileType.ROTATION_PATH:
                                    baseColor = [90, 90, 90]; // ËΩ¨ÁÇπË∑ØÁ∫øÔºàÊ∑±ÁÅ∞Ôºâ
                                    break;
                                case TileType.SHADOW_POINT:
                                    baseColor = [138, 106, 74]; // Èò¥ÁÇπÔºàÊ∑±Ê£ïÁÅ∞Ôºâ
                                    break;
                                default:
                                    baseColor = [50, 50, 50];
                            }
                            
                            ctx.fillStyle = 'rgba(' + baseColor[0] + ',' + baseColor[1] + ',' + baseColor[2] + ',' + opacity + ')';
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // ÁßªÈô§Â¢ôÂ£ÅËæπÊ°ÜÔºå‰∏ç‰ΩøÁî®Ê†ºÂ≠ê
                            
                            // Ê•ºÊ¢ØÊ†áËÆ∞
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                                ctx.font = fontSize + 'px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? '‚Üë' : '‚Üì';
                                ctx.fillText(
                                    arrow, 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3) + offset
                                );
                            }
                        }
                    }
                }
                
                // Ê•ºÂ±ÇÊ†áÁ≠æ
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                const floorFontSize = Math.max(8, Math.floor(cellSize * 0.8));
                ctx.font = 'bold ' + floorFontSize + 'px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('F' + (floor + 1), Math.floor(cellSize * 0.8) + offset, Math.floor(cellSize * 1.5) + offset);
            }
            
            // Ê†áÈ¢ò
            ctx.fillStyle = '#4CAF50';
            const titleFontSize = Math.max(10, Math.floor(cellSize * 1.0));
            ctx.font = 'bold ' + titleFontSize + 'px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('Âè†Âä†ËßÜÂõæ', canvas.width - Math.floor(cellSize * 0.8), Math.floor(cellSize * 1.5));
            
            // Âõæ‰æã
            const legendFontSize = Math.max(8, Math.floor(cellSize * 0.7));
            ctx.font = legendFontSize + 'px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(200, 200, 200, ' + opacity + ')';
                const legendY = Math.floor(cellSize * 2.5) + i * Math.floor(cellSize * 1.5);
                ctx.fillRect(Math.floor(cellSize * 0.8), legendY, Math.floor(cellSize * 1.2), Math.floor(cellSize * 1.2));
                ctx.fillStyle = '#ccc';
                ctx.fillText('Á¨¨' + (i + 1) + 'Â±Ç', Math.floor(cellSize * 2.2), legendY + Math.floor(cellSize * 0.8));
            }
        }
        
        // ÂØºÂá∫Âú∞Âõæ
        function exportMap() {
            const data = {
                floors: mapFloors,
                totalFloors: totalFloors,
                currentFloor: currentFloor
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map_' + Date.now() + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ÊâæÂà∞ÊúÄ‰Ω≥ÁöÑÈó®‰ΩçÁΩÆ
        function findBestDoorPosition(room, floor) {
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0, score: 0 }, // Â∑¶
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0, score: 0 }, // Âè≥
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1, score: 0 }, // ‰∏ä
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1, score: 0 } // ‰∏ã
            ];
            
            // ‰∏∫ÊØè‰∏™‰ΩçÁΩÆËØÑÂàÜ
            for (let side of sides) {
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    
                    // Ê£ÄÊü•Èó®Â§ñÊòØÂê¶ÊúâÁ©∫Âú∞
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        side.score += 10;
                    }
                    
                    // Ê£ÄÊü•ÊòØÂê¶Èù†ËøëÂÖ∂‰ªñÊàøÈó¥
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = -3; dx <= 3; dx++) {
                            const nx = corridorX + dx;
                            const ny = corridorY + dy;
                            if (nx >= 0 && nx < mapFloors[floor][0].length && 
                                ny >= 0 && ny < mapFloors[floor].length) {
                                if (mapFloors[floor][ny][nx] === TileType.FLOOR) {
                                    side.score += 5;
                                }
                            }
                        }
                    }
                }
            }
            
            // ÈÄâÊã©ÂæóÂàÜÊúÄÈ´òÁöÑ‰ΩçÁΩÆ
            sides.sort((a, b) => b.score - a.score);
            return sides[0].score > 0 ? sides[0] : null;
        }
        
        // ÂàõÂª∫ËøûÁª≠Ê∞¥ÂüüÂå∫Âüü
        function createWaterAreas(waterAmount) {
            const mapSize = mapFloors[0].length;
            const waterCount = Math.floor(mapSize * mapSize * waterAmount / 1000);
            
            // ÂàõÂª∫Â§ö‰∏™Ê∞¥ÂüüÂå∫Âüü
            const waterAreas = Math.max(1, Math.floor(waterCount / 50)); // Ê†πÊçÆÊ∞¥ÂüüÊï∞ÈáèÂÜ≥ÂÆöÂå∫ÂüüÊï∞Èáè
            
            for (let area = 0; area < waterAreas; area++) {
                // ÈöèÊú∫ÈÄâÊã©Ê∞¥ÂüüËµ∑ÂßãÁÇπ
                let startX, startY;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    startX = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    startY = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    (startX < 0 || startX >= mapSize || startY < 0 || startY >= mapSize ||
                     !mapFloors[0][startY] || mapFloors[0][startY][startX] === undefined ||
                     (mapFloors[0][startY][startX] !== TileType.FLOOR &&
                      mapFloors[0][startY][startX] !== TileType.MEDIUM_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.HIGH_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.LOW_GROUND))
                );
                
                if (attempts >= maxAttempts) continue;
                
                // ‰ΩøÁî®Ê¥™Ê∞¥Â°´ÂÖÖÁÆóÊ≥ïÂàõÂª∫ËøûÁª≠Ê∞¥Âüü
                const areaSize = Math.floor(waterCount / waterAreas);
                floodFillWater(startX, startY, areaSize);
            }
        }
        
        // Ê¥™Ê∞¥Â°´ÂÖÖÁÆóÊ≥ïÂàõÂª∫Ê∞¥Âüü
        function floodFillWater(startX, startY, maxSize) {
            const queue = [{x: startX, y: startY}];
            const visited = new Set();
            let filledCount = 0;
            
            while (queue.length > 0 && filledCount < maxSize) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                                        // Ê£ÄÊü•ÂΩìÂâç‰ΩçÁΩÆÊòØÂê¶ÈÄÇÂêàÊîæÁΩÆÊ∞¥Âüü
                        if (current.x >= 0 && current.x < mapFloors[0][0].length &&
                            current.y >= 0 && current.y < mapFloors[0].length &&
                            mapFloors[0][current.y] && mapFloors[0][current.y][current.x] !== undefined) {
                            
                            if (mapFloors[0][current.y][current.x] === TileType.FLOOR ||
                                mapFloors[0][current.y][current.x] === TileType.MEDIUM_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.HIGH_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.LOW_GROUND) {
                                
                                // ÊîæÁΩÆÊ∞¥Âüü
                                mapFloors[0][current.y][current.x] = TileType.WATER;
                        filledCount++;
                        
                        // Ê∑ªÂä†Áõ∏ÈÇª‰ΩçÁΩÆÂà∞ÈòüÂàó
                        const directions = [
                            {dx: -1, dy: 0}, {dx: 1, dy: 0},
                            {dx: 0, dy: -1}, {dx: 0, dy: 1}
                        ];
                        
                        for (const dir of directions) {
                            const nextX = current.x + dir.dx;
                            const nextY = current.y + dir.dy;
                            const nextKey = `${nextX},${nextY}`;
                            
                            if (!visited.has(nextKey) && 
                                nextX >= 0 && nextX < mapFloors[0][0].length &&
                                nextY >= 0 && nextY < mapFloors[0].length) {
                                
                                // ÈöèÊú∫ÂÜ≥ÂÆöÊòØÂê¶ÁªßÁª≠Êâ©Â±ïÔºàÂàõÂª∫Ëá™ÁÑ∂ÂΩ¢Áä∂Ôºâ
                                if (Math.random() < 0.7) { // 70%Ê¶ÇÁéáÁªßÁª≠Êâ©Â±ï
                                    queue.push({x: nextX, y: nextY});
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // ÁßçÂ≠êÁ≥ªÁªü
        let savedSeeds = [];
        let currentSeed = null;
        
        // ÁîüÊàêÂΩìÂâçÂèÇÊï∞ÁöÑÂîØ‰∏ÄÁßçÂ≠ê
        function generateSeed() {
            const params = {
                mapSize: document.getElementById('mapSize').value,
                floorCount: document.getElementById('floorCount').value,
                roomCount: document.getElementById('roomCount').value,
                roomSize: document.getElementById('roomSize').value,
                roomPosition: document.getElementById('roomPosition').value,
                corridorWidth: document.getElementById('corridorWidth').value,
                pathComplexity: document.getElementById('pathComplexity').value,
                corridorRandom: document.getElementById('corridorRandom').value,
                coverDensity: document.getElementById('coverDensity').value,
                waterAmount: document.getElementById('waterAmount').value,
                stairsCount: document.getElementById('stairsCount').value,
                windowDensity: document.getElementById('windowDensity').value,
                elevation: document.getElementById('elevation').value,
                longLanes: document.getElementById('longLanes').value,
                midControl: document.getElementById('midControl').value,
                rotateTime: document.getElementById('rotateTime').value,
                verticality: document.getElementById('verticality').value,
                breakables: document.getElementById('breakables').value,
                fieldLayout: document.getElementById('fieldLayout').value,
                gameMode: document.getElementById('gameMode').value,
                mapStyle: document.getElementById('mapStyle').value,
                outdoorRatio: document.getElementById('outdoorRatio').value,
                outdoorSize: document.getElementById('outdoorSize').value,
                outdoorArea: document.getElementById('outdoorArea').value,
                generateLobby: document.getElementById('generateLobby').value,
                nadeSpots: document.getElementById('nadeSpots').value,
                // Â∏∏ËßÅÂú∞ÂΩ¢/Ê®°ÂùóÂèÇÊï∞
                longLane: document.getElementById('longLane').value,
                shortLane: document.getElementById('shortLane').value,
                midLane: document.getElementById('midLane').value,
                platform: document.getElementById('platform').value,
                underpass: document.getElementById('underpass').value,
                connector: document.getElementById('connector').value,
                ramp: document.getElementById('ramp').value,
                rotation: document.getElementById('rotation').value,
                bombSiteCount: document.getElementById('bombSiteCount').value,
                shadowPoint: document.getElementById('shadowPoint').value,
                roomFill: document.getElementById('roomFill').value
            };
            
            // ÂàõÂª∫ÁßçÂ≠êÂ≠óÁ¨¶‰∏≤
            const seedString = JSON.stringify(params);
            return btoa(seedString).substring(0, 16); // ÂèñÂâç16‰Ωç‰Ωú‰∏∫ÁßçÂ≠ê
        }
        
        // ‰øùÂ≠òÂΩìÂâçÁßçÂ≠ê
        function saveCurrentSeed() {
            const seed = generateSeed();
            const seedName = prompt('ËØ∑ËæìÂÖ•ÁßçÂ≠êÂêçÁß∞:', `ÁßçÂ≠ê_${new Date().toLocaleDateString()}`);
            
            if (!seedName) return;
            
            const seedData = {
                id: Date.now(),
                name: seedName,
                seed: seed,
                date: new Date().toISOString(),
                params: {
                    mapSize: document.getElementById('mapSize').value,
                    floorCount: document.getElementById('floorCount').value,
                    roomCount: document.getElementById('roomCount').value,
                    roomSize: document.getElementById('roomSize').value,
                    roomPosition: document.getElementById('roomPosition').value,
                    corridorWidth: document.getElementById('corridorWidth').value,
                    pathComplexity: document.getElementById('pathComplexity').value,
                    corridorRandom: document.getElementById('corridorRandom').value,
                    coverDensity: document.getElementById('coverDensity').value,
                    waterAmount: document.getElementById('waterAmount').value,
                    stairsCount: document.getElementById('stairsCount').value,
                    windowDensity: document.getElementById('windowDensity').value,
                    elevation: document.getElementById('elevation').value,
                    longLanes: document.getElementById('longLanes').value,
                    midControl: document.getElementById('midControl').value,
                    rotateTime: document.getElementById('rotateTime').value,
                    verticality: document.getElementById('verticality').value,
                    breakables: document.getElementById('breakables').value,
                    fieldLayout: document.getElementById('fieldLayout').value,
                    gameMode: document.getElementById('gameMode').value,
                    mapStyle: document.getElementById('mapStyle').value,
                    outdoorRatio: document.getElementById('outdoorRatio').value,
                    outdoorSize: document.getElementById('outdoorSize').value,
                    outdoorArea: document.getElementById('outdoorArea').value,
                    generateLobby: document.getElementById('generateLobby').value,
                    nadeSpots: document.getElementById('nadeSpots').value,
                    longLane: document.getElementById('longLane').value,
                    shortLane: document.getElementById('shortLane').value,
                    midLane: document.getElementById('midLane').value,
                    platform: document.getElementById('platform').value,
                    underpass: document.getElementById('underpass').value,
                    connector: document.getElementById('connector').value,
                    ramp: document.getElementById('ramp').value,
                    rotation: document.getElementById('rotation').value,
                    bombSiteCount: document.getElementById('bombSiteCount').value,
                    shadowPoint: document.getElementById('shadowPoint').value,
                    roomFill: document.getElementById('roomFill').value
                }
            };
            
            savedSeeds.push(seedData);
            saveSeedsToStorage();
            renderSeedsList();
        }
        
        // Â∫îÁî®ÁßçÂ≠êÂèÇÊï∞
        function applySeed(seedData) {
            const params = seedData.params;
            
            // Â∫îÁî®ÊâÄÊúâÂèÇÊï∞
            Object.keys(params).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = params[key];
                    
                    // Ëß¶Âèëoninput‰∫ã‰ª∂‰ª•Êõ¥Êñ∞ÊòæÁ§∫ÂÄº
                    if (element.oninput) {
                        element.oninput();
                    }
                }
            });
            
            // ÁâπÊÆäÂ§ÑÁêÜ‰∏ãÊãâËèúÂçï
            if (params.gameMode) {
                document.getElementById('gameMode').value = params.gameMode;
                applyGameMode(params.gameMode);
            }
            
            if (params.mapStyle) {
                document.getElementById('mapStyle').value = params.mapStyle;
                applyMapStyle(params.mapStyle);
            }
            
            // ÈáçÊñ∞ÁîüÊàêÂú∞Âõæ
            generateMap();
        }
        
        // Âà†Èô§ÁßçÂ≠ê
        function deleteSeed(seedId) {
            if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÁßçÂ≠êÂêóÔºü')) {
                savedSeeds = savedSeeds.filter(seed => seed.id !== seedId);
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // Ê∏ÖÁ©∫ÊâÄÊúâÁßçÂ≠ê
        function clearAllSeeds() {
            if (confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÁßçÂ≠êÂêóÔºü')) {
                savedSeeds = [];
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // Ê∏≤ÊüìÁßçÂ≠êÂàóË°®
        function renderSeedsList() {
            const seedsList = document.getElementById('seedsList');
            seedsList.innerHTML = '';
            
            if (savedSeeds.length === 0) {
                seedsList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">ÊöÇÊó†Êî∂ËóèÁöÑÁßçÂ≠ê</div>';
                return;
            }
            
            savedSeeds.forEach(seed => {
                const seedItem = document.createElement('div');
                seedItem.className = 'seed-item';
                
                const date = new Date(seed.date);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString().substring(0, 5);
                
                // ÂàõÂª∫ÂèÇÊï∞ÊëòË¶Å
                const paramSummary = [
                    `Â∞∫ÂØ∏: ${seed.params.mapSize}`,
                    `Â±ÇÊï∞: ${seed.params.floorCount}`,
                    `ÊàøÈó¥: ${seed.params.roomCount}`,
                    `Êé©‰Ωì: ${seed.params.coverDensity}%`,
                    `Ê∞¥Âüü: ${seed.params.waterAmount}%`
                ].join(' | ');
                
                seedItem.innerHTML = `
                    <div class="seed-header">
                        <div class="seed-name">${seed.name}</div>
                        <div class="seed-date">${dateStr}</div>
                    </div>
                    <div class="seed-params">${paramSummary}</div>
                    <div class="seed-actions">
                        <button onclick="applySeed(${JSON.stringify(seed).replace(/"/g, '&quot;')})">Â∫îÁî®</button>
                        <button class="delete" onclick="deleteSeed(${seed.id})">Âà†Èô§</button>
                    </div>
                `;
                
                seedsList.appendChild(seedItem);
            });
        }
        
        // ‰øùÂ≠òÁßçÂ≠êÂà∞Êú¨Âú∞Â≠òÂÇ®
        function saveSeedsToStorage() {
            localStorage.setItem('mapGeneratorSeeds', JSON.stringify(savedSeeds));
        }
        
        // ‰ªéÊú¨Âú∞Â≠òÂÇ®Âä†ËΩΩÁßçÂ≠ê
        function loadSeedsFromStorage() {
            const stored = localStorage.getItem('mapGeneratorSeeds');
            if (stored) {
                savedSeeds = JSON.parse(stored);
            }
        }
        
        // Ê∑ªÂä†ÊàøÈó¥Â°´ÂÖÖÔºà‰ΩøÁî®Ëø∑ÂÆ´ÁÆóÊ≥ïÂ°´ÂÖÖÊàøÈó¥Ôºâ
        function addRoomFilling(rooms, floor) {
            const roomFillDensity = parseInt(document.getElementById('roomFill').value);
            if (roomFillDensity === 0) return; // Êó†Â°´ÂÖÖ
            
            const densityMultiplier = [0, 0.3, 0.6, 1.0, 1.5][roomFillDensity]; // ÂØÜÂ∫¶ÂÄçÊï∞
            console.log(`Ê•ºÂ±Ç${floor}ÊàøÈó¥Â°´ÂÖÖÂØÜÂ∫¶: ${roomFillDensity}, ÂÄçÊï∞: ${densityMultiplier}`);
            
            let totalFilledRooms = 0;
            
            for (let room of rooms) {
                // Ë∑≥ËøáÂ§™Â∞èÁöÑÊàøÈó¥
                if (room.width < 8 || room.height < 8) continue;
                
                // Ê†πÊçÆÂØÜÂ∫¶ÂÜ≥ÂÆöÊòØÂê¶Â°´ÂÖÖËøô‰∏™ÊàøÈó¥
                if (Math.random() < densityMultiplier) {
                    console.log(`ÊàøÈó¥(${room.x},${room.y},${room.width}x${room.height}) ‰ΩøÁî®Ëø∑ÂÆ´Â°´ÂÖÖÔºåÂØÜÂ∫¶: ${roomFillDensity}`);
                    
                    if (createMazeInRoom(room, floor, roomFillDensity)) {
                        totalFilledRooms++;
                    }
                }
            }
            
            console.log(`Ê•ºÂ±Ç${floor}ÊÄªÂÖ±Â°´ÂÖÖ‰∫Ü${totalFilledRooms}‰∏™Ëø∑ÂÆ´ÊàøÈó¥`);
        }
        
        // Âú®ÊàøÈó¥ÂÜÖÈÉ®ÂàõÂª∫Ëø∑ÂÆ´
        function createMazeInRoom(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2; // ÁïôÂá∫ËæπË∑ù
            const roomHeight = parentRoom.height - 2;
            
            if (roomWidth < 4 || roomHeight < 4) return false;
            
            // Ê†πÊçÆÂØÜÂ∫¶Ë∞ÉÊï¥Ëø∑ÂÆ´ÁΩëÊ†ºÂ§ßÂ∞è
            const densityFactors = [0, 1.5, 1.2, 1.0, 0.8]; // ÂØÜÂ∫¶Ë∂äÈ´òÔºåÁΩëÊ†ºË∂äÂ∞èÔºàÊõ¥ÂØÜÈõÜÔºâ
            const gridSizeFactor = densityFactors[density];
            
            // ËÆ°ÁÆóËø∑ÂÆ´ÁΩëÊ†ºÂ§ßÂ∞èÔºàÊ†πÊçÆÂØÜÂ∫¶Ë∞ÉÊï¥Ôºâ
            const baseMazeWidth = Math.floor(roomWidth / 2);
            const baseMazeHeight = Math.floor(roomHeight / 2);
            const mazeWidth = Math.max(2, Math.floor(baseMazeWidth * gridSizeFactor));
            const mazeHeight = Math.max(2, Math.floor(baseMazeHeight * gridSizeFactor));
            
            console.log(`Ëø∑ÂÆ´ÁΩëÊ†º: ${mazeWidth}x${mazeHeight}, ÂØÜÂ∫¶: ${density}, ÁΩëÊ†ºÂõ†Â≠ê: ${gridSizeFactor}`);
            
            // ÂàõÂª∫Ëø∑ÂÆ´ÁΩëÊ†º
            const maze = createMazeGrid(mazeWidth, mazeHeight, density);
            
            // Â∞ÜËø∑ÂÆ´Â∫îÁî®Âà∞ÊàøÈó¥‰∏≠
            applyMazeToRoom(maze, parentRoom, floor, density);
            
            // ÂàõÂª∫ÂÖ•Âè£ÂíåÂá∫Âè£
            createMazeEntrances(parentRoom, floor, density);
            
            return true;
        }
        
        // ÂàõÂª∫Ëø∑ÂÆ´ÁΩëÊ†ºÔºà‰ΩøÁî®Ê∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ÁÆóÊ≥ïÔºâ
        function createMazeGrid(width, height, density) {
            // ÂàùÂßãÂåñËø∑ÂÆ´ÁΩëÊ†ºÔºåÊâÄÊúâÂ¢ôÈÉΩÊòØÂ∞ÅÈó≠ÁöÑ
            const maze = [];
            for (let y = 0; y < height * 2 + 1; y++) {
                maze[y] = [];
                for (let x = 0; x < width * 2 + 1; x++) {
                    maze[y][x] = 1; // 1Ë°®Á§∫Â¢ôÔºå0Ë°®Á§∫ÈÄöÈÅì
                }
            }
            
            // ‰ΩøÁî®Ê∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ÁîüÊàêËø∑ÂÆ´
            const stack = [];
            const visited = new Set();
            
            // ‰ªéÂ∑¶‰∏äËßíÂºÄÂßã
            const startX = 1;
            const startY = 1;
            stack.push([startX, startY]);
            visited.add(`${startX},${startY}`);
            maze[startY][startX] = 0;
            
            const directions = [
                [0, -2], // ‰∏ä
                [2, 0],  // Âè≥
                [0, 2],  // ‰∏ã
                [-2, 0]  // Â∑¶
            ];
            
            while (stack.length > 0) {
                const [currentX, currentY] = stack[stack.length - 1];
                
                // ÈöèÊú∫Êâì‰π±ÊñπÂêë
                const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                
                let moved = false;
                for (const [dx, dy] of shuffledDirections) {
                    const newX = currentX + dx;
                    const newY = currentY + dy;
                    
                    if (newX >= 1 && newX < width * 2 && newY >= 1 && newY < height * 2) {
                        const key = `${newX},${newY}`;
                        if (!visited.has(key)) {
                            // ÊâìÈÄöÂ¢ôÂ£Å
                            maze[currentY + dy/2][currentX + dx/2] = 0;
                            maze[newY][newX] = 0;
                            
                            visited.add(key);
                            stack.push([newX, newY]);
                            moved = true;
                            break;
                        }
                    }
                }
                
                if (!moved) {
                    stack.pop();
                }
            }
            
            // Ê†πÊçÆÂØÜÂ∫¶Ê∑ªÂä†È¢ùÂ§ñÁöÑÂ¢ôÂ£ÅÔºàÂ¢ûÂä†Ëø∑ÂÆ´Â§çÊùÇÂ∫¶Ôºâ
            addDensityWalls(maze, width, height, density);
            
            return maze;
        }
        
        // Ê†πÊçÆÂØÜÂ∫¶Ê∑ªÂä†È¢ùÂ§ñÁöÑÂ¢ôÂ£Å
        function addDensityWalls(maze, width, height, density) {
            const densityFactors = [0, 0.1, 0.2, 0.3, 0.5]; // ÂØÜÂ∫¶Ë∂äÈ´òÔºåÈ¢ùÂ§ñÂ¢ôÂ£ÅË∂äÂ§ö
            const extraWallChance = densityFactors[density];
            
            if (extraWallChance === 0) return;
            
            const totalCells = width * height;
            const extraWalls = Math.floor(totalCells * extraWallChance);
            
            console.log(`Ê∑ªÂä†${extraWalls}‰∏™È¢ùÂ§ñÂ¢ôÂ£ÅÔºåÂØÜÂ∫¶: ${density}, Ê¶ÇÁéá: ${extraWallChance}`);
            
            for (let i = 0; i < extraWalls; i++) {
                // ÈöèÊú∫ÈÄâÊã©‰ΩçÁΩÆÊ∑ªÂä†Â¢ôÂ£Å
                const x = 1 + Math.floor(Math.random() * (width - 1)) * 2;
                const y = 1 + Math.floor(Math.random() * (height - 1)) * 2;
                
                // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Ê∑ªÂä†Â¢ôÂ£ÅÔºà‰∏ç‰ºöÂÆåÂÖ®Â∞ÅÈó≠Âå∫ÂüüÔºâ
                if (canAddWall(maze, x, y)) {
                    maze[y][x] = 1;
                }
            }
        }
        
        // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Ê∑ªÂä†Â¢ôÂ£Å
        function canAddWall(maze, x, y) {
            // Ê£ÄÊü•Âë®Âõ¥ÊòØÂê¶ÊúâË∂≥Â§üÁöÑÈÄöÈÅì
            let channelCount = 0;
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length) {
                    if (maze[ny][nx] === 0) {
                        channelCount++;
                    }
                }
            }
            
            // Á°Æ‰øùËá≥Â∞ëÊúâ‰∏§‰∏™ÈÄöÈÅìËøûÊé•
            return channelCount >= 2;
        }
        
        // Â∞ÜËø∑ÂÆ´Â∫îÁî®Âà∞ÊàøÈó¥‰∏≠
        function applyMazeToRoom(maze, parentRoom, floor, density) {
            const startX = parentRoom.x + 1;
            const startY = parentRoom.y + 1;
            
            // Ê†πÊçÆÂØÜÂ∫¶Ë∞ÉÊï¥Â¢ôÂ£ÅÂéöÂ∫¶
            const wallThickness = Math.max(1, Math.floor(density / 2)); // ÂØÜÂ∫¶Ë∂äÈ´òÔºåÂ¢ôÂ£ÅË∂äÂéö
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    const worldX = startX + x;
                    const worldY = startY + y;
                    
                    if (worldX >= 0 && worldX < mapFloors[floor][0].length && 
                        worldY >= 0 && worldY < mapFloors[floor].length) {
                        if (mapFloors[floor][worldY] && mapFloors[floor][worldY][worldX] !== undefined) {
                            if (maze[y][x] === 1) {
                                // Â¢ôÂ£ÅÔºàÊ†πÊçÆÂØÜÂ∫¶Ë∞ÉÊï¥ÂéöÂ∫¶Ôºâ
                                for (let wy = 0; wy < wallThickness; wy++) {
                                    for (let wx = 0; wx < wallThickness; wx++) {
                                        const thickX = worldX + wx;
                                        const thickY = worldY + wy;
                                        if (thickX >= 0 && thickX < mapFloors[floor][0].length && 
                                            thickY >= 0 && thickY < mapFloors[floor].length) {
                                            if (mapFloors[floor][thickY] && mapFloors[floor][thickY][thickX] !== undefined) {
                                                mapFloors[floor][thickY][thickX] = TileType.WALL;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // ÈÄöÈÅì
                                mapFloors[floor][worldY][worldX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
            
            console.log(`Ëø∑ÂÆ´Â¢ôÂ£ÅÂéöÂ∫¶: ${wallThickness}, ÂØÜÂ∫¶: ${density}`);
        }
        
        // ÂàõÂª∫Ëø∑ÂÆ´ÂÖ•Âè£ÂíåÂá∫Âè£
        function createMazeEntrances(parentRoom, floor, density) {
            const roomWidth = parentRoom.width;
            const roomHeight = parentRoom.height;
            
            // Ê†πÊçÆÂØÜÂ∫¶Ë∞ÉÊï¥ÂÖ•Âè£Êï∞Èáè
            const entranceCount = Math.min(4, Math.max(1, Math.floor(density / 2) + 1));
            
            // ÂàõÂª∫Â§ö‰∏™ÂÖ•Âè£ÔºàÊ†πÊçÆÂØÜÂ∫¶Ôºâ
            for (let e = 0; e < entranceCount; e++) {
                // ÈöèÊú∫ÈÄâÊã©ÂÖ•Âè£‰ΩçÁΩÆÔºàÊàøÈó¥ËæπÁºòÔºâ
                const entranceSide = Math.floor(Math.random() * 4);
                let entranceX, entranceY;
                
                switch (entranceSide) {
                    case 0: // ‰∏äËæπ
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y;
                        break;
                    case 1: // Âè≥Ëæπ
                        entranceX = parentRoom.x + roomWidth - 1;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                    case 2: // ‰∏ãËæπ
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y + roomHeight - 1;
                        break;
                    case 3: // Â∑¶Ëæπ
                        entranceX = parentRoom.x;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                }
                
                // ÂàõÂª∫ÂÖ•Âè£Èó®
                if (entranceX >= 0 && entranceX < mapFloors[floor][0].length && 
                    entranceY >= 0 && entranceY < mapFloors[floor].length) {
                    if (mapFloors[floor][entranceY] && mapFloors[floor][entranceY][entranceX] !== undefined) {
                        mapFloors[floor][entranceY][entranceX] = TileType.DOOR;
                    }
                }
            }
            
            // Ê†πÊçÆÂØÜÂ∫¶Ë∞ÉÊï¥ÂÜÖÈÉ®Èó®Êï∞Èáè
            const internalDoorCount = Math.min(5, Math.max(1, density + 1));
            for (let i = 0; i < internalDoorCount; i++) {
                createRandomInternalDoor(parentRoom, floor, density);
            }
            
            console.log(`Ëø∑ÂÆ´ÂÖ•Âè£Êï∞Èáè: ${entranceCount}, ÂÜÖÈÉ®Èó®Êï∞Èáè: ${internalDoorCount}, ÂØÜÂ∫¶: ${density}`);
        }
        
        // ÂàõÂª∫ÈöèÊú∫ÂÜÖÈÉ®Èó®
        function createRandomInternalDoor(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2;
            const roomHeight = parentRoom.height - 2;
            
            let attempts = 0;
            const maxAttempts = 30; // Â¢ûÂä†Â∞ùËØïÊ¨°Êï∞
            
            while (attempts < maxAttempts) {
                const x = parentRoom.x + 1 + Math.floor(Math.random() * roomWidth);
                const y = parentRoom.y + 1 + Math.floor(Math.random() * roomHeight);
                
                if (x >= 0 && x < mapFloors[floor][0].length && 
                    y >= 0 && y < mapFloors[floor].length) {
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        if (mapFloors[floor][y][x] === TileType.WALL) {
                            // Ê†πÊçÆÂØÜÂ∫¶ÂÜ≥ÂÆöÊòØÂê¶ÂàõÂª∫Èó®ÔºàÂØÜÂ∫¶Ë∂äÈ´òÔºåË∂äÂÆπÊòìÂàõÂª∫Èó®Ôºâ
                            const doorChance = 0.3 + (density * 0.15); // 30% + ÂØÜÂ∫¶*15%
                            if (Math.random() < doorChance) {
                                mapFloors[floor][y][x] = TileType.DOOR;
                                return;
                            }
                        }
                    }
                }
                attempts++;
            }
        }
        

        
        // Ê∑ªÂä†Èò¥ÁÇπÔºàÂûÇÁõ¥Â∞èÂ¢ô‰ΩìÔºâ
        function addShadowPoints(density, floor = 0) {
            const mapSize = mapFloors[floor].length;
            const densityMultiplier = [0, 0.3, 0.8, 1.5, 2.5][density]; // Ë∞ÉÊï¥ÂØÜÂ∫¶ÂÄçÊï∞Ôºå‰ΩøÈªòËÆ§ÂÄºÊõ¥ÊòéÊòæ
            const shadowPointCount = Math.max(1, Math.floor(mapSize * mapSize * densityMultiplier / 150)); // Â¢ûÂä†Âü∫Á°ÄÊï∞Èáè
            
            console.log(`Ê•ºÂ±Ç${floor}Èò¥ÁÇπÂØÜÂ∫¶: ${density}, ÂÄçÊï∞: ${densityMultiplier}, ÁõÆÊ†áÊï∞Èáè: ${shadowPointCount}`);
            
            let createdCount = 0;
            for (let i = 0; i < shadowPointCount * 2; i++) { // Â¢ûÂä†Â∞ùËØïÊ¨°Êï∞
                // ÈöèÊú∫ÈÄâÊã©‰ΩçÁΩÆ
                let x, y;
                let attempts = 0;
                const maxAttempts = 30;
                
                do {
                    x = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    y = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    !isValidShadowPointPosition(x, y, floor)
                );
                
                if (attempts >= maxAttempts) continue;
                
                // ÂàõÂª∫Èò¥ÁÇπÔºàÂûÇÁõ¥Â∞èÂ¢ô‰ΩìÔºâ
                createShadowPoint(x, y, floor);
                createdCount++;
                
                if (createdCount >= shadowPointCount) break;
            }
            
            console.log(`Ê•ºÂ±Ç${floor}ÂÆûÈôÖÂàõÂª∫Èò¥ÁÇπÊï∞Èáè: ${createdCount}`);
        }
        
        // Ê£ÄÊü•Èò¥ÁÇπ‰ΩçÁΩÆÊòØÂê¶ÊúâÊïà
        function isValidShadowPointPosition(x, y, floor = 0) {
            // Ê£ÄÊü•ËæπÁïåÂíåÊï∞ÁªÑÊúâÊïàÊÄß
            if (x < 0 || x >= mapFloors[floor][0].length || 
                y < 0 || y >= mapFloors[floor].length ||
                !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                return false;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Âú®Âú∞ÊùøÊàñÈÅìË∑Ø‰∏ä
            if (mapFloors[floor][y][x] !== TileType.FLOOR &&
                mapFloors[floor][y][x] !== TileType.MEDIUM_GROUND &&
                mapFloors[floor][y][x] !== TileType.HIGH_GROUND &&
                mapFloors[floor][y][x] !== TileType.LOW_GROUND) {
                return false;
            }
            
            // Ê£ÄÊü•Âë®Âõ¥ÊòØÂê¶ÊúâË∂≥Â§üÁöÑÁ©∫Èó¥ÔºàÊîæÂÆΩÊù°‰ª∂Ôºâ
            let floorCount = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                            (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                             mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                            floorCount++;
                        }
                    }
                }
            }
            
            // Á°Æ‰øùÂë®Âõ¥ÊúâË∂≥Â§üÁöÑÂú∞ÊùøÁ©∫Èó¥ÔºàÈôç‰ΩéË¶ÅÊ±ÇÔºâ
            return floorCount >= 5;
        }
        
        // ÂàõÂª∫Âçï‰∏™Èò¥ÁÇπ
        function createShadowPoint(x, y, floor = 0) {
            const mapSize = mapFloors[floor].length;
            
            // ÈöèÊú∫ÂÜ≥ÂÆöÈò¥ÁÇπÁöÑÊñπÂêëÔºàÂûÇÁõ¥ÊàñÊ∞¥Âπ≥Ôºâ
            const isVertical = Math.random() < 0.7; // 70%Ê¶ÇÁéá‰∏∫ÂûÇÁõ¥
            const length = Math.floor(Math.random() * 3) + 2; // 2-4Ê†ºÈïøÂ∫¶
            
            if (isVertical) {
                // ÂàõÂª∫ÂûÇÁõ¥Èò¥ÁÇπ
                for (let i = 0; i < length; i++) {
                    const ny = y + i;
                    if (ny >= 0 && ny < mapSize && mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                        if (mapFloors[floor][ny][x] === TileType.FLOOR ||
                            mapFloors[floor][ny][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][ny][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][ny][x] === TileType.LOW_GROUND) {
                            mapFloors[floor][ny][x] = TileType.SHADOW_POINT;
                        }
                    }
                }
            } else {
                // ÂàõÂª∫Ê∞¥Âπ≥Èò¥ÁÇπ
                for (let i = 0; i < length; i++) {
                    const nx = x + i;
                    if (nx >= 0 && nx < mapSize && mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                        if (mapFloors[floor][y][nx] === TileType.FLOOR ||
                            mapFloors[floor][y][nx] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][nx] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][nx] === TileType.LOW_GROUND) {
                            mapFloors[floor][y][nx] = TileType.SHADOW_POINT;
                        }
                    }
                }
            }
        }
        
        // ÂàùÂßãÂåñ
        window.addEventListener('DOMContentLoaded', function() {
            document.getElementById('generateBtn').addEventListener('click', generateMap);
            document.getElementById('randomBtn').addEventListener('click', function() {
                randomizeParameters();
                generateMap();
            });
            document.getElementById('exportBtn').addEventListener('click', exportMap);
            
            // ÁßçÂ≠êÁ≥ªÁªü‰∫ã‰ª∂ÁõëÂê¨Âô®
            document.getElementById('saveSeedBtn').addEventListener('click', saveCurrentSeed);
            document.getElementById('clearSeedsBtn').addEventListener('click', clearAllSeeds);
            
            // Âä†ËΩΩ‰øùÂ≠òÁöÑÁßçÂ≠ê
            loadSeedsFromStorage();
            renderSeedsList();
            
            // ÁîüÊàêÂàùÂßãÂú∞Âõæ
            generateMap();
        });
    </script>
</body>
</html>