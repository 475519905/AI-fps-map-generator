<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CFé£æ ¼å¤šå±‚ç«æŠ€åœ°å›¾ç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            max-width: 1600px;
            width: 100%;
            border: 1px solid #333;
        }

        h1 {
            text-align: center;
            color: #f0f0f0;
            margin-bottom: 10px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 25px;
            font-size: 1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: bold;
            color: #999;
            margin-bottom: 5px;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
            background: #1a1a1a;
            color: #ccc;
            font-size: 13px;
            cursor: pointer;
        }

        select:hover {
            border-color: #4CAF50;
        }

        .value-display {
            color: #4CAF50;
            font-weight: bold;
            margin-left: 5px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex: 1;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-1px);
        }

        .export-btn {
            background: #2196F3;
        }

        .export-btn:hover {
            background: #1976D2;
        }

        .floor-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #333;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .overlay-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            margin-left: 20px;
        }
        
        .overlay-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .overlay-btn.active {
            background: linear-gradient(135deg, #764ba2, #667eea);
            border-color: #8a5ec7;
        }

        .floor-btn {
            padding: 10px 20px;
            background: #333;
            color: #999;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            min-width: 80px;
        }

        .floor-btn:hover {
            background: #444;
            color: #ccc;
        }

        .floor-btn.active {
            background: #4CAF50;
            color: white;
            border-color: #5CBF60;
        }

        #canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #333;
            border-radius: 4px;
            background: #000;
        }

        .map-header {
            background: linear-gradient(to right, #2c5f2d, #1a3d1a);
            color: white;
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .map-name {
            font-weight: bold;
            font-size: 16px;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-size: 0.85em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #444;
            border-radius: 2px;
        }
        
        /* ç§å­é¢æ¿æ ·å¼ */
        .seeds-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            width: 300px;
            background: #2a2a2a;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 15px;
            color: white;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .seeds-panel h3 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            text-align: center;
            font-size: 18px;
        }
        
        .seed-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .seed-controls button {
            flex: 1;
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .seed-controls button:hover {
            background: #45a049;
        }
        
        .seeds-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .seed-item {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .seed-item:hover {
            background: #4a4a4a;
            border-color: #4CAF50;
        }
        
        .seed-item.selected {
            background: #4CAF50;
            border-color: #45a049;
        }
        
        .seed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .seed-name {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .seed-date {
            font-size: 11px;
            color: #888;
        }
        
        .seed-params {
            font-size: 11px;
            color: #ccc;
            line-height: 1.3;
        }
        
        .seed-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
        .seed-actions button {
            padding: 4px 8px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: background 0.3s;
        }
        
        .seed-actions button:hover {
            background: #666;
        }
        
        .seed-actions button.delete {
            background: #d32f2f;
        }
        
        .seed-actions button.delete:hover {
            background: #b71c1c;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® CFé£æ ¼å¤šå±‚ç«æŠ€åœ°å›¾ç”Ÿæˆå™¨</h1>
        <div class="subtitle">ç”Ÿæˆå¤šå±‚çˆ†ç ´æ¨¡å¼ç«æŠ€åœ°å›¾</div>
        
        <div class="controls">
            <div class="control-group">
                <label>åœ°å›¾å°ºå¯¸: <span class="value-display" id="sizeValue">60</span></label>
                <input type="range" id="mapSize" min="40" max="800" value="60" step="10">
            </div>
            
            <div class="control-group">
                <label>åœ°å›¾å±‚æ•°: <span class="value-display" id="floorsValue">2</span></label>
                <input type="range" id="floorCount" min="1" max="10" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´æ•°é‡: <span class="value-display" id="roomValue">6</span></label>
                <input type="range" id="roomCount" min="3" max="100" value="6">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´å¤§å°: <span class="value-display" id="roomSizeValue">ä¸­</span></label>
                <input type="range" id="roomSize" min="0" max="4" value="2">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´ä½ç½®: </label>
                <select id="roomPosition">
                    <option value="random" selected>éšæœºä½ç½®</option>
                    <option value="inner">é“è·¯å†…ä¾§</option>
                    <option value="outer">é“è·¯å¤–ä¾§</option>
                    <option value="mixed">æ··åˆä½ç½®</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>èµ°å»Šå®½åº¦: <span class="value-display" id="corridorValue">2-4</span></label>
                <input type="range" id="corridorWidth" min="1" max="10" value="2">
            </div>
            
            <div class="control-group">
                <label>é“è·¯æ›²æŠ˜åº¦: <span class="value-display" id="pathValue">ä¸­</span></label>
                <input type="range" id="pathComplexity" min="0" max="4" value="2">
            </div>
            

            
            <div class="control-group">
                <label>èµ°å»Šæ¨¡å¼: </label>
                <select id="corridorRandom">
                    <option value="fixed">å›ºå®šå®½åº¦</option>
                    <option value="random" selected>éšæœºå®½åº¦</option>
                    <option value="varied">å˜åŒ–å®½åº¦</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æ©ä½“å¯†åº¦: <span class="value-display" id="coverValue">20</span>%</label>
                <input type="range" id="coverDensity" min="10" max="100" value="20" step="5">
            </div>
            
            <div class="control-group">
                <label>æ°´åŸŸ: <span class="value-display" id="waterValue">5</span>%</label>
                <input type="range" id="waterAmount" min="0" max="50" value="5" step="5">
            </div>
            
            <div class="control-group">
                <label>æ¥¼æ¢¯æ•°: <span class="value-display" id="stairsValue">3</span></label>
                <input type="range" id="stairsCount" min="1" max="20" value="3">
            </div>
            
            <div class="control-group">
                <label>çª—æˆ·å¯†åº¦: <span class="value-display" id="windowValue">30</span>%</label>
                <input type="range" id="windowDensity" min="10" max="100" value="30" step="10">
            </div>
            
            <div class="control-group">
                <label>é«˜ä½å·®: <span class="value-display" id="elevationValue">ä¸­</span></label>
                <input type="range" id="elevation" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>ç‹™å‡»é•¿é“: <span class="value-display" id="longValue">2</span></label>
                <input type="range" id="longLanes" min="0" max="20" value="2">
            </div>
            
            <div class="control-group">
                <label>ä¸­è·¯æ§åˆ¶: </label>
                <select id="midControl">
                    <option value="none">æ— ä¸­è·¯</option>
                    <option value="single" selected>å•ä¸­è·¯</option>
                    <option value="double">åŒä¸­è·¯</option>
                    <option value="complex">å¤æ‚ä¸­è·¯</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æ—‹è½¬æ—¶é—´: <span class="value-display" id="rotateValue">ä¸­</span></label>
                <input type="range" id="rotateTime" min="0" max="2" value="1">
            </div>
            
            <div class="control-group">
                <label>å‚ç›´åº¦: <span class="value-display" id="verticalValue">20</span>%</label>
                <input type="range" id="verticality" min="0" max="100" value="20" step="10">
            </div>
            
            <div class="control-group">
                <label>å¯ç ´åç‰©: <span class="value-display" id="breakValue">10</span>%</label>
                <input type="range" id="breakables" min="0" max="100" value="10" step="5">
            </div>
            
            <div class="control-group">
                <label>åœºåœ°å¸ƒå±€: </label>
                <select id="fieldLayout">
                    <option value="indoor" selected>çº¯å†…åœº</option>
                    <option value="outdoor">çº¯å¤–åœº</option>
                    <option value="mixed">æ··åˆåœºåœ°</option>
                    <option value="central_outdoor">ä¸­å¤®å¤–åœº</option>
                    <option value="peripheral_outdoor">è¾¹ç¼˜å¤–åœº</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æ¸¸æˆæ¨¡å¼: </label>
                <select id="gameMode">
                    <option value="team" selected>å›¢é˜Ÿç«æŠ€</option>
                    <option value="bomb">çˆ†ç ´æ¨¡å¼</option>
                    <option value="zombie">ç”ŸåŒ–æ¨¡å¼</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>åœ°å›¾é£æ ¼: </label>
                <select id="mapStyle">
                    <option value="balanced" selected>å¹³è¡¡å‹</option>
                    <option value="ct_sided">CTä¼˜åŠ¿</option>
                    <option value="t_sided">Tä¼˜åŠ¿</option>
                    <option value="aim_heavy">æªæ³•å‹</option>
                    <option value="tactical">æˆ˜æœ¯å‹</option>
                    <option value="rush">å¿«æ”»å‹</option>
                    <option value="black_town">é»‘è‰²åŸé•‡</option>
                    <option value="desert_gray">æ²™æ¼ ç°</option>
                    <option value="new_year_plaza">æ–°å¹´å¹¿åœº</option>
                    <option value="white_house">ç™½æˆ¿</option>
                    <option value="transport_ship">è¿è¾“èˆ¹</option>
                    <option value="satellite_base">å«æ˜ŸåŸºåœ°</option>
                    <option value="harbor_dock">æ¸¯å£ç å¤´</option>
                    <option value="subway_station">åœ°é“ç«™</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>å¤–åœºæ¯”ä¾‹: <span class="value-display" id="outdoorValue">20</span>%</label>
                <input type="range" id="outdoorRatio" min="0" max="100" value="20" step="5">
            </div>
            
            <div class="control-group">
                <label>å¤–åœºå°ºå¯¸: <span class="value-display" id="outdoorSizeValue">ä¸­</span></label>
                <input type="range" id="outdoorSize" min="0" max="2" value="1" step="1">
            </div>
            
            <div class="control-group">
                <label>å¤–åœºé¢ç§¯: <span class="value-display" id="outdoorAreaValue">ä¸­</span></label>
                <input type="range" id="outdoorArea" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ğŸ”¹ å¸¸è§åœ°å½¢/æ¨¡å—</label>
            </div>
            
            <div class="control-group">
                <label>å¤§é“ç”Ÿæˆ: <span class="value-display" id="longLaneValue">ä¸­</span></label>
                <input type="range" id="longLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>å°é“ç”Ÿæˆ: <span class="value-display" id="shortLaneValue">ä¸­</span></label>
                <input type="range" id="shortLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>ä¸­è·¯ç”Ÿæˆ: <span class="value-display" id="midLaneValue">ä¸­</span></label>
                <input type="range" id="midLane" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>é«˜å°ç”Ÿæˆ: <span class="value-display" id="platformValue">ä¸­</span></label>
                <input type="range" id="platform" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>æš—é“ç”Ÿæˆ: <span class="value-display" id="underpassValue">ä¸­</span></label>
                <input type="range" id="underpass" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>è¿æ¥è·¯ç”Ÿæˆ: <span class="value-display" id="connectorValue">ä¸­</span></label>
                <input type="range" id="connector" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>æ–œå¡ç”Ÿæˆ: <span class="value-display" id="rampValue">ä¸­</span></label>
                <input type="range" id="ramp" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>è½¬ç‚¹è·¯çº¿: <span class="value-display" id="rotationValue">ä¸­</span></label>
                <input type="range" id="rotation" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>åŒ…ç‚¹æ•°é‡: <span class="value-display" id="bombSiteValue">2</span></label>
                <input type="range" id="bombSiteCount" min="1" max="5" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>é˜´ç‚¹å¯†åº¦: <span class="value-display" id="shadowPointValue">ä¸­</span></label>
                <input type="range" id="shadowPoint" min="0" max="4" value="2" step="1">
            </div>
            
            <div class="control-group">
                <label>æˆ¿é—´å¡«å……: <span class="value-display" id="roomFillValue">æ— </span></label>
                <input type="range" id="roomFill" min="0" max="4" value="0" step="1">
            </div>
            
            <div class="control-group">
                <label>ç”Ÿæˆå¤§å…: </label>
                <select id="generateLobby">
                    <option value="none">æ— å¤§å…</option>
                    <option value="small" selected>å°å‹å¤§å…</option>
                    <option value="medium">ä¸­å‹å¤§å…</option>
                    <option value="large">å¤§å‹å¤§å…</option>
                    <option value="central">ä¸­å¤®å¤§å…</option>
                    <option value="circle">åœ†å½¢å¤§å…</option>
                    <option value="cross">åå­—å¤§å…</option>
                    <option value="square">æ–¹å½¢å¤§å…</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>æŠ•æ·ç‰©ç‚¹: <span class="value-display" id="nadeValue">15</span></label>
                <input type="range" id="nadeSpots" min="5" max="100" value="15" step="5">
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="generateBtn">ç”Ÿæˆåœ°å›¾</button>
                    <button id="randomBtn">éšæœºç”Ÿæˆ</button>
                    <button class="export-btn" id="exportBtn">å¯¼å‡º</button>
                </div>
            </div>
        </div>
        
        <div class="map-header">
            <div class="map-name" id="mapName">ç«æŠ€åœ°å›¾</div>
            <div>å¤šå±‚çˆ†ç ´æ¨¡å¼</div>
        </div>
        
        <div class="floor-selector" id="floorSelector"></div>
        
        <canvas id="canvas"></canvas>
        
        <div class="seeds-panel">
            <h3>ç§å­æ”¶è—</h3>
            <div class="seed-controls">
                <button id="saveSeedBtn">ğŸ’¾ ä¿å­˜å½“å‰ç§å­</button>
                <button id="clearSeedsBtn">ğŸ—‘ï¸ æ¸…ç©ºæ”¶è—</button>
            </div>
            <div class="seeds-list" id="seedsList">
                <!-- ç§å­åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #4a4a4a;"></div>
                <span>ä¸­ç­‰åœ°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a6a4a;"></div>
                <span>é«˜åœ°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a2a4a;"></div>
                <span>ä½åœ°</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #b0b0b0;"></div>
                <span>å¢™å£</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #303030;"></div>
                <span>æ©ä½“</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2a4d69;"></div>
                <span>æ°´åŸŸ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8B7355;"></div>
                <span>æ¥¼æ¢¯(ä¸Š)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6B5345;"></div>
                <span>æ¥¼æ¢¯(ä¸‹)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a8caf;"></div>
                <span>çª—æˆ·</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a5a00;"></div>
                <span>AåŒ…ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5a3a00;"></div>
                <span>BåŒ…ç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3a2020;"></div>
                <span>Tå‡ºç”Ÿç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #202030;"></div>
                <span>CTå‡ºç”Ÿç‚¹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a8a6a;"></div>
                <span>å¤–åœºåœ°é¢</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a8a7a;"></div>
                <span>å¤–åœºå›´å¢™</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6a7a8a;"></div>
                <span>å¤§å…</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8a6a7a;"></div>
                <span>å¤§å…å…¥å£</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #7a6a8a;"></div>
                <span>å¤§å…ä¸­å¿ƒ</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                <span>å åŠ è§†å›¾</span>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let mapFloors = [];
        let currentFloor = 0;
        let totalFloors = 2;
        let overlayMode = false;
        
        // åœ°å›¾å…ƒç´ ç±»å‹
        const TileType = {
            VOID: 0,
            FLOOR: 1,
            WALL: 2,
            DOOR: 3,
            WINDOW: 4,
            COVER: 5,
            BOMBSITE_A: 6,
            BOMBSITE_B: 7,
            BOMBSITE_C: 40, // æ–°å¢åŒ…ç‚¹C
            BOMBSITE_D: 41, // æ–°å¢åŒ…ç‚¹D
            BOMBSITE_E: 42, // æ–°å¢åŒ…ç‚¹E
            T_SPAWN: 8,
            CT_SPAWN: 9,
            STAIRS_UP: 10,
            STAIRS_DOWN: 11,
            WATER: 12,
            BRIDGE: 13,
            ELEVATED: 14,      // é«˜å°
            LOWERED: 15,       // ä½åœ°
            BREAKABLE: 16,     // å¯ç ´åå¢™
            HIGH_GROUND: 29,   // é«˜åœ°
            LOW_GROUND: 30,    // ä½åœ°
            MEDIUM_GROUND: 31, // ä¸­ç­‰åœ°
            LONG_LANE: 17,     // ç‹™å‡»é•¿é“
            MID_AREA: 18,      // ä¸­è·¯åŒºåŸŸ
            NADE_SPOT: 19,     // æŠ•æ·ç‰©ç‚¹
            BOOST_SPOT: 20,    // è·³ç‚¹ä½ç½®
            ONE_WAY: 21,       // å•å‘ä½ç½®
            OUTDOOR: 22,       // å¤–åœºåœ°é¢
            OUTDOOR_WALL: 23,  // å¤–åœºå¢™å£/å›´å¢™
            OUTDOOR_COVER: 24, // å¤–åœºæ©ä½“ï¼ˆé›†è£…ç®±ã€è½¦è¾†ç­‰ï¼‰
            SKYBOX: 25,       // å¤©ç©ºç›’åŒºåŸŸ
            LOBBY: 26,        // å¤§å…
            LOBBY_ENTRANCE: 27, // å¤§å…å…¥å£
            LOBBY_CENTER: 28,  // å¤§å…ä¸­å¿ƒ
            // å¸¸è§åœ°å½¢/æ¨¡å—
            LONG_LANE: 32,     // å¤§é“ï¼ˆé•¿ç›´é€šé“ï¼‰
            SHORT_LANE: 33,    // å°é“ï¼ˆçª„é€šé“ï¼‰
            MID_LANE: 34,      // ä¸­è·¯ï¼ˆäº¤æ±‡åŒºï¼‰
            PLATFORM: 35,      // é«˜å°/å¹³å°
            UNDERPASS: 36,     // æš—é“/ä¸‹æ°´é“
            CONNECTOR: 37,     // è¿æ¥è·¯
            RAMP: 38,          // æ–œå¡
            ROTATION_PATH: 39, // è½¬ç‚¹/è½®è½¬è·¯çº¿
            SHADOW_POINT: 43   // é˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
        };
        
        // æ›´æ–°æ»‘å—æ˜¾ç¤º
        document.getElementById('mapSize').oninput = function() {
            document.getElementById('sizeValue').textContent = this.value;
        };
        
        document.getElementById('floorCount').oninput = function() {
            document.getElementById('floorsValue').textContent = this.value;
        };
        
        document.getElementById('roomCount').oninput = function() {
            document.getElementById('roomValue').textContent = this.value;
        };
        
        document.getElementById('corridorWidth').oninput = function() {
            const val = parseInt(this.value);
            const mode = document.getElementById('corridorRandom').value;
            if (mode === 'fixed') {
                document.getElementById('corridorValue').textContent = val + 1;
            } else if (mode === 'random') {
                document.getElementById('corridorValue').textContent = val + '-' + (val + 2);
            } else {
                document.getElementById('corridorValue').textContent = '1-' + (val + 2);
            }
        };
        
        document.getElementById('coverDensity').oninput = function() {
            document.getElementById('coverValue').textContent = this.value;
        };
        
        document.getElementById('waterAmount').oninput = function() {
            document.getElementById('waterValue').textContent = this.value;
        };
        
        document.getElementById('stairsCount').oninput = function() {
            document.getElementById('stairsValue').textContent = this.value;
        };
        
        document.getElementById('outdoorRatio').oninput = function() {
            document.getElementById('outdoorValue').textContent = this.value;
        };
        
        document.getElementById('outdoorSize').oninput = function() {
            const values = ['å°', 'ä¸­', 'å¤§'];
            document.getElementById('outdoorSizeValue').textContent = values[this.value];
        };
        
        document.getElementById('outdoorArea').oninput = function() {
            const values = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
            document.getElementById('outdoorAreaValue').textContent = values[this.value];
        };
        
        // å¸¸è§åœ°å½¢/æ¨¡å—å‚æ•°äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('longLane').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('longLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('shortLane').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('shortLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('midLane').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('midLaneValue').textContent = values[this.value];
        };
        
        document.getElementById('platform').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('platformValue').textContent = values[this.value];
        };
        
        document.getElementById('underpass').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('underpassValue').textContent = values[this.value];
        };
        
        document.getElementById('connector').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('connectorValue').textContent = values[this.value];
        };
        
        document.getElementById('ramp').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('rampValue').textContent = values[this.value];
        };
        
        document.getElementById('rotation').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('rotationValue').textContent = values[this.value];
        };
        
        document.getElementById('bombSiteCount').oninput = function() {
            document.getElementById('bombSiteValue').textContent = this.value;
        };
        
        document.getElementById('shadowPoint').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('shadowPointValue').textContent = values[this.value];
        };
        
        document.getElementById('pathComplexity').oninput = function() {
            const values = ['ç›´çº¿', 'å¾®å¼¯', 'ä¸­ç­‰', 'æ›²æŠ˜', 'è¿·å®«'];
            document.getElementById('pathValue').textContent = values[this.value];
        };
        

        
        document.getElementById('elevation').oninput = function() {
            const values = ['ä½', 'ä¸­', 'é«˜'];
            document.getElementById('elevationValue').textContent = values[this.value];
        };
        
        document.getElementById('roomSize').oninput = function() {
            const values = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
            document.getElementById('roomSizeValue').textContent = values[this.value];
        };
        
        document.getElementById('roomFill').oninput = function() {
            const values = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('roomFillValue').textContent = values[this.value];
        };
        
        document.getElementById('longLanes').oninput = function() {
            document.getElementById('longValue').textContent = this.value;
        };
        
        document.getElementById('rotateTime').oninput = function() {
            const values = ['çŸ­', 'ä¸­', 'é•¿'];
            document.getElementById('rotateValue').textContent = values[this.value];
        };
        
        document.getElementById('verticality').oninput = function() {
            document.getElementById('verticalValue').textContent = this.value;
        };
        
        document.getElementById('breakables').oninput = function() {
            document.getElementById('breakValue').textContent = this.value;
        };
        
        document.getElementById('nadeSpots').oninput = function() {
            document.getElementById('nadeValue').textContent = this.value;
        };
        
        // æ¸¸æˆæ¨¡å¼é€‰æ‹©äº‹ä»¶
        document.getElementById('gameMode').onchange = function() {
            const gameMode = this.value;
            applyGameMode(gameMode);
        };
        
        // åœ°å›¾é£æ ¼é€‰æ‹©äº‹ä»¶
        document.getElementById('mapStyle').onchange = function() {
            const mapStyle = this.value;
            applyMapStyle(mapStyle);
        };
        
        // éšæœºç”Ÿæˆå‚æ•°
        function randomizeParameters() {
            // åœ°å›¾å°ºå¯¸å’Œæ¥¼å±‚æ•°ä¿æŒä¸å˜ï¼Œä¸éšæœºåŒ–
            
            // éšæœºæˆ¿é—´æ•°é‡ (3-100)
            
            // éšæœºæˆ¿é—´æ•°é‡ (3-100)
            const roomCount = Math.floor(Math.random() * 98) + 3;
            document.getElementById('roomCount').value = roomCount;
            document.getElementById('roomValue').textContent = roomCount;
            
            // éšæœºæˆ¿é—´å¤§å° (0-4)
            const roomSize = Math.floor(Math.random() * 5);
            document.getElementById('roomSize').value = roomSize;
            const roomSizeTexts = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
            document.getElementById('roomSizeValue').textContent = roomSizeTexts[roomSize];
            
            // éšæœºæˆ¿é—´ä½ç½®
            const roomPositions = ['random', 'inner', 'outer', 'mixed'];
            const roomPosition = roomPositions[Math.floor(Math.random() * roomPositions.length)];
            document.getElementById('roomPosition').value = roomPosition;
            
            // éšæœºèµ°å»Šå®½åº¦ (1-10)
            const corridorWidth = Math.floor(Math.random() * 10) + 1;
            document.getElementById('corridorWidth').value = corridorWidth;
            const corridorMode = document.getElementById('corridorRandom').value;
            if (corridorMode === 'fixed') {
                document.getElementById('corridorValue').textContent = corridorWidth + 1;
            } else if (corridorMode === 'random') {
                document.getElementById('corridorValue').textContent = corridorWidth + '-' + (corridorWidth + 2);
            } else {
                document.getElementById('corridorValue').textContent = '1-' + (corridorWidth + 2);
            }
            
            // éšæœºé“è·¯æ›²æŠ˜åº¦ (0-4)
            const pathComplexity = Math.floor(Math.random() * 5);
            document.getElementById('pathComplexity').value = pathComplexity;
            const complexityTexts = ['ç®€å•', 'è¾ƒç®€å•', 'ä¸­', 'è¾ƒå¤æ‚', 'å¤æ‚'];
            document.getElementById('pathValue').textContent = complexityTexts[pathComplexity];
            

            
            // éšæœºèµ°å»Šæ¨¡å¼
            const corridorModes = ['fixed', 'random', 'varied'];
            const corridorModeRandom = corridorModes[Math.floor(Math.random() * corridorModes.length)];
            document.getElementById('corridorRandom').value = corridorModeRandom;
            
            // éšæœºæ©ä½“å¯†åº¦ (10-100)
            const coverDensity = Math.floor(Math.random() * 91) + 10;
            document.getElementById('coverDensity').value = coverDensity;
            document.getElementById('coverValue').textContent = coverDensity;
            
            // éšæœºæ°´åŸŸ (0-50)
            const waterAmount = Math.floor(Math.random() * 51);
            document.getElementById('waterAmount').value = waterAmount;
            document.getElementById('waterValue').textContent = waterAmount;
            
            // éšæœºæ¥¼æ¢¯æ•° (1-20)
            const stairsCount = Math.floor(Math.random() * 20) + 1;
            document.getElementById('stairsCount').value = stairsCount;
            document.getElementById('stairsValue').textContent = stairsCount;
            
            // éšæœºçª—æˆ·å¯†åº¦ (10-100)
            const windowDensity = Math.floor(Math.random() * 91) + 10;
            document.getElementById('windowDensity').value = windowDensity;
            document.getElementById('windowValue').textContent = windowDensity;
            
            // éšæœºé«˜ä½å·® (0-2)
            const elevation = Math.floor(Math.random() * 3);
            document.getElementById('elevation').value = elevation;
            const elevationTexts = ['æ— ', 'ä¸­', 'é«˜'];
            document.getElementById('elevationValue').textContent = elevationTexts[elevation];
            
            // éšæœºç‹™å‡»é•¿é“ (0-20)
            const longLanes = Math.floor(Math.random() * 21);
            document.getElementById('longLanes').value = longLanes;
            document.getElementById('longValue').textContent = longLanes;
            
            // éšæœºä¸­è·¯æ§åˆ¶
            const midControls = ['none', 'single', 'double', 'complex'];
            const midControl = midControls[Math.floor(Math.random() * midControls.length)];
            document.getElementById('midControl').value = midControl;
            
            // éšæœºæ—‹è½¬æ—¶é—´ (0-2)
            const rotateTime = Math.floor(Math.random() * 3);
            document.getElementById('rotateTime').value = rotateTime;
            const rotateTexts = ['çŸ­', 'ä¸­', 'é•¿'];
            document.getElementById('rotateValue').textContent = rotateTexts[rotateTime];
            
            // éšæœºå‚ç›´åº¦ (0-100)
            const verticality = Math.floor(Math.random() * 101);
            document.getElementById('verticality').value = verticality;
            document.getElementById('verticalValue').textContent = verticality;
            
            // éšæœºå¯ç ´åç‰© (0-100)
            const breakables = Math.floor(Math.random() * 101);
            document.getElementById('breakables').value = breakables;
            document.getElementById('breakValue').textContent = breakables;
            
            // éšæœºåœºåœ°å¸ƒå±€
            const fieldLayouts = ['indoor', 'outdoor', 'mixed', 'central_outdoor', 'peripheral_outdoor'];
            const fieldLayout = fieldLayouts[Math.floor(Math.random() * fieldLayouts.length)];
            document.getElementById('fieldLayout').value = fieldLayout;
            
            // éšæœºæ¸¸æˆæ¨¡å¼
            const gameModes = ['team', 'bomb', 'zombie'];
            const gameMode = gameModes[Math.floor(Math.random() * gameModes.length)];
            document.getElementById('gameMode').value = gameMode;
            applyGameMode(gameMode);
            
            // éšæœºåœ°å›¾é£æ ¼
            const mapStyles = ['balanced', 'ct_sided', 't_sided', 'aim_heavy', 'tactical', 'rush', 
                              'black_town', 'desert_gray', 'new_year_plaza', 'white_house', 
                              'transport_ship', 'satellite_base', 'harbor_dock', 'subway_station'];
            const mapStyle = mapStyles[Math.floor(Math.random() * mapStyles.length)];
            document.getElementById('mapStyle').value = mapStyle;
            applyMapStyle(mapStyle);
            
            // éšæœºå¤–åœºæ¯”ä¾‹ (0-100)
            const outdoorRatio = Math.floor(Math.random() * 101);
            document.getElementById('outdoorRatio').value = outdoorRatio;
            document.getElementById('outdoorValue').textContent = outdoorRatio;
            
            // éšæœºå¤–åœºå°ºå¯¸ (0-2)
            const outdoorSize = Math.floor(Math.random() * 3);
            document.getElementById('outdoorSize').value = outdoorSize;
            const outdoorSizeTexts = ['å°', 'ä¸­', 'å¤§'];
            document.getElementById('outdoorSizeValue').textContent = outdoorSizeTexts[outdoorSize];
            
            // éšæœºå¤–åœºé¢ç§¯ (0-4)
            const outdoorArea = Math.floor(Math.random() * 5);
            document.getElementById('outdoorArea').value = outdoorArea;
            const outdoorAreaTexts = ['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'];
            document.getElementById('outdoorAreaValue').textContent = outdoorAreaTexts[outdoorArea];
            
            // éšæœºç”Ÿæˆå¤§å…
            const lobbyTypes = ['none', 'small', 'medium', 'large', 'central', 'circle', 'cross', 'square'];
            const lobbyType = lobbyTypes[Math.floor(Math.random() * lobbyTypes.length)];
            document.getElementById('generateLobby').value = lobbyType;
            
            // éšæœºå¸¸è§åœ°å½¢/æ¨¡å—å‚æ•°
            const longLane = Math.floor(Math.random() * 5);
            document.getElementById('longLane').value = longLane;
            const longLaneTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('longLaneValue').textContent = longLaneTexts[longLane];
            
            const shortLane = Math.floor(Math.random() * 5);
            document.getElementById('shortLane').value = shortLane;
            const shortLaneTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('shortLaneValue').textContent = shortLaneTexts[shortLane];
            
            const midLane = Math.floor(Math.random() * 5);
            document.getElementById('midLane').value = midLane;
            const midLaneTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('midLaneValue').textContent = midLaneTexts[midLane];
            
            const platform = Math.floor(Math.random() * 5);
            document.getElementById('platform').value = platform;
            const platformTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('platformValue').textContent = platformTexts[platform];
            
            const underpass = Math.floor(Math.random() * 5);
            document.getElementById('underpass').value = underpass;
            const underpassTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('underpassValue').textContent = underpassTexts[underpass];
            
            const connector = Math.floor(Math.random() * 5);
            document.getElementById('connector').value = connector;
            const connectorTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('connectorValue').textContent = connectorTexts[connector];
            
            const ramp = Math.floor(Math.random() * 5);
            document.getElementById('ramp').value = ramp;
            const rampTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('rampValue').textContent = rampTexts[ramp];
            
            const rotation = Math.floor(Math.random() * 5);
            document.getElementById('rotation').value = rotation;
            const rotationTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('rotationValue').textContent = rotationTexts[rotation];
            
            // éšæœºåŒ…ç‚¹æ•°é‡ (1-5)
            const bombSiteCount = Math.floor(Math.random() * 5) + 1;
            document.getElementById('bombSiteCount').value = bombSiteCount;
            document.getElementById('bombSiteValue').textContent = bombSiteCount;
            
            // éšæœºé˜´ç‚¹å¯†åº¦ (0-4)
            const shadowPoint = Math.floor(Math.random() * 5);
            document.getElementById('shadowPoint').value = shadowPoint;
            const shadowPointTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('shadowPointValue').textContent = shadowPointTexts[shadowPoint];
            
            // éšæœºæˆ¿é—´å¡«å…… (0-4)
            const roomFill = Math.floor(Math.random() * 5);
            document.getElementById('roomFill').value = roomFill;
            const roomFillTexts = ['æ— ', 'å°‘', 'ä¸­', 'å¤š', 'æå¤š'];
            document.getElementById('roomFillValue').textContent = roomFillTexts[roomFill];
            
            // éšæœºæŠ•æ·ç‰©ç‚¹ (5-100)
            const nadeSpots = Math.floor(Math.random() * 96) + 5;
            document.getElementById('nadeSpots').value = nadeSpots;
            document.getElementById('nadeValue').textContent = nadeSpots;
        }
        
        // åˆå§‹åŒ–åœ°å›¾
        function initMap(size, floors) {
            mapFloors = [];
            totalFloors = floors;
            
            for (let f = 0; f < floors; f++) {
                mapFloors[f] = [];
                for (let y = 0; y < size; y++) {
                    mapFloors[f][y] = [];
                    for (let x = 0; x < size; x++) {
                        mapFloors[f][y][x] = TileType.VOID;
                    }
                }
            }
        }
        
        // ç”Ÿæˆæˆ¿é—´ï¼ˆæ”¯æŒå†…å¤–åœºï¼‰
        function generateRooms(size, roomCount, floor) {
            const rooms = [];
            // æ ¹æ®æˆ¿é—´å¤§å°å‚æ•°è°ƒæ•´æˆ¿é—´å°ºå¯¸
            const roomSizeParam = parseInt(document.getElementById('roomSize').value);
            const roomSizeMultipliers = [0.2, 0.4, 0.8, 1.5, 2.5]; // æå°ã€å°ã€ä¸­ã€å¤§ã€æå¤§ - å¢åŠ å·®å¼‚
            const roomSizeMultiplier = roomSizeMultipliers[roomSizeParam];
            
            const minRoomSize = Math.max(2, Math.floor(size / 25 * roomSizeMultiplier)); // æœ€å°æˆ¿é—´å°ºå¯¸
            const maxRoomSize = Math.max(minRoomSize + 1, Math.floor(size / 4 * roomSizeMultiplier)); // æœ€å¤§æˆ¿é—´å°ºå¯¸ï¼Œç§»é™¤ç¡¬ç¼–ç é™åˆ¶
            const fieldLayout = document.getElementById('fieldLayout').value;
            const outdoorRatio = parseInt(document.getElementById('outdoorRatio').value) / 100;
            const roomPosition = document.getElementById('roomPosition').value; // æˆ¿é—´ç”Ÿæˆä½ç½®
            
            // å…ˆåˆ›å»ºå¤–åœºåŒºåŸŸ
            if (floor === 0 && fieldLayout !== 'indoor') {
                createOutdoorAreas(size, fieldLayout, outdoorRatio);
            }
            
            // è®¡ç®—æˆ¿é—´é—´è·ï¼ˆç¡®ä¿æˆ¿é—´ç‹¬ç«‹ï¼‰
            const minSpacing = Math.max(1, Math.floor(size / 50)); // è¿›ä¸€æ­¥å‡å°é—´è·
            
            for (let i = 0; i < roomCount * 100; i++) { // è¿›ä¸€æ­¥å¢åŠ å°è¯•æ¬¡æ•°
                const width = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                const height = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
                
                // æ ¹æ®æˆ¿é—´ç”Ÿæˆä½ç½®å‚æ•°å†³å®šæˆ¿é—´ä½ç½®
                let x, y;
                const centerX = Math.floor(size / 2);
                const centerY = Math.floor(size / 2);
                const roadRadius = Math.floor(size / 3); // å‡è®¾é“è·¯åœ¨ä¸­å¿ƒåŒºåŸŸ
                
                switch(roomPosition) {
                    case 'inner':
                        // é“è·¯å†…ä¾§ï¼ˆé è¿‘ä¸­å¿ƒï¼‰
                        const innerRadius = Math.floor(size / 4);
                        const angle = Math.random() * 2 * Math.PI;
                        const distance = Math.random() * innerRadius;
                        x = Math.floor(centerX + Math.cos(angle) * distance);
                        y = Math.floor(centerY + Math.sin(angle) * distance);
                        break;
                    case 'outer':
                        // é“è·¯å¤–ä¾§ï¼ˆè¿œç¦»ä¸­å¿ƒï¼‰
                        const outerRadius = Math.floor(size / 2.5);
                        const outerAngle = Math.random() * 2 * Math.PI;
                        const outerDistance = outerRadius + Math.random() * (size / 2 - outerRadius);
                        x = Math.floor(centerX + Math.cos(outerAngle) * outerDistance);
                        y = Math.floor(centerY + Math.sin(outerAngle) * outerDistance);
                        break;
                    case 'mixed':
                        // æ··åˆä½ç½®
                        if (Math.random() > 0.5) {
                            // å†…ä¾§
                            const mixedAngle = Math.random() * 2 * Math.PI;
                            const mixedDistance = Math.random() * (size / 3);
                            x = Math.floor(centerX + Math.cos(mixedAngle) * mixedDistance);
                            y = Math.floor(centerY + Math.sin(mixedAngle) * mixedDistance);
                        } else {
                            // å¤–ä¾§
                            const mixedOuterAngle = Math.random() * 2 * Math.PI;
                            const mixedOuterDistance = (size / 3) + Math.random() * (size / 2 - size / 3);
                            x = Math.floor(centerX + Math.cos(mixedOuterAngle) * mixedOuterDistance);
                            y = Math.floor(centerY + Math.sin(mixedOuterAngle) * mixedOuterDistance);
                        }
                        break;
                    default: // 'random'
                        // éšæœºä½ç½®
                        x = Math.floor(Math.random() * (size - width - minSpacing * 2)) + minSpacing;
                        y = Math.floor(Math.random() * (size - height - minSpacing * 2)) + minSpacing;
                        break;
                }
                
                // ç¡®ä¿æˆ¿é—´åœ¨è¾¹ç•Œå†…
                x = Math.max(minSpacing, Math.min(x, size - width - minSpacing));
                y = Math.max(minSpacing, Math.min(y, size - height - minSpacing));
                
                // é¢å¤–æ£€æŸ¥ï¼šç¡®ä¿æˆ¿é—´å®Œå…¨åœ¨åœ°å›¾èŒƒå›´å†…
                if (x < 0 || y < 0 || x + width > size || y + height > size) {
                    continue; // è·³è¿‡è¿™ä¸ªæˆ¿é—´ï¼Œå°è¯•ä¸‹ä¸€ä¸ª
                }
                
                // è°ƒè¯•ï¼šæ˜¾ç¤ºæˆ¿é—´ä½ç½®ä¿¡æ¯
                if (rooms.length < 3) {
                    console.log(`æˆ¿é—´${rooms.length + 1}: ä½ç½®(${x},${y}), å°ºå¯¸(${width}x${height}), ä½ç½®ç±»å‹: ${roomPosition}`);
                }
                
                // æ£€æŸ¥ä¸ç°æœ‰æˆ¿é—´çš„é‡å å’Œé—´è·
                let canPlace = true;
                for (let room of rooms) {
                    // æ£€æŸ¥é‡å ï¼ˆå‡å°‘é—´è·è¦æ±‚ï¼‰
                    const expandedX = room.x - Math.floor(minSpacing / 2);
                    const expandedY = room.y - Math.floor(minSpacing / 2);
                    const expandedWidth = room.width + Math.floor(minSpacing / 2) * 2;
                    const expandedHeight = room.height + Math.floor(minSpacing / 2) * 2;
                    
                    if (x < expandedX + expandedWidth && x + width > expandedX &&
                        y < expandedY + expandedHeight && y + height > expandedY) {
                        canPlace = false;
                        break;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸å¤–åœºé‡å ï¼ˆå¤–åœºä¼˜å…ˆï¼‰
                if (canPlace && floor === 0) {
                    for (let cy = y - 1; cy < y + height + 1; cy++) {
                        for (let cx = x - 1; cx < x + width + 1; cx++) {
                            if (cy >= 0 && cy < size && cx >= 0 && cx < size) {
                            if (mapFloors[floor][cy] && mapFloors[floor][cy][cx] === TileType.OUTDOOR) {
                                    canPlace = false;
                                break;
                            }
                        }
                        }
                        if (!canPlace) break;
                    }
                }
                
                if (canPlace) {
                    rooms.push({ x, y, width, height, floor, isIndoor: true });
                    
                    // ç»˜åˆ¶æˆ¿é—´ï¼ˆå†…åœºï¼‰- ç¡®ä¿å¢™å£å®Œæ•´
                    for (let ry = y; ry < y + height; ry++) {
                        for (let rx = x; rx < x + width; rx++) {
                            if (ry === y || ry === y + height - 1 || rx === x || rx === x + width - 1) {
                                // æˆ¿é—´è¾¹ç•Œå¢™å£
                                        mapFloors[floor][ry][rx] = TileType.WALL;
                                } else {
                                // æˆ¿é—´å†…éƒ¨åœ°æ¿
                                mapFloors[floor][ry][rx] = TileType.FLOOR;
                            }
                        }
                    }
                    
                    // åœ¨æˆ¿é—´å‘¨å›´æ·»åŠ ç¼“å†²åŒºï¼ˆå‡å°‘ç¼“å†²åŒºå¤§å°ï¼‰
                    addRoomBuffer(x, y, width, height, floor, size, Math.floor(minSpacing / 2));
                    
                    if (rooms.length >= roomCount) break;
                }
            }
            
            // è°ƒè¯•ä¿¡æ¯ï¼šæ˜¾ç¤ºå®é™…ç”Ÿæˆçš„æˆ¿é—´æ•°é‡
            console.log(`ç›®æ ‡æˆ¿é—´æ•°é‡: ${roomCount}, å®é™…ç”Ÿæˆæˆ¿é—´æ•°é‡: ${rooms.length}`);
            console.log(`æˆ¿é—´å°ºå¯¸èŒƒå›´: ${minRoomSize}-${maxRoomSize}, é—´è·: ${minSpacing}`);
            console.log(`åœ°å›¾å¤§å°: ${size}x${size}, æˆ¿é—´å¤§å°å€æ•°: ${roomSizeMultiplier}`);
            console.log(`æˆ¿é—´å¤§å°å‚æ•°: ${roomSizeParam} (${['æå°', 'å°', 'ä¸­', 'å¤§', 'æå¤§'][roomSizeParam]})`);
            console.log(`å°è¯•æ¬¡æ•°: ${roomCount * 100}, æˆåŠŸç‡: ${(rooms.length / roomCount * 100).toFixed(1)}%`);
            
            return rooms;
        }
        
        // åˆ›å»ºå¤–åœºåŒºåŸŸ
        function createOutdoorAreas(size, layout, ratio) {
            const outdoorSize = parseInt(document.getElementById('outdoorSize').value);
            const outdoorArea = parseInt(document.getElementById('outdoorArea').value);
            const sizeMultiplier = [0.5, 1.0, 1.5][outdoorSize]; // å°ã€ä¸­ã€å¤§
            const areaMultiplier = [0.3, 0.6, 1.0, 1.5, 2.0][outdoorArea]; // æå°ã€å°ã€ä¸­ã€å¤§ã€æå¤§
            const outdoorTiles = Math.floor(size * size * ratio * sizeMultiplier * areaMultiplier);
            
            switch(layout) {
                case 'outdoor':
                    // å…¨å¤–åœº
                    for (let y = 0; y < size; y++) {
                        for (let x = 0; x < size; x++) {
                            mapFloors[0][y][x] = TileType.OUTDOOR;
                        }
                    }
                    break;
                    
                case 'central_outdoor':
                    // ä¸­å¤®å¤–åœºï¼ˆè§„åˆ™çŸ©å½¢ï¼‰
                    const centerX = Math.floor(size / 2);
                    const centerY = Math.floor(size / 2);
                    const areaWidth = Math.floor(size * Math.sqrt(ratio));
                    const areaHeight = Math.floor(size * Math.sqrt(ratio));
                    
                    const startX = Math.max(0, centerX - Math.floor(areaWidth / 2));
                    const endX = Math.min(size - 1, centerX + Math.floor(areaWidth / 2));
                    const startY = Math.max(0, centerY - Math.floor(areaHeight / 2));
                    const endY = Math.min(size - 1, centerY + Math.floor(areaHeight / 2));
                    
                    for (let y = startY; y <= endY; y++) {
                        for (let x = startX; x <= endX; x++) {
                                    mapFloors[0][y][x] = TileType.OUTDOOR;
                        }
                    }
                    break;
                    
                case 'peripheral_outdoor':
                    // è¾¹ç¼˜å¤–åœºï¼ˆè§„åˆ™è¾¹æ¡†ï¼‰
                    const margin = Math.floor((1 - Math.sqrt(1 - ratio)) * size / 2);
                    
                    for (let y = 0; y < size; y++) {
                        for (let x = 0; x < size; x++) {
                            if (x < margin || x >= size - margin || 
                                y < margin || y >= size - margin) {
                                mapFloors[0][y][x] = TileType.OUTDOOR;
                            }
                        }
                    }
                    break;
                    
                case 'mixed':
                default:
                    // æ··åˆåœºåœ°ï¼ˆè§„åˆ™çŸ©å½¢åŒºåŸŸï¼‰
                    const numOutdoorAreas = 2 + Math.floor(Math.random() * 2); // 2-3ä¸ªåŒºåŸŸ
                    const areaSize = Math.floor(Math.sqrt(outdoorTiles / numOutdoorAreas));
                    
                    for (let i = 0; i < numOutdoorAreas; i++) {
                        // ç¡®ä¿åŒºåŸŸä¸é‡å 
                        let attempts = 0;
                        let placed = false;
                        
                        // é™åˆ¶åŒºåŸŸå¤§å°ï¼Œé¿å…è¶…å‡ºè¾¹ç•Œ
                        const maxAreaSize = Math.min(areaSize, Math.floor(size / 4));
                        
                        while (!placed && attempts < 50) {
                            const cx = Math.floor(Math.random() * (size - maxAreaSize * 2)) + maxAreaSize;
                            const cy = Math.floor(Math.random() * (size - maxAreaSize * 2)) + maxAreaSize;
                        
                            // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰å¤–åœºåŒºåŸŸé‡å 
                            let overlaps = false;
                            for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                if (x >= 0 && x < size && y >= 0 && y < size) {
                                        if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                                            overlaps = true;
                                            break;
                                        }
                                    }
                                }
                                if (overlaps) break;
                            }
                            
                            if (!overlaps) {
                                // åˆ›å»ºè§„åˆ™çŸ©å½¢å¤–åœºåŒºåŸŸ
                                for (let y = cy - maxAreaSize; y <= cy + maxAreaSize; y++) {
                                    for (let x = cx - maxAreaSize; x <= cx + maxAreaSize; x++) {
                                        if (x >= 0 && x < size && y >= 0 && y < size) {
                                        mapFloors[0][y][x] = TileType.OUTDOOR;
                                    }
                                }
                            }
                                placed = true;
                            }
                            attempts++;
                        }
                        
                        // å¦‚æœæ— æ³•æ”¾ç½®ï¼Œåœ¨è§’è½åˆ›å»ºå°åŒºåŸŸ
                        if (!placed) {
                            const cornerSize = Math.min(maxAreaSize, 10); // é™åˆ¶è§’è½åŒºåŸŸå¤§å°
                            const cornerX = (i % 2 === 0) ? cornerSize : size - cornerSize - 1;
                            const cornerY = (i < 2) ? cornerSize : size - cornerSize - 1;
                            
                            for (let y = cornerY - cornerSize; y <= cornerY + cornerSize; y++) {
                                for (let x = cornerX - cornerSize; x <= cornerX + cornerSize; x++) {
                                    if (x >= 0 && x < size && y >= 0 && y < size) {
                                        mapFloors[0][y][x] = TileType.OUTDOOR;
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
            
            // åœ¨å¤–åœºæ·»åŠ ä¸€äº›æ©ä½“å’Œç‰¹å¾
            addOutdoorFeatures(size);
        }
        
        // ç”Ÿæˆå¤§å…
        function generateLobby(size, floor) {
            const lobbyType = document.getElementById('generateLobby').value;
            
            if (lobbyType === 'none') return;
            
            let lobbyWidth, lobbyHeight, lobbyX, lobbyY;
            
            switch(lobbyType) {
                case 'small':
                    lobbyWidth = 8;
                    lobbyHeight = 6;
                    break;
                case 'medium':
                    lobbyWidth = 12;
                    lobbyHeight = 8;
                    break;
                case 'large':
                    lobbyWidth = 16;
                    lobbyHeight = 10;
                    break;
                case 'central':
                    lobbyWidth = 14;
                    lobbyHeight = 12;
                    break;
                case 'circle':
                    lobbyWidth = 12;
                    lobbyHeight = 12;
                    break;
                case 'cross':
                    lobbyWidth = 15;
                    lobbyHeight = 15;
                    break;
                case 'square':
                    lobbyWidth = 14;
                    lobbyHeight = 14;
                    break;
                default:
                    return;
            }
            
            // ç¡®å®šå¤§å…ä½ç½®
            if (lobbyType === 'central') {
                // ä¸­å¤®å¤§å…
                lobbyX = Math.floor((size - lobbyWidth) / 2);
                lobbyY = Math.floor((size - lobbyHeight) / 2);
            } else {
                // éšæœºä½ç½®ï¼Œä½†é¿å…ä¸å¤–åœºé‡å 
                let attempts = 0;
                do {
                    lobbyX = Math.floor(Math.random() * (size - lobbyWidth - 4)) + 2;
                    lobbyY = Math.floor(Math.random() * (size - lobbyHeight - 4)) + 2;
                    attempts++;
                } while (hasOutdoorOverlap(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) && attempts < 50);
                
                if (attempts >= 50) return; // å¦‚æœæ‰¾ä¸åˆ°åˆé€‚ä½ç½®ï¼Œè·³è¿‡
            }
            
            // ç¡®ä¿å¤§å…å®Œå…¨åœ¨åœ°å›¾èŒƒå›´å†…
            if (lobbyX < 0 || lobbyY < 0 || lobbyX + lobbyWidth > size || lobbyY + lobbyHeight > size) {
                return; // å¦‚æœå¤§å…è¶…å‡ºè¾¹ç•Œï¼Œè·³è¿‡
            }
            
            // æ ¹æ®å¤§å…ç±»å‹åˆ›å»ºä¸åŒå½¢çŠ¶
            switch(lobbyType) {
                case 'circle':
                    createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'cross':
                    createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                case 'square':
                    createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
                default:
                    createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
                    break;
            }
            
            // æ·»åŠ å¤§å…å…¥å£
            addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
            
            // è¿æ¥å¤§å…åˆ°å…¶ä»–åŒºåŸŸ
            connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor);
        }
        
        // åˆ›å»ºçŸ©å½¢å¤§å…
        function createRectangularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // å¢™å£
                        mapFloors[floor][y][x] = TileType.WALL;
                    } else {
                        // å¤§å…å†…éƒ¨
                        if (x === Math.floor(lobbyX + lobbyWidth / 2) && 
                            y === Math.floor(lobbyY + lobbyHeight / 2)) {
                            mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
        }
        
        // åˆ›å»ºåœ†å½¢å¤§å…
        function createCircularLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const radius = Math.min(lobbyWidth, lobbyHeight) / 2 - 1;
            
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    
                    if (distance <= radius) {
                        // å¤§å…å†…éƒ¨
                        if (distance <= 1) {
                            mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    } else if (distance <= radius + 1) {
                        // å¢™å£
                        mapFloors[floor][y][x] = TileType.WALL;
                    }
                }
            }
        }
        
        // åˆ›å»ºåå­—å¤§å…
        function createCrossLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const armWidth = 3;
            const armLength = Math.min(lobbyWidth, lobbyHeight) / 2 - 2;
            
            // æ¸…ç©ºåŒºåŸŸ
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    mapFloors[floor][y][x] = TileType.VOID;
                }
            }
            
            // åˆ›å»ºåå­—å½¢çŠ¶
            // æ°´å¹³è‡‚
            for (let y = centerY - armWidth; y <= centerY + armWidth; y++) {
                for (let x = centerX - armLength; x <= centerX + armLength; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (x === centerX - armLength || x === centerX + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // å‚ç›´è‡‚
            for (let y = centerY - armLength; y <= centerY + armLength; y++) {
                for (let x = centerX - armWidth; x <= centerX + armWidth; x++) {
                    if (x >= lobbyX && x < lobbyX + lobbyWidth && y >= lobbyY && y < lobbyY + lobbyHeight) {
                        if (y === centerY - armLength || y === centerY + armLength) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        } else {
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
            
            // ä¸­å¿ƒç‚¹
            mapFloors[floor][centerY][centerX] = TileType.LOBBY_CENTER;
            
            // æ·»åŠ å¤–éƒ¨å¢™å£
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (mapFloors[floor][y][x] === TileType.VOID) {
                        // æ£€æŸ¥æ˜¯å¦ä¸å¤§å…å†…éƒ¨ç›¸é‚»
                        let adjacentToLobby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= lobbyX && nx < lobbyX + lobbyWidth && 
                                    ny >= lobbyY && ny < lobbyY + lobbyHeight) {
                                    if (mapFloors[floor][ny][nx] === TileType.LOBBY || 
                                        mapFloors[floor][ny][nx] === TileType.LOBBY_CENTER) {
                                        adjacentToLobby = true;
                                        break;
                                    }
                                }
                            }
                            if (adjacentToLobby) break;
                        }
                        if (adjacentToLobby) {
                            mapFloors[floor][y][x] = TileType.WALL;
                        }
                    }
                }
            }
        }
        
        // åˆ›å»ºæ–¹å½¢å¤§å…
        function createSquareLobby(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const centerX = Math.floor(lobbyX + lobbyWidth / 2);
            const centerY = Math.floor(lobbyY + lobbyHeight / 2);
            const innerSize = Math.min(lobbyWidth, lobbyHeight) - 4;
            
            // åˆ›å»ºå¤–éƒ¨æ–¹å½¢
            for (let y = lobbyY; y < lobbyY + lobbyHeight; y++) {
                for (let x = lobbyX; x < lobbyX + lobbyWidth; x++) {
                    if (y === lobbyY || y === lobbyY + lobbyHeight - 1 || 
                        x === lobbyX || x === lobbyX + lobbyWidth - 1) {
                        // å¤–éƒ¨å¢™å£
                        mapFloors[floor][y][x] = TileType.WALL;
                    } else {
                        // å†…éƒ¨åŒºåŸŸ
                        const innerX = Math.floor((lobbyWidth - innerSize) / 2);
                        const innerY = Math.floor((lobbyHeight - innerSize) / 2);
                        
                        if (x >= lobbyX + innerX && x < lobbyX + innerX + innerSize &&
                            y >= lobbyY + innerY && y < lobbyY + innerY + innerSize) {
                            // å†…éƒ¨æ–¹å½¢
                            if (x === lobbyX + innerX || x === lobbyX + innerX + innerSize - 1 ||
                                y === lobbyY + innerY || y === lobbyY + innerY + innerSize - 1) {
                                // å†…éƒ¨å¢™å£
                                mapFloors[floor][y][x] = TileType.WALL;
                            } else {
                                // å†…éƒ¨ç©ºé—´
                                if (x === centerX && y === centerY) {
                                    mapFloors[floor][y][x] = TileType.LOBBY_CENTER;
                                } else {
                                    mapFloors[floor][y][x] = TileType.LOBBY;
                                }
                            }
                        } else {
                            // ä¸­é—´åŒºåŸŸï¼ˆèµ°å»Šï¼‰
                            mapFloors[floor][y][x] = TileType.LOBBY;
                        }
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸å¤–åœºé‡å 
        function hasOutdoorOverlap(x, y, width, height, floor) {
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length &&
                        mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                        if (mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // æ·»åŠ å¤§å…å…¥å£
        function addLobbyEntrances(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            const entranceCount = 2 + Math.floor(Math.random() * 2); // 2-3ä¸ªå…¥å£
            
            for (let i = 0; i < entranceCount; i++) {
                let entranceX, entranceY;
                
                // éšæœºé€‰æ‹©å…¥å£ä½ç½®ï¼ˆå››è¾¹ï¼‰
                const side = Math.floor(Math.random() * 4);
                
                switch(side) {
                    case 0: // ä¸Šè¾¹
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY;
                        break;
                    case 1: // ä¸‹è¾¹
                        entranceX = lobbyX + Math.floor(lobbyWidth / 2);
                        entranceY = lobbyY + lobbyHeight - 1;
                        break;
                    case 2: // å·¦è¾¹
                        entranceX = lobbyX;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                    case 3: // å³è¾¹
                        entranceX = lobbyX + lobbyWidth - 1;
                        entranceY = lobbyY + Math.floor(lobbyHeight / 2);
                        break;
                }
                
                // åˆ›å»ºå…¥å£
                mapFloors[floor][entranceY][entranceX] = TileType.LOBBY_ENTRANCE;
                
                // åˆ›å»ºå…¥å£é€šé“
                createEntrancePath(entranceX, entranceY, floor);
            }
        }
        
        // åˆ›å»ºå…¥å£é€šé“
        function createEntrancePath(entranceX, entranceY, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const pathLength = 3 + Math.floor(Math.random() * 3); // 3-5æ ¼é•¿
            
            for (let [dx, dy] of directions) {
                let canCreatePath = true;
                
                // æ£€æŸ¥è·¯å¾„æ–¹å‘æ˜¯å¦å¯è¡Œ
                for (let i = 1; i <= pathLength; i++) {
                    const nx = entranceX + dx * i;
                    const ny = entranceY + dy * i;
                    
                    if (nx < 0 || nx >= mapFloors[floor][0].length || 
                        ny < 0 || ny >= mapFloors[floor].length ||
                        !mapFloors[floor][ny] || mapFloors[floor][ny][nx] === undefined) {
                        canCreatePath = false;
                        break;
                    }
                    
                    if (mapFloors[floor][ny][nx] !== TileType.VOID && 
                        mapFloors[floor][ny][nx] !== TileType.OUTDOOR) {
                        canCreatePath = false;
                        break;
                    }
                }
                
                if (canCreatePath) {
                    // åˆ›å»ºé€šé“
                    for (let i = 1; i <= pathLength; i++) {
                        const nx = entranceX + dx * i;
                        const ny = entranceY + dy * i;
                        mapFloors[floor][ny][nx] = TileType.FLOOR;
                    }
                    break; // åªåˆ›å»ºä¸€ä¸ªæ–¹å‘çš„é€šé“
                }
            }
        }
        
        // è¿æ¥å¤§å…åˆ°å…¶ä»–åŒºåŸŸ
        function connectLobbyToAreas(lobbyX, lobbyY, lobbyWidth, lobbyHeight, floor) {
            // æ‰¾åˆ°æœ€è¿‘çš„æˆ¿é—´æˆ–èµ°å»Š
            let nearestArea = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (!mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                        continue;
                    }
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN) {
                        
                        const dist = Math.abs(x - (lobbyX + lobbyWidth/2)) + 
                                   Math.abs(y - (lobbyY + lobbyHeight/2));
                        
                        if (dist < minDist && dist > 5) { // è·ç¦»å¤§äº5æ‰éœ€è¦è¿æ¥
                            minDist = dist;
                            nearestArea = {x, y};
                        }
                    }
                }
            }
            
            // å¦‚æœæ‰¾åˆ°äº†éœ€è¦è¿æ¥çš„åŒºåŸŸï¼Œåˆ›å»ºèµ°å»Š
            if (nearestArea && minDist < 20) {
                const lobbyCenterX = Math.floor(lobbyX + lobbyWidth / 2);
                const lobbyCenterY = Math.floor(lobbyY + lobbyHeight / 2);
                
                createSimpleCorridor(lobbyCenterX, lobbyCenterY, nearestArea.x, nearestArea.y, floor);
            }
        }
        
        // æ£€æŸ¥ä½ç½®æ˜¯å¦é å¢™æˆ–é é—¨
        function isNearWallOrDoor(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const adjacentTile = mapFloors[floor][ny][nx];
                    
                    // æ£€æŸ¥æ˜¯å¦é å¢™
                    if (adjacentTile === TileType.WALL) {
                        return true;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é é—¨ï¼ˆé—¨é€šå¸¸æ˜¯åœ°æ¿ï¼Œä½†è¿æ¥æˆ¿é—´ï¼‰
                    if (adjacentTile === TileType.FLOOR || 
                        adjacentTile === TileType.MEDIUM_GROUND ||
                        adjacentTile === TileType.HIGH_GROUND ||
                        adjacentTile === TileType.LOW_GROUND) {
                        // æ£€æŸ¥è¿™ä¸ªåœ°æ¿æ˜¯å¦è¿æ¥æˆ¿é—´ï¼ˆå³å‘¨å›´æœ‰å¢™å£ï¼‰
                        if (isDoorway(nx, ny, floor)) {
                            return true;
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é çª—æˆ·
                    if (adjacentTile === TileType.WINDOW) {
                        return true;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é å¤§å…å…¥å£
                    if (adjacentTile === TileType.LOBBY_ENTRANCE) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // æ£€æŸ¥ä½ç½®æ˜¯å¦æ˜¯é—¨å£
        function isDoorway(x, y, floor) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            let wallCount = 0;
            let voidCount = 0;
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < mapFloors[floor][0].length && 
                    ny >= 0 && ny < mapFloors[floor].length &&
                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined) {
                    
                    const tile = mapFloors[floor][ny][nx];
                    if (tile === TileType.WALL) {
                        wallCount++;
                    } else if (tile === TileType.VOID) {
                        voidCount++;
                    }
                }
            }
            
            // å¦‚æœå‘¨å›´æœ‰å¢™å£å’Œç©ºåœ°ï¼Œè¯´æ˜è¿™æ˜¯é—¨å£
            return wallCount >= 1 && voidCount >= 1;
        }
        
        // æ·»åŠ å¤–åœºç‰¹å¾
        function addOutdoorFeatures(size) {
            // æ·»åŠ è§„åˆ™çš„å¤–åœºæ©ä½“ï¼ˆé›†è£…ç®±ã€è½¦è¾†ç­‰ï¼‰- åªç”Ÿæˆåœ¨é å¢™ä½ç½®
            const coverCount = Math.floor(size * size * 0.01); // 1%çš„å¯†åº¦
            let placedCount = 0;
            let attempts = 0;
            
            while (placedCount < coverCount && attempts < coverCount * 10) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR && isOutdoorCoverPosition(x, y, size)) {
                    // åˆ›å»ºè§„åˆ™çŸ©å½¢æ©ä½“
                    const coverWidth = 2 + Math.floor(Math.random() * 2); // 2-3æ ¼å®½
                    const coverHeight = 2; // å›ºå®š2æ ¼é«˜
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´
                    let canPlace = true;
                            for (let dy = 0; dy < coverHeight; dy++) {
                                for (let dx = 0; dx < coverWidth; dx++) {
                            if (y + dy >= size - 1 || x + dx >= size - 1) {
                                canPlace = false;
                                break;
                            }
                            if (mapFloors[0][y + dy][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        if (!canPlace) break;
                    }
                    
                    if (canPlace) {
                        for (let dy = 0; dy < coverHeight; dy++) {
                            for (let dx = 0; dx < coverWidth; dx++) {
                                            mapFloors[0][y + dy][x + dx] = TileType.OUTDOOR_COVER;
                                        }
                                    }
                        placedCount++;
                    }
                }
                attempts++;
            }
            
            // åœ¨å¤–åœºè¾¹ç¼˜æ·»åŠ è§„åˆ™å›´å¢™
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // æ£€æŸ¥æ˜¯å¦ä¸å¤–åœºè¾¹ç¼˜ç›¸é‚»
                        let isEdge = false;
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                mapFloors[0][ny][nx] === TileType.VOID) {
                                        isEdge = true;
                                break;
                            }
                        }
                        
                        if (isEdge && Math.random() < 0.9) { // æé«˜å›´å¢™ç”Ÿæˆæ¦‚ç‡
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // ç¡®ä¿å¤–åœºæœ‰å®Œæ•´çš„å›´å¢™è¾¹ç•Œ
            createOutdoorWallBoundary(size);
            
            // æ·»åŠ è§„åˆ™çš„é“è·¯è¿æ¥
            addOutdoorPaths(size);
        }
        
        // æ£€æŸ¥å¤–åœºæ©ä½“ä½ç½®æ˜¯å¦åˆé€‚ï¼ˆé å¢™æˆ–è¾¹ç¼˜ï¼‰
        function isOutdoorCoverPosition(x, y, size) {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // æ£€æŸ¥æ˜¯å¦é å¤–åœºè¾¹ç¼˜
                if (nx < 0 || nx >= size || ny < 0 || ny >= size) {
                    return true;
                }
                
                // æ£€æŸ¥è¾¹ç•Œå’Œæ•°ç»„æœ‰æ•ˆæ€§
                if (nx < 0 || nx >= size || ny < 0 || ny >= size ||
                    !mapFloors[0][ny] || mapFloors[0][ny][nx] === undefined) {
                    continue;
                }
                
                // æ£€æŸ¥æ˜¯å¦é å¤–åœºå›´å¢™
                if (mapFloors[0][ny][nx] === TileType.OUTDOOR_WALL) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦é å†…åœºè¾¹ç•Œï¼ˆå¢™å£ï¼‰
                if (mapFloors[0][ny][nx] === TileType.WALL) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦é ç©ºåœ°ï¼ˆå¤–åœºè¾¹ç¼˜ï¼‰
                if (mapFloors[0][ny][nx] === TileType.VOID) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦é é“è·¯ï¼ˆåœ°æ¿ï¼‰
                if (mapFloors[0][ny][nx] === TileType.FLOOR) {
                    return true;
                }
            }
            
            return false;
        }
        
        // åˆ›å»ºå¤–åœºå›´å¢™è¾¹ç•Œ
        function createOutdoorWallBoundary(size) {
            // æ‰«æå¤–åœºåŒºåŸŸï¼Œç¡®ä¿è¾¹ç•Œå®Œæ•´
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (mapFloors[0][y][x] === TileType.OUTDOOR) {
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        let needsWall = false;
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            // å¦‚æœé‚»æ¥åœ°å›¾è¾¹ç•Œæˆ–ç©ºåœ°ï¼Œéœ€è¦å›´å¢™
                            if (ny < 0 || ny >= size || nx < 0 || nx >= size || 
                                (mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined &&
                                 mapFloors[0][ny][nx] === TileType.VOID)) {
                                needsWall = true;
                                break;
                            }
                        }
                        
                        // å¦‚æœå½“å‰æ˜¯å¤–åœºä¸”éœ€è¦å›´å¢™ï¼Œä½†è¿˜æ²¡æœ‰å›´å¢™ï¼Œåˆ™æ·»åŠ å›´å¢™
                        if (needsWall && mapFloors[0][y][x] === TileType.OUTDOOR) {
                            mapFloors[0][y][x] = TileType.OUTDOOR_WALL;
                        }
                    }
                }
            }
            
            // æ·»åŠ å¤–åœºå†…éƒ¨çš„å›´å¢™ç»“æ„ï¼ˆå¦‚åˆ†éš”å¢™ï¼‰
            addOutdoorInternalWalls(size);
        }
        
        // æ·»åŠ å¤–åœºå†…éƒ¨å›´å¢™
        function addOutdoorInternalWalls(size) {
            // åœ¨å¤–åœºåŒºåŸŸæ·»åŠ ä¸€äº›å†…éƒ¨å›´å¢™ï¼Œåˆ›é€ æˆ˜æœ¯æ©ä½“
            const wallCount = Math.floor(size * 0.5); // æ ¹æ®åœ°å›¾å¤§å°å†³å®šå›´å¢™æ•°é‡ï¼Œæ”¯æŒæ›´å¤§åœ°å›¾
            
            for (let i = 0; i < wallCount; i++) {
                const x = Math.floor(Math.random() * (size - 4)) + 2;
                const y = Math.floor(Math.random() * (size - 4)) + 2;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // éšæœºé€‰æ‹©å›´å¢™æ–¹å‘ï¼ˆæ°´å¹³æˆ–å‚ç›´ï¼‰
                    const isHorizontal = Math.random() > 0.5;
                    const wallLength = 3 + Math.floor(Math.random() * 4); // 3-6æ ¼é•¿
                    
                    if (isHorizontal) {
                        // åˆ›å»ºæ°´å¹³å›´å¢™
                        let canPlace = true;
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx >= size || 
                                !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                                mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dx = 0; dx < wallLength; dx++) {
                                if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                    mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    } else {
                        // åˆ›å»ºå‚ç›´å›´å¢™
                        let canPlace = true;
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                        
                        if (canPlace) {
                            for (let dy = 0; dy < wallLength; dy++) {
                                if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                    mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                                }
                            }
                        }
                    }
                }
            }
            
            // æ·»åŠ Lå½¢å›´å¢™ï¼ˆè§’è½æ©ä½“ï¼‰
            addOutdoorCornerWalls(size);
        }
        
        // æ·»åŠ å¤–åœºè§’è½å›´å¢™
        function addOutdoorCornerWalls(size) {
            const cornerCount = Math.floor(size * 0.2); // è§’è½å›´å¢™æ•°é‡ï¼Œæ”¯æŒæ›´å¤§åœ°å›¾
            
            for (let i = 0; i < cornerCount; i++) {
                const x = Math.floor(Math.random() * (size - 6)) + 3;
                const y = Math.floor(Math.random() * (size - 6)) + 3;
                
                if (y >= 0 && y < size && x >= 0 && x < size &&
                    mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                    mapFloors[0][y][x] === TileType.OUTDOOR) {
                    // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´åˆ›å»ºLå½¢å›´å¢™
                    const wallLength = 3;
                    let canPlace = true;
                    
                    // æ£€æŸ¥æ°´å¹³æ®µ
                    for (let dx = 0; dx < wallLength; dx++) {
                        if (x + dx >= size || 
                            !mapFloors[0][y] || mapFloors[0][y][x + dx] === undefined ||
                            mapFloors[0][y][x + dx] !== TileType.OUTDOOR) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    // æ£€æŸ¥å‚ç›´æ®µ
                    if (canPlace) {
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy >= size || 
                                !mapFloors[0][y + dy] || mapFloors[0][y + dy][x] === undefined ||
                                mapFloors[0][y + dy][x] !== TileType.OUTDOOR) {
                                canPlace = false;
                                break;
                            }
                        }
                    }
                    
                    if (canPlace) {
                        // åˆ›å»ºLå½¢å›´å¢™
                        for (let dx = 0; dx < wallLength; dx++) {
                            if (x + dx < size && mapFloors[0][y] && mapFloors[0][y][x + dx] !== undefined) {
                                mapFloors[0][y][x + dx] = TileType.OUTDOOR_WALL;
                            }
                        }
                        for (let dy = 0; dy < wallLength; dy++) {
                            if (y + dy < size && mapFloors[0][y + dy] && mapFloors[0][y + dy][x] !== undefined) {
                                mapFloors[0][y + dy][x] = TileType.OUTDOOR_WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // ç”Ÿæˆé«˜ä½å·®åŒºåŸŸ - æ•´æ®µé“è·¯å‡é«˜æˆ–é™ä½
        function generateElevationAreas(size, floor) {
            const elevation = parseInt(document.getElementById('elevation').value);
            if (elevation === 0) return; // æ— é«˜ä½å·®
            
            // æ‰¾åˆ°æ‰€æœ‰è¿ç»­çš„é“è·¯æ®µ
            const roadSegments = findRoadSegments(size, floor);
            
            // æ ¹æ®é«˜ä½å·®è®¾ç½®å†³å®šè¦æ”¹å˜çš„é“è·¯æ®µæ•°é‡
            const elevationIntensity = elevation * 0.4; // 0.4 = 40%çš„é“è·¯æ®µä¼šæœ‰é«˜ä½å·®
            const segmentsToElevate = Math.floor(roadSegments.length * elevationIntensity);
            
            // éšæœºé€‰æ‹©é“è·¯æ®µè¿›è¡Œé«˜ä½å·®å¤„ç†
            const shuffledSegments = [...roadSegments].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < Math.min(segmentsToElevate, shuffledSegments.length); i++) {
                const segment = shuffledSegments[i];
                const isHighGround = Math.random() > 0.5; // 50%æ¦‚ç‡æ˜¯é«˜åœ°ï¼Œ50%æ¦‚ç‡æ˜¯ä½åœ°
                
                // å°†æ•´ä¸ªé“è·¯æ®µæ ‡è®°ä¸ºé«˜åœ°æˆ–ä½åœ°
                for (const point of segment) {
                    if (mapFloors[floor][point.y][point.x] === TileType.FLOOR) {
                        mapFloors[floor][point.y][point.x] = isHighGround ? TileType.HIGH_GROUND : TileType.LOW_GROUND;
                    }
                }
            }
            
            // å°†å‰©ä½™çš„åœ°æ¿å’Œé“è·¯åŒºåŸŸæ ‡è®°ä¸ºä¸­ç­‰åœ°
            markMediumGround(size, floor);
        }
        
        // æ‰¾åˆ°è¿ç»­çš„é“è·¯æ®µ
        function findRoadSegments(size, floor) {
            const visited = Array(size).fill().map(() => Array(size).fill(false));
            const segments = [];
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (!visited[y][x] && 
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        const segment = [];
                        floodFillRoad(x, y, size, floor, visited, segment);
                        
                        // åªä¿ç•™è¶³å¤Ÿå¤§çš„é“è·¯æ®µï¼ˆè‡³å°‘5ä¸ªè¿ç»­ç‚¹ï¼‰
                        if (segment.length >= 5) {
                            segments.push(segment);
                        }
                    }
                }
            }
            
            return segments;
        }
        
        // æ´ªæ°´å¡«å……ç®—æ³•æ‰¾åˆ°è¿ç»­çš„é“è·¯æ®µ
        function floodFillRoad(x, y, size, floor, visited, segment) {
            if (x < 0 || x >= size || y < 0 || y >= size || 
                visited[y][x] || 
                !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined ||
                mapFloors[floor][y][x] !== TileType.FLOOR) {
                return;
            }
            
            visited[y][x] = true;
            segment.push({x, y});
            
            // å‘å››ä¸ªæ–¹å‘æ‰©å±•
            floodFillRoad(x + 1, y, size, floor, visited, segment);
            floodFillRoad(x - 1, y, size, floor, visited, segment);
            floodFillRoad(x, y + 1, size, floor, visited, segment);
            floodFillRoad(x, y - 1, size, floor, visited, segment);
        }
        
        // åˆ›å»ºé«˜ä½å·®åŒºåŸŸ
        function createElevationArea(centerX, centerY, size, elevationType, floor) {
            const halfSize = Math.floor(size / 2);
            
            for (let y = centerY - halfSize; y <= centerY + halfSize; y++) {
                for (let x = centerX - halfSize; x <= centerX + halfSize; x++) {
                    if (x >= 0 && x < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length &&
                        mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        
                        // åªå¯¹åœ°é¢å’Œé“è·¯åº”ç”¨é«˜ä½å·®
                        if (mapFloors[floor][y][x] === TileType.FLOOR) {
                            mapFloors[floor][y][x] = elevationType;
                        }
                    }
                }
            }
        }
        
        // æ ‡è®°ä¸­ç­‰åœ°
        function markMediumGround(size, floor) {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    // åªå¯¹åœ°é¢å’Œé“è·¯æ ‡è®°ä¸ºä¸­ç­‰åœ°ï¼Œä¿æŒå…¶ä»–å…ƒç´ ä¸å˜
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined &&
                        mapFloors[floor][y][x] === TileType.FLOOR) {
                        mapFloors[floor][y][x] = TileType.MEDIUM_GROUND;
                    }
                }
            }
        }
        
        // æ·»åŠ å¤–åœºé“è·¯
        function addOutdoorPaths(size) {
            // åœ¨å¤–åœºåŒºåŸŸä¹‹é—´åˆ›å»ºè§„åˆ™çš„é“è·¯è¿æ¥
            const pathCount = Math.floor(size / 20) + Math.floor(Math.random() * 5); // æ ¹æ®åœ°å›¾å¤§å°è°ƒæ•´é“è·¯æ•°é‡
            
            for (let i = 0; i < pathCount; i++) {
                // æ‰¾åˆ°ä¸¤ä¸ªå¤–åœºåŒºåŸŸçš„ä¸­å¿ƒç‚¹
                let outdoorAreas = [];
                
                // æ‰«æå¤–åœºåŒºåŸŸ
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (mapFloors[0][y] && mapFloors[0][y][x] !== undefined &&
                            mapFloors[0][y][x] === TileType.OUTDOOR) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°åŒºåŸŸçš„ä¸­å¿ƒ
                            let isCenter = true;
                            for (let dy = -3; dy <= 3; dy++) {
                                for (let dx = -3; dx <= 3; dx++) {
                                    const ny = y + dy;
                                    const nx = x + dx;
                                    if (ny >= 0 && ny < size && nx >= 0 && nx < size &&
                                        mapFloors[0][ny] && mapFloors[0][ny][nx] !== undefined) {
                                        if (mapFloors[0][ny][nx] !== TileType.OUTDOOR && 
                                            mapFloors[0][ny][nx] !== TileType.OUTDOOR_COVER) {
                                            isCenter = false;
                                        }
                                    }
                                }
                            }
                            if (isCenter) {
                                outdoorAreas.push({x, y});
                            }
                        }
                    }
                }
                
                // è¿æ¥ä¸åŒçš„å¤–åœºåŒºåŸŸ
                if (outdoorAreas.length >= 2) {
                    const area1 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    let area2;
                    do {
                        area2 = outdoorAreas[Math.floor(Math.random() * outdoorAreas.length)];
                    } while (area2 === area1);
                    
                    // åˆ›å»ºç›´çº¿é“è·¯è¿æ¥
                    createStraightPath(area1.x, area1.y, area2.x, area2.y);
                }
            }
        }
        
        // åˆ›å»ºé“è·¯ï¼ˆç›´çº¿ï¼‰
        function createStraightPath(x1, y1, x2, y2) {
            
            // ç›´çº¿é“è·¯
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // åˆ›å»ºé“è·¯ï¼ˆ2æ ¼å®½ï¼‰
                for (let w = -1; w <= 1; w++) {
                    for (let h = -1; h <= 1; h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[0][0].length && 
                            ny >= 0 && ny < mapFloors[0].length) {
                            if (mapFloors[0][ny][nx] === TileType.OUTDOOR) {
                                mapFloors[0][ny][nx] = TileType.FLOOR; // é“è·¯ä½¿ç”¨åœ°æ¿ç±»å‹
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        

        
        // åœ¨æˆ¿é—´å‘¨å›´æ·»åŠ ç¼“å†²åŒºï¼ˆç¡®ä¿ç‹¬ç«‹æ€§ï¼‰
        function addRoomBuffer(x, y, width, height, floor, size, minSpacing) {
            // åœ¨æˆ¿é—´å‘¨å›´åˆ›å»ºç¼“å†²åŒºï¼Œç¡®ä¿æˆ¿é—´ä¹‹é—´æœ‰è¶³å¤Ÿç©ºé—´
            for (let by = y - minSpacing; by < y + height + minSpacing; by++) {
                for (let bx = x - minSpacing; bx < x + width + minSpacing; bx++) {
                    if (bx >= 0 && bx < size && by >= 0 && by < size) {
                        // å¦‚æœç¼“å†²åŒºä½ç½®æ˜¯ç©ºåœ°ï¼Œä¿æŒä¸ºç©ºåœ°
                        if (mapFloors[floor][by][bx] === TileType.VOID) {
                            // ä¿æŒä¸ºç©ºåœ°ï¼Œä¸æ·»åŠ ä»»ä½•è£…é¥°
                        }
                    }
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦é‚»æ¥å¤–åœº
        function isAdjacentToOutdoor(x, y, floor) {
            if (floor !== 0) return false;
            
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] === TileType.OUTDOOR) {
                    return true;
                }
            }
            return false;
        }
        
        // è¿æ¥æˆ¿é—´ï¼ˆæ”¹è¿›ç‰ˆï¼šéšæœºèµ°å»Šå®½åº¦ï¼Œç¡®ä¿æ‰€æœ‰æˆ¿é—´è¿é€šï¼‰
        function connectRooms(rooms, floor, baseCorridorWidth) {
            if (rooms.length < 2) return;
            
            const corridorMode = document.getElementById('corridorRandom').value;
            
            // ä½¿ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ç¡®ä¿æ‰€æœ‰æˆ¿é—´è¿é€š
            const connected = new Set([0]); // ä»ç¬¬ä¸€ä¸ªæˆ¿é—´å¼€å§‹
            const unconnected = new Set();
            for (let i = 1; i < rooms.length; i++) {
                unconnected.add(i);
            }
            
            // è¿æ¥æ‰€æœ‰æˆ¿é—´
            while (unconnected.size > 0) {
                let minDist = Infinity;
                let bestConnected = -1;
                let bestUnconnected = -1;
                
                // æ‰¾åˆ°æœ€è¿‘çš„æœªè¿æ¥æˆ¿é—´å¯¹
                for (let c of connected) {
                    for (let u of unconnected) {
                        const room1 = rooms[c];
                        const room2 = rooms[u];
                        const dist = Math.abs(room1.x + room1.width/2 - room2.x - room2.width/2) + 
                                   Math.abs(room1.y + room1.height/2 - room2.y - room2.height/2);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            bestConnected = c;
                            bestUnconnected = u;
                        }
                    }
                }
                
                if (bestConnected !== -1 && bestUnconnected !== -1) {
                    // æ ¹æ®æ¨¡å¼å†³å®šèµ°å»Šå®½åº¦
                    let corridorWidth = baseCorridorWidth;
                    if (corridorMode === 'random') {
                        corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                    } else if (corridorMode === 'varied') {
                        corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                    } else {
                        corridorWidth = baseCorridorWidth + 1;
                    }
                    
                    // åˆ›å»ºèµ°å»Šè¿æ¥ä¸¤ä¸ªæˆ¿é—´
                    createCorridorBetweenRooms(rooms[bestConnected], rooms[bestUnconnected], floor, corridorWidth);
                    
                    // å°†æˆ¿é—´æ ‡è®°ä¸ºå·²è¿æ¥
                    connected.add(bestUnconnected);
                    unconnected.delete(bestUnconnected);
                }
            }
            
            // æ·»åŠ é¢å¤–çš„è¿æ¥å¢åŠ è·¯çº¿å¤šæ ·æ€§ï¼ˆ20%æ¦‚ç‡ï¼Œå‡å°‘è¿‡åº¦è¿æ¥ï¼‰
            for (let i = 0; i < rooms.length; i++) {
                for (let j = i + 1; j < rooms.length; j++) {
                    if (Math.random() < 0.2) {
                        let corridorWidth = baseCorridorWidth;
                        if (corridorMode === 'random') {
                            corridorWidth = baseCorridorWidth + Math.floor(Math.random() * 3);
                        } else if (corridorMode === 'varied') {
                            corridorWidth = 1 + Math.floor(Math.random() * (baseCorridorWidth + 2));
                        }
                        createCorridorBetweenRooms(rooms[i], rooms[j], floor, corridorWidth);
                    }
                }
                    }
        
        // æ¸…ç†å­¤ç«‹çš„æˆ¿é—´ï¼ˆç¡®ä¿æ‰€æœ‰æˆ¿é—´éƒ½å¯è¾¾ï¼‰
        function cleanupIsolatedRooms(rooms, floor) {
            // æ£€æŸ¥æ¯ä¸ªæˆ¿é—´æ˜¯å¦éƒ½æœ‰é—¨æˆ–ä¸èµ°å»Šè¿æ¥
            for (let room of rooms) {
                let hasAccess = false;
                
                // æ£€æŸ¥æˆ¿é—´è¾¹ç•Œæ˜¯å¦æœ‰å¼€å£
                const directions = [
                    { x: room.x - 1, y: room.y + Math.floor(room.height / 2) }, // å·¦
                    { x: room.x + room.width, y: room.y + Math.floor(room.height / 2) }, // å³
                    { x: room.x + Math.floor(room.width / 2), y: room.y - 1 }, // ä¸Š
                    { x: room.x + Math.floor(room.width / 2), y: room.y + room.height } // ä¸‹
                ];
                
                for (let dir of directions) {
                    if (dir.x >= 0 && dir.x < mapFloors[floor][0].length && 
                        dir.y >= 0 && dir.y < mapFloors[floor].length) {
                        if (mapFloors[floor][dir.y][dir.x] === TileType.FLOOR) {
                            hasAccess = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰è®¿é—®è·¯å¾„ï¼Œåˆ›å»ºä¸€ä¸ªé—¨
                if (!hasAccess) {
                    createRoomDoor(room, floor);
                }
            }
        }
        
        // ä¸ºæˆ¿é—´åˆ›å»ºé—¨
        function createRoomDoor(room, floor) {
            // éšæœºé€‰æ‹©ä¸€é¢å¢™åˆ›å»ºé—¨
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0 }, // å·¦
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0 }, // å³
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1 }, // ä¸Š
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1 } // ä¸‹
            ];
            
            const side = sides[Math.floor(Math.random() * sides.length)];
            
            // åˆ›å»ºé—¨
            if (side.x >= 0 && side.x < mapFloors[floor][0].length && 
                side.y >= 0 && side.y < mapFloors[floor].length) {
                mapFloors[floor][side.y][side.x] = TileType.FLOOR;
                
                // åˆ›å»ºé—¨å¤–çš„èµ°å»Š
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        mapFloors[floor][corridorY][corridorX] = TileType.FLOOR;
                    }
                    }
                }
            }
            
            // ç¡®ä¿æ¯ä¸ªæˆ¿é—´éƒ½æœ‰é—¨
            ensureRoomDoors(rooms, floor);
            
            // æ·»åŠ èµ°å»Šå¢™å£
            addCorridorWalls(floor);
            
            // æ¸…ç†å­¤ç«‹çš„æˆ¿é—´ï¼ˆç¡®ä¿æ‰€æœ‰æˆ¿é—´éƒ½å¯è¾¾ï¼‰
            cleanupIsolatedRooms(rooms, floor);
        }
        
        // åˆ›å»ºä¸¤ä¸ªæˆ¿é—´ä¹‹é—´çš„èµ°å»Šï¼ˆæ”¯æŒæ›²æŠ˜åº¦å’Œå¼¯æ›²åº¦ï¼‰
        function createCorridorBetweenRooms(room1, room2, floor, width) {
            const x1 = Math.floor(room1.x + room1.width / 2);
            const y1 = Math.floor(room1.y + room1.height / 2);
            const x2 = Math.floor(room2.x + room2.width / 2);
            const y2 = Math.floor(room2.y + room2.height / 2);
            
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            switch(pathComplexity) {
                case 0: // ç›´çº¿
                    createStraightCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 1: // å¾®å¼¯
                    createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 2: // ä¸­ç­‰ï¼ˆLå½¢ï¼‰
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 3: // æ›²æŠ˜
                    createZigzagCorridor(x1, y1, x2, y2, floor, width);
                    break;
                case 4: // è¿·å®«
                    createMazeLikeCorridor(x1, y1, x2, y2, floor, width);
                    break;
                default:
                    createLShapedCorridor(x1, y1, x2, y2, floor, width);
            }
        }
        
        // ç›´çº¿èµ°å»Šï¼ˆæœ€çŸ­è·¯å¾„ï¼‰
        function createStraightCorridor(x1, y1, x2, y2, floor, width) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let x = x1;
            let y = y1;
            
            while (true) {
                // ç»˜åˆ¶å®½åº¦çš„èµ°å»Š
                for (let w = -Math.floor(width/2); w <= Math.floor(width/2); w++) {
                    for (let h = -Math.floor(width/2); h <= Math.floor(width/2); h++) {
                        const nx = x + w;
                        const ny = y + h;
                        if (nx >= 0 && nx < mapFloors[floor][0].length && 
                            ny >= 0 && ny < mapFloors[floor].length) {
                            if (mapFloors[floor][ny][nx] === TileType.VOID || 
                                mapFloors[floor][ny][nx] === TileType.WALL) {
                                mapFloors[floor][ny][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
                
                if (x === x2 && y === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
        }
        
        // å¾®å¼¯èµ°å»Šï¼ˆå¸¦å°å¼§åº¦ï¼‰
        function createSlightlyCurvedCorridor(x1, y1, x2, y2, floor, width) {
            
            const midX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 6) - 3;
            const midY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 6) - 3;
            
            createStraightCorridor(x1, y1, midX, midY, floor, width);
            createStraightCorridor(midX, midY, x2, y2, floor, width);
        }
        
        // Lå½¢èµ°å»Šï¼ˆç»å…¸90åº¦è½¬å¼¯ï¼‰
        function createLShapedCorridor(x1, y1, x2, y2, floor, width) {
            if (Math.random() > 0.5) {
                // å…ˆæ°´å¹³åå‚ç›´
                createHorizontalCorridor(x1, x2, y1, floor, width);
                createVerticalCorridor(x2, y1, y2, floor, width);
            } else {
                // å…ˆå‚ç›´åæ°´å¹³
                createVerticalCorridor(x1, y1, y2, floor, width);
                createHorizontalCorridor(x1, x2, y2, floor, width);
            }
        }
        
        // æ›²æŠ˜èµ°å»Šï¼ˆå¤šä¸ªè½¬å¼¯ï¼‰
        function createZigzagCorridor(x1, y1, x2, y2, floor, width) {
            // æ£€æŸ¥æ›²æŠ˜åº¦è®¾ç½®
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // å¦‚æœæ›²æŠ˜åº¦ä¸º0ï¼ˆç›´çº¿ï¼‰ï¼Œåˆ™ä½¿ç”¨ç›´çº¿èµ°å»Š
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            const points = [];
            points.push({x: x1, y: y1});
            
            // æ·»åŠ 2-3ä¸ªä¸­é—´ç‚¹
            const numPoints = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numPoints; i++) {
                const t = (i + 1) / (numPoints + 1);
                const baseX = x1 + (x2 - x1) * t;
                const baseY = y1 + (y2 - y1) * t;
                
                // æ·»åŠ éšæœºåç§»ï¼ˆç¡®ä¿åœ¨è¾¹ç•Œå†…ï¼‰
                const offsetX = Math.floor(Math.random() * 10) - 5;
                const offsetY = Math.floor(Math.random() * 10) - 5;
                
                points.push({
                    x: Math.max(1, Math.min(Math.floor(baseX + offsetX), mapWidth - 2)),
                    y: Math.max(1, Math.min(Math.floor(baseY + offsetY), mapHeight - 2))
                });
            }
            
            points.push({x: x2, y: y2});
            
            // è¿æ¥æ‰€æœ‰ç‚¹
            for (let i = 0; i < points.length - 1; i++) {
                if (i % 2 === 0) {
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i].y, floor, width);
                    createVerticalCorridor(points[i+1].x, points[i].y, points[i+1].y, floor, width);
                } else {
                    createVerticalCorridor(points[i].x, points[i].y, points[i+1].y, floor, width);
                    createHorizontalCorridor(points[i].x, points[i+1].x, points[i+1].y, floor, width);
                }
            }
        }
        
        // è¿·å®«å¼èµ°å»Šï¼ˆå¤æ‚è·¯å¾„ï¼‰
        function createMazeLikeCorridor(x1, y1, x2, y2, floor, width) {
            // æ£€æŸ¥æ›²æŠ˜åº¦è®¾ç½®
            const pathComplexity = parseInt(document.getElementById('pathComplexity').value);
            
            // å¦‚æœæ›²æŠ˜åº¦ä¸º0ï¼ˆç›´çº¿ï¼‰ï¼Œåˆ™ä½¿ç”¨ç›´çº¿èµ°å»Š
            if (pathComplexity === 0) {
                createStraightCorridor(x1, y1, x2, y2, floor, width);
                return;
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            const mapWidth = mapFloors[floor][0].length;
            const mapHeight = mapFloors[floor].length;
            
            x1 = Math.max(1, Math.min(x1, mapWidth - 2));
            y1 = Math.max(1, Math.min(y1, mapHeight - 2));
            x2 = Math.max(1, Math.min(x2, mapWidth - 2));
            y2 = Math.max(1, Math.min(y2, mapHeight - 2));
            
            // åˆ›å»ºä¸»è·¯å¾„
            createZigzagCorridor(x1, y1, x2, y2, floor, width);
            
            // æ·»åŠ 1-2æ¡é¢å¤–è·¯å¾„
            const extraPaths = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < extraPaths; i++) {
                // åˆ›å»ºåç§»èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆç¡®ä¿åœ¨è¾¹ç•Œå†…ï¼‰
                const offsetX1 = Math.max(1, Math.min(x1 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY1 = Math.max(1, Math.min(y1 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                const offsetX2 = Math.max(1, Math.min(x2 + Math.floor(Math.random() * 10) - 5, mapWidth - 2));
                const offsetY2 = Math.max(1, Math.min(y2 + Math.floor(Math.random() * 10) - 5, mapHeight - 2));
                
                // ä½¿ç”¨è¾ƒçª„çš„å®½åº¦
                const narrowWidth = Math.max(1, width - 1);
                
                // éšæœºé€‰æ‹©è·¯å¾„ç±»å‹
                if (Math.random() > 0.5) {
                    createLShapedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                } else {
                    createSlightlyCurvedCorridor(offsetX1, offsetY1, offsetX2, offsetY2, floor, narrowWidth);
                }
            }
            
            // æ·»åŠ ä¸€äº›è¿æ¥æ¨ªé“
            const crossPaths = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < crossPaths; i++) {
                const crossX = Math.floor((x1 + x2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossY = Math.floor((y1 + y2) / 2) + Math.floor(Math.random() * 20) - 10;
                const crossLength = 5 + Math.floor(Math.random() * 10);
                
                if (Math.random() > 0.5) {
                    // æ°´å¹³æ¨ªé“
                    const startX = Math.max(0, crossX - Math.floor(crossLength/2));
                    const endX = Math.min(mapWidth - 1, crossX + Math.floor(crossLength/2));
                    
                    if (crossY >= 0 && crossY < mapHeight) {
                        for (let x = startX; x <= endX; x++) {
                            if (mapFloors[floor][crossY][x] === TileType.VOID) {
                                mapFloors[floor][crossY][x] = TileType.FLOOR;
                            }
                        }
                    }
                } else {
                    // å‚ç›´æ¨ªé“
                    const startY = Math.max(0, crossY - Math.floor(crossLength/2));
                    const endY = Math.min(mapHeight - 1, crossY + Math.floor(crossLength/2));
                    
                    if (crossX >= 0 && crossX < mapWidth) {
                        for (let y = startY; y <= endY; y++) {
                            if (mapFloors[floor][y][crossX] === TileType.VOID) {
                                mapFloors[floor][y][crossX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        

        
        // åˆ›å»ºæ°´å¹³èµ°å»Š
        function createHorizontalCorridor(x1, x2, y, floor, width) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const halfWidth = Math.floor(width / 2);
            
            for (let x = minX; x <= maxX; x++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const ny = y + w;
                    if (ny >= 0 && ny < mapFloors[floor].length && 
                        x >= 0 && x < mapFloors[floor][0].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                            if (mapFloors[floor][ny][x] === TileType.VOID || 
                                mapFloors[floor][ny][x] === TileType.WALL) {
                                mapFloors[floor][ny][x] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // åˆ›å»ºå‚ç›´èµ°å»Š
        function createVerticalCorridor(x, y1, y2, floor, width) {
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            const halfWidth = Math.floor(width / 2);
            
            for (let y = minY; y <= maxY; y++) {
                for (let w = -halfWidth; w <= halfWidth; w++) {
                    const nx = x + w;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        y >= 0 && y < mapFloors[floor].length) {
                        if (mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                            if (mapFloors[floor][y][nx] === TileType.VOID || 
                                mapFloors[floor][y][nx] === TileType.WALL) {
                                mapFloors[floor][y][nx] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
        }
        
        // ç¡®ä¿æ¯ä¸ªæˆ¿é—´éƒ½æœ‰è‡³å°‘ä¸€ä¸ªé—¨
        function ensureRoomDoors(rooms, floor) {
            for (let room of rooms) {
                let hasDoor = false;
                
                // æ£€æŸ¥æˆ¿é—´è¾¹ç•Œæ˜¯å¦æœ‰å¼€å£
                // ä¸Šè¾¹
                for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                    if (mapFloors[floor][room.y][x] === TileType.FLOOR) {
                        hasDoor = true;
                        break;
                    }
                }
                
                // ä¸‹è¾¹
                if (!hasDoor) {
                    for (let x = room.x + 1; x < room.x + room.width - 1; x++) {
                        if (mapFloors[floor][room.y + room.height - 1][x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // å·¦è¾¹
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // å³è¾¹
                if (!hasDoor) {
                    for (let y = room.y + 1; y < room.y + room.height - 1; y++) {
                        if (mapFloors[floor][y][room.x + room.width - 1] === TileType.FLOOR) {
                            hasDoor = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰é—¨ï¼Œåˆ›å»ºä¸€ä¸ª
                if (!hasDoor) {
                    // éšæœºé€‰æ‹©ä¸€é¢å¢™åˆ›å»ºé—¨
                    const side = Math.floor(Math.random() * 4);
                    const doorWidth = 2; // é—¨çš„å®½åº¦
                    
                    switch(side) {
                        case 0: // ä¸Š
                            const topX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (topX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y][topX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 1: // ä¸‹
                            const bottomX = room.x + Math.floor(room.width / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (bottomX + i < room.x + room.width - 1) {
                                    mapFloors[floor][room.y + room.height - 1][bottomX + i] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 2: // å·¦
                            const leftY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (leftY + i < room.y + room.height - 1) {
                                    mapFloors[floor][leftY + i][room.x] = TileType.FLOOR;
                                }
                            }
                            break;
                        case 3: // å³
                            const rightY = room.y + Math.floor(room.height / 2) - 1;
                            for (let i = 0; i < doorWidth; i++) {
                                if (rightY + i < room.y + room.height - 1) {
                                    mapFloors[floor][rightY + i][room.x + room.width - 1] = TileType.FLOOR;
                                }
                            }
                            break;
                    }
                }
            }
        }
        
        // æ·»åŠ èµ°å»Šå¢™å£
        function addCorridorWalls(floor) {
            const tempMap = JSON.parse(JSON.stringify(mapFloors[floor]));
            
            for (let y = 1; y < mapFloors[floor].length - 1; y++) {
                for (let x = 1; x < mapFloors[floor][0].length - 1; x++) {
                    if (tempMap[y][x] === TileType.FLOOR || 
                        tempMap[y][x] === TileType.MEDIUM_GROUND ||
                        tempMap[y][x] === TileType.HIGH_GROUND ||
                        tempMap[y][x] === TileType.LOW_GROUND ||
                        tempMap[y][x] === TileType.T_SPAWN ||
                        tempMap[y][x] === TileType.CT_SPAWN ||
                        tempMap[y][x] === TileType.BOMBSITE_A ||
                        tempMap[y][x] === TileType.BOMBSITE_B) {
                        
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘
                        const directions = [[-1, 0], [0, -1], [0, 1], [1, 0]];
                        
                        for (let [dy, dx] of directions) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < mapFloors[floor].length && 
                                nx >= 0 && nx < mapFloors[floor][0].length) {
                                if (tempMap[ny][nx] === TileType.VOID && 
                                    mapFloors[floor][ny][nx] === TileType.VOID) {
                                    mapFloors[floor][ny][nx] = TileType.WALL;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // æ·»åŠ æ¥¼æ¢¯ï¼ˆæ”¹è¿›ç‰ˆï¼šç¡®ä¿ä¸é“è·¯è¿æ¥ï¼‰
        function addStairs(rooms, stairsCount) {
            if (totalFloors <= 1) return;
            
            // ä¸ºæ¯å¯¹ç›¸é‚»æ¥¼å±‚åˆ›å»ºæ¥¼æ¢¯
            for (let floor = 0; floor < totalFloors - 1; floor++) {
                let stairsPlaced = 0;
                
                // æ”¶é›†æ‰€æœ‰é“è·¯ä½ç½®
                const roadPositions = [];
                for (let y = 0; y < mapFloors[floor].length; y++) {
                    for (let x = 0; x < mapFloors[floor][0].length; x++) {
                        if (mapFloors[floor][y][x] === TileType.FLOOR ||
                            mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][x] === TileType.LOW_GROUND) {
                            roadPositions.push({ x, y });
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰é“è·¯ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
                if (roadPositions.length === 0) {
                    roadPositions.push(
                        { x: Math.floor(mapFloors[0][0].length / 2), y: Math.floor(mapFloors[0].length / 2) }
                    );
                }
                
                // æ‰“ä¹±é“è·¯ä½ç½®é¡ºåº
                roadPositions.sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < Math.min(stairsCount, roadPositions.length); i++) {
                    const roadPos = roadPositions[i];
                    
                    // åœ¨é“è·¯é™„è¿‘å¯»æ‰¾åˆé€‚çš„ä½ç½®
                    let found = false;
                    for (let dy = -3; dy <= 3 && !found; dy++) {
                        for (let dx = -3; dx <= 3 && !found; dx++) {
                            const x = roadPos.x + dx;
                            const y = roadPos.y + dy;
                            
                            // æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆ2x2åŒºåŸŸï¼‰
                            if (x >= 1 && x < mapFloors[0][0].length - 2 &&
                                y >= 1 && y < mapFloors[0].length - 2) {
                                
                                // æ£€æŸ¥å½“å‰å±‚æ˜¯å¦å¯ä»¥æ”¾ç½®æ¥¼æ¢¯
                                let canPlaceLower = true;
                                let canPlaceUpper = true;
                                
                                for (let sy = 0; sy < 2; sy++) {
                                    for (let sx = 0; sx < 2; sx++) {
                                        // æ£€æŸ¥ä¸‹å±‚
                                        if (mapFloors[floor][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceLower = false;
                                        }
                                        // æ£€æŸ¥ä¸Šå±‚
                                        if (mapFloors[floor + 1][y + sy][x + sx] !== TileType.FLOOR &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.MEDIUM_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.HIGH_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.LOW_GROUND &&
                                            mapFloors[floor + 1][y + sy][x + sx] !== TileType.VOID) {
                                            canPlaceUpper = false;
                                        }
                                    }
                                }
                                
                                // æ£€æŸ¥æ˜¯å¦ä¸é“è·¯ç›¸é‚»
                                let hasRoadAdjacent = false;
                                for (let sy = -1; sy <= 2; sy++) {
                                    for (let sx = -1; sx <= 2; sx++) {
                                        const nx = x + sx;
                                        const ny = y + sy;
                                        if (nx >= 0 && nx < mapFloors[floor][0].length &&
                                            ny >= 0 && ny < mapFloors[floor].length) {
                                            if (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                                mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][ny][nx] === TileType.LOW_GROUND) {
                                                hasRoadAdjacent = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (hasRoadAdjacent) break;
                                }
                                
                                if ((canPlaceLower || canPlaceUpper) && hasRoadAdjacent) {
                                    // åœ¨ä¸‹å±‚åˆ›å»ºå‘ä¸Šçš„æ¥¼æ¢¯
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // å¦‚æœæ˜¯ç©ºåœ°ï¼Œå…ˆåˆ›å»ºåœ°æ¿
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // ç„¶åè®¾ç½®ä¸ºæ¥¼æ¢¯ï¼ˆæ”¯æŒæ‰€æœ‰åœ°é¢ç±»å‹ï¼‰
                                            if (mapFloors[floor][y + sy][x + sx] === TileType.FLOOR ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.MEDIUM_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.HIGH_GROUND ||
                                                mapFloors[floor][y + sy][x + sx] === TileType.LOW_GROUND) {
                                                mapFloors[floor][y + sy][x + sx] = TileType.STAIRS_UP;
                                            }
                                        }
                                    }
                                    
                                    // åœ¨ä¸Šå±‚çš„ç›¸åŒä½ç½®åˆ›å»ºå‘ä¸‹çš„æ¥¼æ¢¯
                                    for (let sy = 0; sy < 2; sy++) {
                                        for (let sx = 0; sx < 2; sx++) {
                                            // å¦‚æœæ˜¯ç©ºåœ°ï¼Œå…ˆåˆ›å»ºåœ°æ¿
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.VOID) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.FLOOR;
                                            }
                                            // ç„¶åè®¾ç½®ä¸ºæ¥¼æ¢¯
                                            if (mapFloors[floor + 1][y + sy][x + sx] === TileType.FLOOR) {
                                                mapFloors[floor + 1][y + sy][x + sx] = TileType.STAIRS_DOWN;
                                            }
                                        }
                                    }
                                    
                                    // ç¡®ä¿æ¥¼æ¢¯å‘¨å›´æœ‰å¢™å£
                                    ensureStairWalls(x, y, floor);
                                    ensureStairWalls(x, y, floor + 1);
                                    
                                    stairsPlaced++;
                                    found = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // ç¡®ä¿æ¥¼æ¢¯å‘¨å›´æœ‰é€‚å½“çš„å¢™å£
        function ensureStairWalls(x, y, floor) {
            // æ£€æŸ¥æ¥¼æ¢¯å‘¨å›´3x3åŒºåŸŸ
            for (let dy = -1; dy <= 2; dy++) {
                for (let dx = -1; dx <= 2; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    // è·³è¿‡æ¥¼æ¢¯æœ¬èº«ï¼ˆ2x2ä¸­å¿ƒåŒºåŸŸï¼‰
                    if (dx >= 0 && dx <= 1 && dy >= 0 && dy <= 1) {
                        continue;
                    }
                    
                    // å¦‚æœæ˜¯è¾¹ç•Œä½ç½®ä¸”æ˜¯ç©ºåœ°ï¼Œæ·»åŠ å¢™å£
                    if (nx >= 0 && nx < mapFloors[floor][0].length &&
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny][nx] === TileType.VOID) {
                            // æ£€æŸ¥æ˜¯å¦ä¸é“è·¯ç›¸é‚»ï¼Œå¦‚æœæ˜¯åˆ™ä¸æ·»åŠ å¢™å£
                            let hasRoadAdjacent = false;
                            for (let sy = -1; sy <= 1; sy++) {
                                for (let sx = -1; sx <= 1; sx++) {
                                    const checkX = nx + sx;
                                    const checkY = ny + sy;
                                    if (checkX >= 0 && checkX < mapFloors[floor][0].length &&
                                        checkY >= 0 && checkY < mapFloors[floor].length) {
                                        if (mapFloors[floor][checkY][checkX] === TileType.FLOOR ||
                                            mapFloors[floor][checkY][checkX] === TileType.MEDIUM_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.HIGH_GROUND ||
                                            mapFloors[floor][checkY][checkX] === TileType.LOW_GROUND) {
                                            hasRoadAdjacent = true;
                                            break;
                                        }
                                    }
                                }
                                if (hasRoadAdjacent) break;
                            }
                            
                            // åªåœ¨æ²¡æœ‰é“è·¯ç›¸é‚»çš„è¾¹ç¼˜æ·»åŠ å¢™å£
                            if (!hasRoadAdjacent && (Math.abs(dx) === 1 || Math.abs(dy) === 1)) {
                                mapFloors[floor][ny][nx] = TileType.WALL;
                            }
                        }
                    }
                }
            }
        }
        
        // è¿æ¥æ¥¼æ¢¯åˆ°æœ€è¿‘çš„æˆ¿é—´æˆ–èµ°å»Š
        function connectStairToRooms(stairX, stairY, floor) {
            // æŸ¥æ‰¾æœ€è¿‘çš„åœ°æ¿åŒºåŸŸ
            let nearestFloor = null;
            let minDist = Infinity;
            
            for (let y = 0; y < mapFloors[floor].length; y++) {
                for (let x = 0; x < mapFloors[floor][0].length; x++) {
                    if (mapFloors[floor][y][x] === TileType.FLOOR ||
                        mapFloors[floor][y][x] === TileType.T_SPAWN ||
                        mapFloors[floor][y][x] === TileType.CT_SPAWN ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_A ||
                        mapFloors[floor][y][x] === TileType.BOMBSITE_B) {
                        
                        const dist = Math.abs(x - stairX) + Math.abs(y - stairY);
                        if (dist < minDist && dist > 3) { // è·ç¦»å¤§äº3æ‰éœ€è¦è¿æ¥
                            minDist = dist;
                            nearestFloor = { x, y };
                        }
                    }
                }
            }
            
            // å¦‚æœæ‰¾åˆ°äº†éœ€è¦è¿æ¥çš„åœ°æ¿ï¼Œåˆ›å»ºèµ°å»Š
            if (nearestFloor && minDist < 15) {
                createSimpleCorridor(stairX + 1, stairY + 1, nearestFloor.x, nearestFloor.y, floor);
            }
        }
        
        // åˆ›å»ºç®€å•èµ°å»Šè¿æ¥ä¸¤ç‚¹
        function createSimpleCorridor(x1, y1, x2, y2, floor) {
            // å…ˆæ°´å¹³åå‚ç›´
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            
            // æ°´å¹³æ®µ
            for (let x = minX; x <= maxX; x++) {
                if (mapFloors[floor][y1][x] === TileType.VOID) {
                    mapFloors[floor][y1][x] = TileType.FLOOR;
                }
                // æ·»åŠ å¢™å£
                if (y1 > 0 && mapFloors[floor][y1 - 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 - 1][x] = TileType.WALL;
                }
                if (y1 < mapFloors[floor].length - 1 && mapFloors[floor][y1 + 1][x] === TileType.VOID) {
                    mapFloors[floor][y1 + 1][x] = TileType.WALL;
                }
            }
            
            // å‚ç›´æ®µ
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            for (let y = minY; y <= maxY; y++) {
                if (mapFloors[floor][y][x2] === TileType.VOID) {
                    mapFloors[floor][y][x2] = TileType.FLOOR;
                }
                // æ·»åŠ å¢™å£
                if (x2 > 0 && mapFloors[floor][y][x2 - 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 - 1] = TileType.WALL;
                }
                if (x2 < mapFloors[floor][0].length - 1 && mapFloors[floor][y][x2 + 1] === TileType.VOID) {
                    mapFloors[floor][y][x2 + 1] = TileType.WALL;
                }
            }
        }
        
        // æ·»åŠ ç‰¹æ®Šå…ƒç´ 
        function addSpecialElements(rooms, coverDensity, waterAmount, windowDensity) {
            // è®¾ç½®å‡ºç”Ÿç‚¹å’ŒåŒ…ç‚¹
            if (rooms.length >= 3) {
                const firstFloorRooms = rooms.filter(r => r.floor === 0);
                if (firstFloorRooms.length >= 3) {
                    // Tå‡ºç”Ÿç‚¹
                    const tRoom = firstFloorRooms[0];
                    for (let y = tRoom.y + 1; y < tRoom.y + tRoom.height - 1; y++) {
                        for (let x = tRoom.x + 1; x < tRoom.x + tRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.T_SPAWN;
                            }
                        }
                    }
                    
                    // CTå‡ºç”Ÿç‚¹
                    const ctRoom = firstFloorRooms[firstFloorRooms.length - 1];
                    for (let y = ctRoom.y + 1; y < ctRoom.y + ctRoom.height - 1; y++) {
                        for (let x = ctRoom.x + 1; x < ctRoom.x + ctRoom.width - 1; x++) {
                                                if (mapFloors[0][y][x] === TileType.FLOOR || 
                        mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                        mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                        mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                mapFloors[0][y][x] = TileType.CT_SPAWN;
                            }
                        }
                    }
                    
                    // ç”ŸæˆåŒ…ç‚¹
                    const bombSiteCount = parseInt(document.getElementById('bombSiteCount').value);
                    const availableRooms = firstFloorRooms.slice(2); // è·³è¿‡å‡ºç”Ÿç‚¹æˆ¿é—´
                    
                    // ç¡®ä¿æœ‰è¶³å¤Ÿçš„æˆ¿é—´
                    const maxBombSites = Math.min(bombSiteCount, availableRooms.length);
                    
                    for (let i = 0; i < maxBombSites; i++) {
                        const roomIndex = Math.floor((i + 1) * availableRooms.length / (maxBombSites + 1));
                        const bombRoom = availableRooms[roomIndex];
                        
                        if (bombRoom) {
                            const centerX = Math.floor(bombRoom.x + bombRoom.width / 2);
                            const centerY = Math.floor(bombRoom.y + bombRoom.height / 2);
                            
                            // æ ¹æ®åŒ…ç‚¹ç´¢å¼•é€‰æ‹©TileType
                            const bombSiteType = i === 0 ? TileType.BOMBSITE_A : 
                                               i === 1 ? TileType.BOMBSITE_B :
                                               i === 2 ? TileType.BOMBSITE_C :
                                               i === 3 ? TileType.BOMBSITE_D :
                                               TileType.BOMBSITE_E;
                            
                            // åˆ›å»ºåŒ…ç‚¹åŒºåŸŸ
                            for (let y = centerY - 2; y <= centerY + 2; y++) {
                                for (let x = centerX - 2; x <= centerX + 2; x++) {
                                    if (y > bombRoom.y && y < bombRoom.y + bombRoom.height - 1 &&
                                        x > bombRoom.x && x < bombRoom.x + bombRoom.width - 1) {
                                        if (mapFloors[0][y][x] === TileType.FLOOR || 
                                            mapFloors[0][y][x] === TileType.MEDIUM_GROUND ||
                                            mapFloors[0][y][x] === TileType.HIGH_GROUND ||
                                            mapFloors[0][y][x] === TileType.LOW_GROUND) {
                                            mapFloors[0][y][x] = bombSiteType;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // æ·»åŠ æ©ä½“ï¼ˆåªç”Ÿæˆåœ¨é å¢™æˆ–é é—¨ä½ç½®ï¼Œæ¯æ®µé“è·¯æœ€å¤š3ä¸ªï¼‰
            for (let floor = 0; floor < totalFloors; floor++) {
                // æ‰¾åˆ°æ‰€æœ‰é“è·¯æ®µ
                const roadSegments = findRoadSegments(mapFloors[floor][0].length, floor);
                
                // ä¸ºæ¯ä¸ªé“è·¯æ®µæ·»åŠ æ©ä½“
                for (const segment of roadSegments) {
                    const maxCoversPerSegment = 3; // æ¯æ®µé“è·¯æœ€å¤š3ä¸ªæ©ä½“
                    const segmentCoverCount = Math.min(
                        Math.floor(segment.length * coverDensity / 1000), 
                        maxCoversPerSegment
                    );
                    
                    let placedCount = 0;
                    let attempts = 0;
                    const maxAttempts = segment.length * 2; // é™åˆ¶å°è¯•æ¬¡æ•°
                    
                    // éšæœºæ‰“ä¹±é“è·¯æ®µä¸­çš„ç‚¹
                    const shuffledPoints = [...segment].sort(() => Math.random() - 0.5);
                    
                    for (const point of shuffledPoints) {
                        if (placedCount >= segmentCoverCount || attempts >= maxAttempts) break;
                        
                        const x = point.x;
                        const y = point.y;
                        
                        if ((mapFloors[floor][y][x] === TileType.FLOOR || 
                             mapFloors[floor][y][x] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][y][x] === TileType.HIGH_GROUND ||
                             mapFloors[floor][y][x] === TileType.LOW_GROUND) && 
                            isNearWallOrDoor(x, y, floor)) {
                        mapFloors[floor][y][x] = TileType.COVER;
                            placedCount++;
                        }
                        attempts++;
                    }
                }
            }
            
            // æ·»åŠ æ°´åŸŸï¼ˆåªåœ¨ç¬¬ä¸€å±‚ï¼‰- ä½¿ç”¨æ´ªæ°´å¡«å……åˆ›å»ºè¿ç»­æ°´åŸŸ
            if (waterAmount > 0) {
                createWaterAreas(waterAmount);
            }
            
            // æ·»åŠ é˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
            const shadowPointDensity = parseInt(document.getElementById('shadowPoint').value);
            if (shadowPointDensity > 0) {
                // åœ¨æ‰€æœ‰æ¥¼å±‚æ·»åŠ é˜´ç‚¹
                for (let floor = 0; floor < totalFloors; floor++) {
                    addShadowPoints(shadowPointDensity, floor);
                }
            }
            
            // æ·»åŠ çª—æˆ·
            for (let floor = 0; floor < totalFloors; floor++) {
                const windowCount = Math.floor(mapFloors[floor].length * mapFloors[floor][0].length * windowDensity / 1000);
                for (let i = 0; i < windowCount; i++) {
                    const x = Math.floor(Math.random() * (mapFloors[floor][0].length - 2)) + 1;
                    const y = Math.floor(Math.random() * (mapFloors[floor].length - 2)) + 1;
                    if (mapFloors[floor][y][x] === TileType.WALL) {
                        // æ£€æŸ¥æ˜¯å¦åˆé€‚æ”¾çª—æˆ·
                        let hasFloorNearby = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                if (ny >= 0 && ny < mapFloors[floor].length && 
                                    nx >= 0 && nx < mapFloors[floor][0].length &&
                                    mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                                    (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                                     mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                                     mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                                    hasFloorNearby = true;
                                }
                            }
                        }
                        if (hasFloorNearby) {
                            mapFloors[floor][y][x] = TileType.WINDOW;
                        }
                    }
                }
            }
        }
        
        // æ¸¸æˆæ¨¡å¼é…ç½®
        const gameModes = {
            team: {
                name: "å›¢é˜Ÿç«æŠ€",
                description: "å›¢é˜Ÿç«æŠ€æ¨¡å¼",
                spawnPoints: { t: 2, ct: 2 },
                objectives: ["elimination"],
                features: ["cover", "water", "stairs", "windows"]
            },
            bomb: {
                name: "çˆ†ç ´æ¨¡å¼", 
                description: "çˆ†ç ´æ¨¡å¼",
                spawnPoints: { t: 5, ct: 5 },
                objectives: ["bomb_a", "bomb_b"],
                features: ["cover", "water", "stairs", "windows", "bombsites"]
            },
            zombie: {
                name: "ç”ŸåŒ–æ¨¡å¼",
                description: "ç”ŸåŒ–æ¨¡å¼", 
                spawnPoints: { human: 8, zombie: 2 },
                objectives: ["survival"],
                features: ["cover", "water", "stairs", "windows", "safe_zones"]
            }
        };

        // åœ°å›¾é£æ ¼é…ç½®
        const mapStyles = {
            balanced: {
                name: "å¹³è¡¡å‹",
                description: "å¹³è¡¡å‹åœ°å›¾",
                layout: "balanced",
                coverDensity: 1.0,
                waterAmount: 1.0,
                complexity: 1.0
            },
            ct_sided: {
                name: "CTä¼˜åŠ¿",
                description: "CTä¼˜åŠ¿åœ°å›¾",
                layout: "ct_sided", 
                coverDensity: 0.8,
                waterAmount: 1.2,
                complexity: 1.1
            },
            t_sided: {
                name: "Tä¼˜åŠ¿",
                description: "Tä¼˜åŠ¿åœ°å›¾",
                layout: "t_sided",
                coverDensity: 1.2,
                waterAmount: 0.8,
                complexity: 0.9
            },
            aim_heavy: {
                name: "æªæ³•å‹",
                description: "æªæ³•å‹åœ°å›¾",
                layout: "aim_heavy",
                coverDensity: 0.6,
                waterAmount: 0.5,
                complexity: 0.8
            },
            tactical: {
                name: "æˆ˜æœ¯å‹",
                description: "æˆ˜æœ¯å‹åœ°å›¾",
                layout: "tactical",
                coverDensity: 1.3,
                waterAmount: 1.1,
                complexity: 1.2
            },
            rush: {
                name: "å¿«æ”»å‹",
                description: "å¿«æ”»å‹åœ°å›¾",
                layout: "rush",
                coverDensity: 0.7,
                waterAmount: 0.6,
                complexity: 0.7
            },
            black_town: {
                name: "é»‘è‰²åŸé•‡",
                description: "é»‘è‰²åŸé•‡é£æ ¼",
                layout: "urban",
                coverDensity: 1.1,
                waterAmount: 0.3,
                complexity: 1.0,
                theme: "dark_urban"
            },
            desert_gray: {
                name: "æ²™æ¼ ç°",
                description: "æ²™æ¼ ç°é£æ ¼",
                layout: "desert",
                coverDensity: 0.8,
                waterAmount: 0.1,
                complexity: 0.9,
                theme: "desert"
            },
            new_year_plaza: {
                name: "æ–°å¹´å¹¿åœº",
                description: "æ–°å¹´å¹¿åœºé£æ ¼",
                layout: "plaza",
                coverDensity: 1.0,
                waterAmount: 0.5,
                complexity: 1.1,
                theme: "festival"
            },
            white_house: {
                name: "ç™½æˆ¿",
                description: "ç™½æˆ¿é£æ ¼",
                layout: "mansion",
                coverDensity: 1.2,
                waterAmount: 0.4,
                complexity: 1.3,
                theme: "luxury"
            },
            transport_ship: {
                name: "è¿è¾“èˆ¹",
                description: "è¿è¾“èˆ¹é£æ ¼",
                layout: "ship",
                coverDensity: 0.9,
                waterAmount: 0.8,
                complexity: 1.0,
                theme: "naval"
            },
            satellite_base: {
                name: "å«æ˜ŸåŸºåœ°",
                description: "å«æ˜ŸåŸºåœ°é£æ ¼",
                layout: "military",
                coverDensity: 1.1,
                waterAmount: 0.2,
                complexity: 1.2,
                theme: "military"
            },
            harbor_dock: {
                name: "æ¸¯å£ç å¤´",
                description: "æ¸¯å£ç å¤´é£æ ¼",
                layout: "harbor",
                coverDensity: 1.0,
                waterAmount: 1.5,
                complexity: 1.1,
                theme: "harbor"
            },
            subway_station: {
                name: "åœ°é“ç«™",
                description: "åœ°é“ç«™é£æ ¼",
                layout: "underground",
                coverDensity: 1.3,
                waterAmount: 0.1,
                complexity: 1.4,
                theme: "underground"
            }
        };

        // åº”ç”¨æ¸¸æˆæ¨¡å¼è®¾ç½®
        function applyGameMode(gameMode) {
            const mode = gameModes[gameMode];
            if (!mode) return;
            
            // æ›´æ–°åœ°å›¾æ ‡é¢˜
            document.getElementById('mapName').textContent = mode.name + "åœ°å›¾";
            
            // æ›´æ–°æ¨¡å¼æè¿°
            const modeDescription = document.querySelector('.map-header div:last-child');
            if (modeDescription) {
                modeDescription.textContent = mode.description;
            }
            
            return mode;
        }

        // åº”ç”¨åœ°å›¾é£æ ¼è®¾ç½®
        function applyMapStyle(mapStyle) {
            const style = mapStyles[mapStyle];
            if (!style) return;
            
            // æ ¹æ®é£æ ¼è°ƒæ•´å‚æ•°
            const coverDensitySlider = document.getElementById('coverDensity');
            const waterAmountSlider = document.getElementById('waterAmount');
            const pathComplexitySlider = document.getElementById('pathComplexity');
            
            if (coverDensitySlider && style.coverDensity) {
                const currentValue = parseInt(coverDensitySlider.value);
                const newValue = Math.round(currentValue * style.coverDensity);
                coverDensitySlider.value = Math.min(100, Math.max(10, newValue));
                document.getElementById('coverValue').textContent = coverDensitySlider.value;
            }
            
            if (waterAmountSlider && style.waterAmount) {
                const currentValue = parseInt(waterAmountSlider.value);
                const newValue = Math.round(currentValue * style.waterAmount);
                waterAmountSlider.value = Math.min(50, Math.max(0, newValue));
                document.getElementById('waterValue').textContent = waterAmountSlider.value;
            }
            
            if (pathComplexitySlider && style.complexity) {
                const currentValue = parseInt(pathComplexitySlider.value);
                const newValue = Math.round(currentValue * style.complexity);
                pathComplexitySlider.value = Math.min(4, Math.max(0, newValue));
                document.getElementById('pathValue').textContent = getComplexityText(pathComplexitySlider.value);
            }
            
            return style;
        }

        // è·å–å¤æ‚åº¦æ–‡æœ¬
        function getComplexityText(value) {
            const texts = ['ç®€å•', 'è¾ƒç®€å•', 'ä¸­', 'è¾ƒå¤æ‚', 'å¤æ‚'];
            return texts[value] || 'ä¸­';
        }
        
        // ç”Ÿæˆåœ°å›¾
        function generateMap() {
            // è·å–æ¸¸æˆæ¨¡å¼å’Œåœ°å›¾é£æ ¼
            const gameMode = document.getElementById('gameMode').value;
            const mapStyle = document.getElementById('mapStyle').value;
            
            // åº”ç”¨æ¸¸æˆæ¨¡å¼è®¾ç½®
            const modeConfig = applyGameMode(gameMode);
            
            // åº”ç”¨åœ°å›¾é£æ ¼è®¾ç½®
            const styleConfig = applyMapStyle(mapStyle);
            
            const size = parseInt(document.getElementById('mapSize').value);
            const floors = parseInt(document.getElementById('floorCount').value);
            const roomCount = parseInt(document.getElementById('roomCount').value);
            const corridorWidth = parseInt(document.getElementById('corridorWidth').value);
            const coverDensity = parseInt(document.getElementById('coverDensity').value);
            const waterAmount = parseInt(document.getElementById('waterAmount').value);
            const stairsCount = parseInt(document.getElementById('stairsCount').value);
            const windowDensity = parseInt(document.getElementById('windowDensity').value);
            
            // åˆå§‹åŒ–åœ°å›¾
            initMap(size, floors);
            
            // ç”Ÿæˆæ¯å±‚çš„æˆ¿é—´
            const allRooms = [];
            for (let floor = 0; floor < floors; floor++) {
                const rooms = generateRooms(size, roomCount, floor);
                connectRooms(rooms, floor, corridorWidth);
                
                // ç”Ÿæˆå¤§å…ï¼ˆåªåœ¨ç¬¬ä¸€å±‚ï¼‰
                if (floor === 0) {
                    generateLobby(size, floor);
                }
                
                // ç”Ÿæˆé«˜ä½å·®åŒºåŸŸ
                generateElevationAreas(size, floor);
                
                // æ·»åŠ æˆ¿é—´å¡«å……ï¼ˆåœ¨æˆ¿é—´å†…éƒ¨åˆ›å»ºæ›´å¤šå°æˆ¿é—´ï¼‰
                addRoomFilling(rooms, floor);
                
                allRooms.push(...rooms);
            }
            
            // æ·»åŠ æ¥¼æ¢¯
            addStairs(allRooms, stairsCount);
            
            // æ·»åŠ ç‰¹æ®Šå…ƒç´ 
            addSpecialElements(allRooms, coverDensity, waterAmount, windowDensity);
            
            // åˆ›å»ºæ¥¼å±‚é€‰æ‹©å™¨
            createFloorSelector();
            
            // é‡ç½®åˆ°ç¬¬ä¸€å±‚
            currentFloor = 0;
            
            // ç»˜åˆ¶å åŠ è§†å›¾åœ°å›¾
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const cellSize = 10;
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ä»åº•å±‚åˆ°é¡¶å±‚ç»˜åˆ¶ï¼Œä½¿ç”¨é€æ˜åº¦
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25); // é«˜å±‚æ›´é€æ˜
                const offset = floor * 2; // æ¯å±‚åç§»ï¼Œåˆ›å»º3Dæ•ˆæœ
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let color = '#000';
                            
                            // æ ¹æ®æ¥¼å±‚è°ƒæ•´é¢œè‰²
                            switch(tile) {
                                case TileType.FLOOR: 
                                    color = floor === 0 ? 'rgba(74, 74, 74, ' : 
                                           floor === 1 ? 'rgba(90, 90, 90, ' : 
                                           floor === 2 ? 'rgba(106, 106, 106, ' : 
                                           'rgba(122, 122, 122, ';
                                    break;
                                case TileType.WALL: 
                                    color = floor === 0 ? 'rgba(176, 176, 176, ' : 
                                           floor === 1 ? 'rgba(160, 160, 176, ' : 
                                           floor === 2 ? 'rgba(144, 144, 176, ' : 
                                           'rgba(128, 128, 176, ';
                                    break;
                                case TileType.DOOR: 
                                    color = 'rgba(96, 96, 96, '; 
                                    break;
                                case TileType.WINDOW: 
                                    color = 'rgba(106, 140, 175, '; 
                                    break;
                                case TileType.COVER: 
                                    color = 'rgba(48, 48, 48, '; 
                                    break;
                                case TileType.BOMBSITE_A: 
                                    color = 'rgba(90, 90, 0, '; 
                                    break;
                                case TileType.BOMBSITE_B: 
                                    color = 'rgba(90, 58, 0, '; 
                                    break;
                                case TileType.T_SPAWN: 
                                    color = 'rgba(58, 32, 32, '; 
                                    break;
                                case TileType.CT_SPAWN: 
                                    color = 'rgba(32, 32, 48, '; 
                                    break;
                                case TileType.STAIRS_UP: 
                                    color = 'rgba(139, 115, 85, '; 
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    color = 'rgba(107, 83, 69, '; 
                                    break;
                                case TileType.WATER: 
                                    color = 'rgba(42, 77, 105, '; 
                                    break;
                                case TileType.BRIDGE: 
                                    color = 'rgba(90, 90, 90, '; 
                                    break;
                            }
                            
                            // æ·»åŠ é€æ˜åº¦
                            color += opacity + ')';
                            
                            ctx.fillStyle = color;
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // ç»˜åˆ¶å¢™å£è¾¹æ¡†
                            if (tile === TileType.WALL) {
                                ctx.strokeStyle = 'rgba(128, 128, 128, ' + (opacity * 0.5) + ')';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(
                                    x * cellSize + offset, 
                                    y * cellSize + offset, 
                                    cellSize, 
                                    cellSize
                                );
                            }
                            
                            // ç»˜åˆ¶æ¥¼æ¢¯ç®­å¤´å’Œæ¥¼å±‚æ ‡è®°
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                ctx.font = '8px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? 'â†‘' : 'â†“';
                                ctx.fillText(
                                    arrow + (floor + 1), 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + 3 + offset
                                );
                            }
                        }
                    }
                }
                
                // ç»˜åˆ¶æ¥¼å±‚æ ‡ç­¾
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`F${floor + 1}`, 10 + offset, 20 + offset);
            }
            
            // ç»˜åˆ¶è¯´æ˜
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('å åŠ è§†å›¾æ¨¡å¼', canvas.width - 10, 20);
            
            // ç»˜åˆ¶æ¥¼å±‚å›¾ä¾‹
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                ctx.fillRect(10, 40 + i * 20, 15, 15);
                ctx.fillStyle = '#ccc';
                ctx.fillText(`ç¬¬${i + 1}å±‚`, 30, 50 + i * 20);
            }
            
            // ç»˜åˆ¶åŒ…ç‚¹æ ‡è®°ï¼ˆæ‰€æœ‰å±‚ï¼‰
            const overlayBombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + overlayBombFontSize + 'px Arial';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                ctx.fillStyle = 'rgba(255, 215, 0, ' + opacity + ')';
                
                // AåŒ…ç‚¹
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_A) {
                            ctx.strokeText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('A', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
                
                // BåŒ…ç‚¹
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        if (currentMap[y][x] === TileType.BOMBSITE_B) {
                            ctx.strokeText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            ctx.fillText('B', x * cellSize + Math.floor(cellSize * 1.5) + offset, y * cellSize + Math.floor(cellSize * 2.5) + offset);
                            y = currentMap.length;
                            break;
                        }
                    }
                }
            }
        }
            drawMap();
        }
        
        // åˆ›å»ºæ¥¼å±‚é€‰æ‹©å™¨
        function createFloorSelector() {
            const selector = document.getElementById('floorSelector');
            selector.innerHTML = '';
            
            // æ·»åŠ æ¥¼å±‚æŒ‰é’®
            for (let i = 0; i < totalFloors; i++) {
                const btn = document.createElement('button');
                btn.className = 'floor-btn';
                btn.textContent = `ç¬¬${i + 1}å±‚`;
                btn.onclick = function() {
                    overlayMode = false;
                    currentFloor = i;
                    updateFloorButtons();
                    drawMap();
                };
                if (i === 0 && !overlayMode) {
                    btn.classList.add('active');
                }
                selector.appendChild(btn);
            }
            
            // æ·»åŠ å åŠ è§†å›¾æŒ‰é’®
            if (totalFloors > 1) {
                const overlayBtn = document.createElement('button');
                overlayBtn.className = 'overlay-btn';
                overlayBtn.textContent = 'ğŸ”² å åŠ è§†å›¾';
                overlayBtn.onclick = function() {
                    overlayMode = !overlayMode;
                    updateFloorButtons();
                    
                    if (overlayMode) {
                        overlayBtn.classList.add('active');
                        drawOverlayMap();
                    } else {
                        overlayBtn.classList.remove('active');
                        drawMap();
                    }
                };
                selector.appendChild(overlayBtn);
            }
        }
        
        // æ›´æ–°æ¥¼å±‚æŒ‰é’®çŠ¶æ€
        function updateFloorButtons() {
            const buttons = document.querySelectorAll('.floor-btn');
            const overlayBtn = document.querySelector('.overlay-btn');
            
            buttons.forEach((btn, index) => {
                if (!overlayMode && index === currentFloor) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            if (overlayBtn) {
                if (overlayMode) {
                    overlayBtn.classList.add('active');
                } else {
                    overlayBtn.classList.remove('active');
                }
            }
        }
        
        // ç»˜åˆ¶åœ°å›¾
        function drawMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // å¯ç”¨æŠ—é”¯é½¿å’Œå¹³æ»‘æ•ˆæœ
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[currentFloor]) return;
            
            const map = mapFloors[currentFloor];
            const mapSize = parseInt(document.getElementById('mapSize').value);
            
            // æ ¹æ®åœ°å›¾å°ºå¯¸åŠ¨æ€è°ƒæ•´æ–¹å—å¤§å°ï¼Œä½¿ç”¨æ›´å°çš„å°ºå¯¸å‡å°‘åƒç´ æ„Ÿ
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // é™åˆ¶ç”»å¸ƒæœ€å¤§å°ºå¯¸ï¼Œé¿å…è¿‡å¤§
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶åœ°å›¾
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[0].length; x++) {
                    const tile = map[y][x];
                    let color = '#000';
                    
                    switch(tile) {
                        case TileType.FLOOR: color = '#4a4a4a'; break;
                        case TileType.WALL: color = '#b0b0b0'; break;
                        case TileType.DOOR: color = '#606060'; break;
                        case TileType.WINDOW: color = '#6a8caf'; break;
                        case TileType.COVER: color = '#303030'; break;
                        case TileType.HIGH_GROUND: color = '#6a6a4a'; break;    // é«˜åœ°ï¼ˆæµ…é»„ç°ï¼‰
                        case TileType.LOW_GROUND: color = '#2a2a4a'; break;     // ä½åœ°ï¼ˆæ·±è“ç°ï¼‰
                        case TileType.MEDIUM_GROUND: color = '#4a4a4a'; break;  // ä¸­ç­‰åœ°ï¼ˆæ ‡å‡†ç°ï¼‰
                        case TileType.BOMBSITE_A: color = '#5a5a00'; break;
                        case TileType.BOMBSITE_B: color = '#5a3a00'; break;
                        case TileType.BOMBSITE_C: color = '#5a1a00'; break; // åŒ…ç‚¹Cï¼ˆæ·±æ©™ï¼‰
                        case TileType.BOMBSITE_D: color = '#3a5a00'; break; // åŒ…ç‚¹Dï¼ˆæ·±ç»¿ï¼‰
                        case TileType.BOMBSITE_E: color = '#1a5a00'; break; // åŒ…ç‚¹Eï¼ˆæ·±é’ï¼‰
                        case TileType.T_SPAWN: color = '#3a2020'; break;
                        case TileType.CT_SPAWN: color = '#202030'; break;
                        case TileType.STAIRS_UP: color = '#8B7355'; break;
                        case TileType.STAIRS_DOWN: color = '#6B5345'; break;
                        case TileType.WATER: color = '#2a4d69'; break;
                        case TileType.BRIDGE: color = '#5a5a5a'; break;
                        case TileType.OUTDOOR: color = '#7a8a6a'; break;           // å¤–åœºåœ°é¢ï¼ˆæµ…ç»¿ç°ï¼‰
                        case TileType.OUTDOOR_WALL: color = '#8a8a7a'; break;     // å¤–åœºå›´å¢™ï¼ˆæµ…ç°ï¼‰
                        case TileType.OUTDOOR_COVER: color = '#4a5a4a'; break;    // å¤–åœºæ©ä½“ï¼ˆæ·±ç»¿ç°ï¼‰
                        case TileType.LOBBY: color = '#6a7a8a'; break;            // å¤§å…
                        case TileType.LOBBY_ENTRANCE: color = '#8a6a7a'; break;   // å¤§å…å…¥å£
                        case TileType.LOBBY_CENTER: color = '#7a6a8a'; break;     // å¤§å…ä¸­å¿ƒ
                        // å¸¸è§åœ°å½¢/æ¨¡å—é¢œè‰²
                        case TileType.LONG_LANE: color = '#8a4a4a'; break;        // å¤§é“ï¼ˆæ·±çº¢ç°ï¼‰
                        case TileType.SHORT_LANE: color = '#4a8a4a'; break;       // å°é“ï¼ˆæ·±ç»¿ç°ï¼‰
                        case TileType.MID_LANE: color = '#4a4a8a'; break;         // ä¸­è·¯ï¼ˆæ·±è“ç°ï¼‰
                        case TileType.PLATFORM: color = '#8a8a4a'; break;         // é«˜å°ï¼ˆæ·±é»„ç°ï¼‰
                        case TileType.UNDERPASS: color = '#4a8a8a'; break;        // æš—é“ï¼ˆæ·±é’ç°ï¼‰
                        case TileType.CONNECTOR: color = '#8a4a8a'; break;        // è¿æ¥è·¯ï¼ˆæ·±ç´«ç°ï¼‰
                        case TileType.RAMP: color = '#6a6a6a'; break;             // æ–œå¡ï¼ˆä¸­ç°ï¼‰
                        case TileType.ROTATION_PATH: color = '#5a5a5a'; break;    // è½¬ç‚¹è·¯çº¿ï¼ˆæ·±ç°ï¼‰
                        case TileType.SHADOW_POINT: color = '#8a6a4a'; break;      // é˜´ç‚¹ï¼ˆæ·±æ£•ç°ï¼‰
                    }
                    
                    if (tile !== TileType.VOID) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        
                        // ç§»é™¤å¢™å£è¾¹æ¡†ï¼Œä¸ä½¿ç”¨æ ¼å­
                        
                        // ç»˜åˆ¶æ¥¼æ¢¯ç®­å¤´
                        if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                            ctx.fillStyle = '#fff';
                            const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                            ctx.font = fontSize + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(tile === TileType.STAIRS_UP ? 'â†‘' : 'â†“', 
                                x * cellSize + cellSize/2, y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3));
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶åŒ…ç‚¹æ ‡è®°
            const bombFontSize = Math.max(12, Math.floor(cellSize * 1.5));
            ctx.font = 'bold ' + bombFontSize + 'px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = Math.max(1, Math.floor(cellSize * 0.2));
            
            // åŒ…ç‚¹æ ‡è®°æ˜ å°„
            const bombSiteMarkers = {
                [TileType.BOMBSITE_A]: 'A',
                [TileType.BOMBSITE_B]: 'B',
                [TileType.BOMBSITE_C]: 'C',
                [TileType.BOMBSITE_D]: 'D',
                [TileType.BOMBSITE_E]: 'E'
            };
            
            // ç»˜åˆ¶æ‰€æœ‰åŒ…ç‚¹æ ‡è®°
            for (const [tileType, marker] of Object.entries(bombSiteMarkers)) {
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[0].length; x++) {
                        if (map[y][x] === parseInt(tileType)) {
                            ctx.strokeText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                            ctx.fillText(marker, x * cellSize + Math.floor(cellSize * 1.5), y * cellSize + Math.floor(cellSize * 2.5));
                        y = map.length;
                        break;
                        }
                    }
                }
            }
        }
        
        // ç»˜åˆ¶å åŠ è§†å›¾
        function drawOverlayMap() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // å¯ç”¨æŠ—é”¯é½¿å’Œå¹³æ»‘æ•ˆæœ
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            if (!mapFloors[0]) return;
            
            const map = mapFloors[0];
            const mapSize = parseInt(document.getElementById('mapSize').value);
            
            // æ ¹æ®åœ°å›¾å°ºå¯¸åŠ¨æ€è°ƒæ•´æ–¹å—å¤§å°ï¼Œä½¿ç”¨æ›´å°çš„å°ºå¯¸å‡å°‘åƒç´ æ„Ÿ
            let cellSize;
            if (mapSize <= 100) {
                cellSize = 6;
            } else if (mapSize <= 200) {
                cellSize = 4;
            } else if (mapSize <= 400) {
                cellSize = 3;
            } else if (mapSize <= 600) {
                cellSize = 2;
            } else {
                cellSize = 1.5;
            }
            
            // é™åˆ¶ç”»å¸ƒæœ€å¤§å°ºå¯¸ï¼Œé¿å…è¿‡å¤§
            const maxCanvasSize = 1200;
            const actualWidth = map[0].length * cellSize;
            const actualHeight = map.length * cellSize;
            
            if (actualWidth > maxCanvasSize || actualHeight > maxCanvasSize) {
                const scale = Math.min(maxCanvasSize / actualWidth, maxCanvasSize / actualHeight);
                cellSize = Math.floor(cellSize * scale);
            }
            
            canvas.width = map[0].length * cellSize;
            canvas.height = map.length * cellSize;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ä»åº•å±‚åˆ°é¡¶å±‚ç»˜åˆ¶
            for (let floor = 0; floor < totalFloors; floor++) {
                const currentMap = mapFloors[floor];
                const opacity = 1 - (floor * 0.25);
                const offset = floor * 2;
                
                for (let y = 0; y < currentMap.length; y++) {
                    for (let x = 0; x < currentMap[0].length; x++) {
                        const tile = currentMap[y][x];
                        
                        if (tile !== TileType.VOID) {
                            let baseColor = [0, 0, 0];
                            
                            switch(tile) {
                                case TileType.FLOOR: 
                                    baseColor = [74 + floor * 16, 74 + floor * 16, 74 + floor * 16];
                                    break;
                                case TileType.WALL: 
                                    baseColor = [176 - floor * 16, 176 - floor * 16, 176];
                                    break;
                                case TileType.HIGH_GROUND: 
                                    baseColor = [106, 106, 74]; // é«˜åœ°ï¼ˆæµ…é»„ç°ï¼‰
                                    break;
                                case TileType.LOW_GROUND: 
                                    baseColor = [42, 42, 74]; // ä½åœ°ï¼ˆæ·±è“ç°ï¼‰
                                    break;
                                case TileType.MEDIUM_GROUND: 
                                    baseColor = [74, 74, 74]; // ä¸­ç­‰åœ°ï¼ˆæ ‡å‡†ç°ï¼‰
                                    break;
                                case TileType.COVER: 
                                    baseColor = [48, 48, 48];
                                    break;
                                case TileType.BOMBSITE_A: 
                                    baseColor = [90, 90, 0];
                                    break;
                                case TileType.BOMBSITE_B: 
                                    baseColor = [90, 58, 0];
                                    break;
                                case TileType.BOMBSITE_C: 
                                    baseColor = [90, 26, 0]; // åŒ…ç‚¹Cï¼ˆæ·±æ©™ï¼‰
                                    break;
                                case TileType.BOMBSITE_D: 
                                    baseColor = [58, 90, 0]; // åŒ…ç‚¹Dï¼ˆæ·±ç»¿ï¼‰
                                    break;
                                case TileType.BOMBSITE_E: 
                                    baseColor = [26, 90, 0]; // åŒ…ç‚¹Eï¼ˆæ·±é’ï¼‰
                                    break;
                                case TileType.T_SPAWN: 
                                    baseColor = [58, 32, 32];
                                    break;
                                case TileType.CT_SPAWN: 
                                    baseColor = [32, 32, 48];
                                    break;
                                case TileType.STAIRS_UP: 
                                    baseColor = [139, 115, 85];
                                    break;
                                case TileType.STAIRS_DOWN: 
                                    baseColor = [107, 83, 69];
                                    break;
                                case TileType.WATER: 
                                    baseColor = [42, 77, 105];
                                    break;
                                case TileType.WINDOW:
                                    baseColor = [106, 140, 175];
                                    break;
                                // å¸¸è§åœ°å½¢/æ¨¡å—é¢œè‰²
                                case TileType.LONG_LANE:
                                    baseColor = [138, 74, 74]; // å¤§é“ï¼ˆæ·±çº¢ç°ï¼‰
                                    break;
                                case TileType.SHORT_LANE:
                                    baseColor = [74, 138, 74]; // å°é“ï¼ˆæ·±ç»¿ç°ï¼‰
                                    break;
                                case TileType.MID_LANE:
                                    baseColor = [74, 74, 138]; // ä¸­è·¯ï¼ˆæ·±è“ç°ï¼‰
                                    break;
                                case TileType.PLATFORM:
                                    baseColor = [138, 138, 74]; // é«˜å°ï¼ˆæ·±é»„ç°ï¼‰
                                    break;
                                case TileType.UNDERPASS:
                                    baseColor = [74, 138, 138]; // æš—é“ï¼ˆæ·±é’ç°ï¼‰
                                    break;
                                case TileType.CONNECTOR:
                                    baseColor = [138, 74, 138]; // è¿æ¥è·¯ï¼ˆæ·±ç´«ç°ï¼‰
                                    break;
                                case TileType.RAMP:
                                    baseColor = [106, 106, 106]; // æ–œå¡ï¼ˆä¸­ç°ï¼‰
                                    break;
                                case TileType.ROTATION_PATH:
                                    baseColor = [90, 90, 90]; // è½¬ç‚¹è·¯çº¿ï¼ˆæ·±ç°ï¼‰
                                    break;
                                case TileType.SHADOW_POINT:
                                    baseColor = [138, 106, 74]; // é˜´ç‚¹ï¼ˆæ·±æ£•ç°ï¼‰
                                    break;
                                default:
                                    baseColor = [50, 50, 50];
                            }
                            
                            ctx.fillStyle = 'rgba(' + baseColor[0] + ',' + baseColor[1] + ',' + baseColor[2] + ',' + opacity + ')';
                            ctx.fillRect(
                                x * cellSize + offset, 
                                y * cellSize + offset, 
                                cellSize, 
                                cellSize
                            );
                            
                            // ç§»é™¤å¢™å£è¾¹æ¡†ï¼Œä¸ä½¿ç”¨æ ¼å­
                            
                            // æ¥¼æ¢¯æ ‡è®°
                            if (tile === TileType.STAIRS_UP || tile === TileType.STAIRS_DOWN) {
                                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                                const fontSize = Math.max(6, Math.floor(cellSize * 0.6));
                                ctx.font = fontSize + 'px Arial';
                                ctx.textAlign = 'center';
                                const arrow = tile === TileType.STAIRS_UP ? 'â†‘' : 'â†“';
                                ctx.fillText(
                                    arrow, 
                                    x * cellSize + cellSize/2 + offset, 
                                    y * cellSize + cellSize/2 + Math.floor(cellSize * 0.3) + offset
                                );
                            }
                        }
                    }
                }
                
                // æ¥¼å±‚æ ‡ç­¾
                ctx.fillStyle = 'rgba(255, 255, 255, ' + opacity + ')';
                const floorFontSize = Math.max(8, Math.floor(cellSize * 0.8));
                ctx.font = 'bold ' + floorFontSize + 'px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('F' + (floor + 1), Math.floor(cellSize * 0.8) + offset, Math.floor(cellSize * 1.5) + offset);
            }
            
            // æ ‡é¢˜
            ctx.fillStyle = '#4CAF50';
            const titleFontSize = Math.max(10, Math.floor(cellSize * 1.0));
            ctx.font = 'bold ' + titleFontSize + 'px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('å åŠ è§†å›¾', canvas.width - Math.floor(cellSize * 0.8), Math.floor(cellSize * 1.5));
            
            // å›¾ä¾‹
            const legendFontSize = Math.max(8, Math.floor(cellSize * 0.7));
            ctx.font = legendFontSize + 'px Arial';
            ctx.textAlign = 'left';
            for (let i = 0; i < totalFloors; i++) {
                const opacity = 1 - (i * 0.25);
                ctx.fillStyle = 'rgba(200, 200, 200, ' + opacity + ')';
                const legendY = Math.floor(cellSize * 2.5) + i * Math.floor(cellSize * 1.5);
                ctx.fillRect(Math.floor(cellSize * 0.8), legendY, Math.floor(cellSize * 1.2), Math.floor(cellSize * 1.2));
                ctx.fillStyle = '#ccc';
                ctx.fillText('ç¬¬' + (i + 1) + 'å±‚', Math.floor(cellSize * 2.2), legendY + Math.floor(cellSize * 0.8));
            }
        }
        
        // å¯¼å‡ºåœ°å›¾
        function exportMap() {
            const data = {
                floors: mapFloors,
                totalFloors: totalFloors,
                currentFloor: currentFloor
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map_' + Date.now() + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // æ‰¾åˆ°æœ€ä½³çš„é—¨ä½ç½®
        function findBestDoorPosition(room, floor) {
            const sides = [
                { x: room.x, y: room.y + Math.floor(room.height / 2), dx: -1, dy: 0, score: 0 }, // å·¦
                { x: room.x + room.width - 1, y: room.y + Math.floor(room.height / 2), dx: 1, dy: 0, score: 0 }, // å³
                { x: room.x + Math.floor(room.width / 2), y: room.y, dx: 0, dy: -1, score: 0 }, // ä¸Š
                { x: room.x + Math.floor(room.width / 2), y: room.y + room.height - 1, dx: 0, dy: 1, score: 0 } // ä¸‹
            ];
            
            // ä¸ºæ¯ä¸ªä½ç½®è¯„åˆ†
            for (let side of sides) {
                const corridorX = side.x + side.dx;
                const corridorY = side.y + side.dy;
                
                if (corridorX >= 0 && corridorX < mapFloors[floor][0].length && 
                    corridorY >= 0 && corridorY < mapFloors[floor].length) {
                    
                    // æ£€æŸ¥é—¨å¤–æ˜¯å¦æœ‰ç©ºåœ°
                    if (mapFloors[floor][corridorY][corridorX] === TileType.VOID) {
                        side.score += 10;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦é è¿‘å…¶ä»–æˆ¿é—´
                    for (let dy = -3; dy <= 3; dy++) {
                        for (let dx = -3; dx <= 3; dx++) {
                            const nx = corridorX + dx;
                            const ny = corridorY + dy;
                            if (nx >= 0 && nx < mapFloors[floor][0].length && 
                                ny >= 0 && ny < mapFloors[floor].length) {
                                if (mapFloors[floor][ny][nx] === TileType.FLOOR) {
                                    side.score += 5;
                                }
                            }
                        }
                    }
                }
            }
            
            // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„ä½ç½®
            sides.sort((a, b) => b.score - a.score);
            return sides[0].score > 0 ? sides[0] : null;
        }
        
        // åˆ›å»ºè¿ç»­æ°´åŸŸåŒºåŸŸ
        function createWaterAreas(waterAmount) {
            const mapSize = mapFloors[0].length;
            const waterCount = Math.floor(mapSize * mapSize * waterAmount / 1000);
            
            // åˆ›å»ºå¤šä¸ªæ°´åŸŸåŒºåŸŸ
            const waterAreas = Math.max(1, Math.floor(waterCount / 50)); // æ ¹æ®æ°´åŸŸæ•°é‡å†³å®šåŒºåŸŸæ•°é‡
            
            for (let area = 0; area < waterAreas; area++) {
                // éšæœºé€‰æ‹©æ°´åŸŸèµ·å§‹ç‚¹
                let startX, startY;
                let attempts = 0;
                const maxAttempts = 100;
                
                do {
                    startX = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    startY = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    (startX < 0 || startX >= mapSize || startY < 0 || startY >= mapSize ||
                     !mapFloors[0][startY] || mapFloors[0][startY][startX] === undefined ||
                     (mapFloors[0][startY][startX] !== TileType.FLOOR &&
                      mapFloors[0][startY][startX] !== TileType.MEDIUM_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.HIGH_GROUND &&
                      mapFloors[0][startY][startX] !== TileType.LOW_GROUND))
                );
                
                if (attempts >= maxAttempts) continue;
                
                // ä½¿ç”¨æ´ªæ°´å¡«å……ç®—æ³•åˆ›å»ºè¿ç»­æ°´åŸŸ
                const areaSize = Math.floor(waterCount / waterAreas);
                floodFillWater(startX, startY, areaSize);
            }
        }
        
        // æ´ªæ°´å¡«å……ç®—æ³•åˆ›å»ºæ°´åŸŸ
        function floodFillWater(startX, startY, maxSize) {
            const queue = [{x: startX, y: startY}];
            const visited = new Set();
            let filledCount = 0;
            
            while (queue.length > 0 && filledCount < maxSize) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                                        // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦é€‚åˆæ”¾ç½®æ°´åŸŸ
                        if (current.x >= 0 && current.x < mapFloors[0][0].length &&
                            current.y >= 0 && current.y < mapFloors[0].length &&
                            mapFloors[0][current.y] && mapFloors[0][current.y][current.x] !== undefined) {
                            
                            if (mapFloors[0][current.y][current.x] === TileType.FLOOR ||
                                mapFloors[0][current.y][current.x] === TileType.MEDIUM_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.HIGH_GROUND ||
                                mapFloors[0][current.y][current.x] === TileType.LOW_GROUND) {
                                
                                // æ”¾ç½®æ°´åŸŸ
                                mapFloors[0][current.y][current.x] = TileType.WATER;
                        filledCount++;
                        
                        // æ·»åŠ ç›¸é‚»ä½ç½®åˆ°é˜Ÿåˆ—
                        const directions = [
                            {dx: -1, dy: 0}, {dx: 1, dy: 0},
                            {dx: 0, dy: -1}, {dx: 0, dy: 1}
                        ];
                        
                        for (const dir of directions) {
                            const nextX = current.x + dir.dx;
                            const nextY = current.y + dir.dy;
                            const nextKey = `${nextX},${nextY}`;
                            
                            if (!visited.has(nextKey) && 
                                nextX >= 0 && nextX < mapFloors[0][0].length &&
                                nextY >= 0 && nextY < mapFloors[0].length) {
                                
                                // éšæœºå†³å®šæ˜¯å¦ç»§ç»­æ‰©å±•ï¼ˆåˆ›å»ºè‡ªç„¶å½¢çŠ¶ï¼‰
                                if (Math.random() < 0.7) { // 70%æ¦‚ç‡ç»§ç»­æ‰©å±•
                                    queue.push({x: nextX, y: nextY});
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // ç§å­ç³»ç»Ÿ
        let savedSeeds = [];
        let currentSeed = null;
        
        // ç”Ÿæˆå½“å‰å‚æ•°çš„å”¯ä¸€ç§å­
        function generateSeed() {
            const params = {
                mapSize: document.getElementById('mapSize').value,
                floorCount: document.getElementById('floorCount').value,
                roomCount: document.getElementById('roomCount').value,
                roomSize: document.getElementById('roomSize').value,
                roomPosition: document.getElementById('roomPosition').value,
                corridorWidth: document.getElementById('corridorWidth').value,
                pathComplexity: document.getElementById('pathComplexity').value,
                corridorRandom: document.getElementById('corridorRandom').value,
                coverDensity: document.getElementById('coverDensity').value,
                waterAmount: document.getElementById('waterAmount').value,
                stairsCount: document.getElementById('stairsCount').value,
                windowDensity: document.getElementById('windowDensity').value,
                elevation: document.getElementById('elevation').value,
                longLanes: document.getElementById('longLanes').value,
                midControl: document.getElementById('midControl').value,
                rotateTime: document.getElementById('rotateTime').value,
                verticality: document.getElementById('verticality').value,
                breakables: document.getElementById('breakables').value,
                fieldLayout: document.getElementById('fieldLayout').value,
                gameMode: document.getElementById('gameMode').value,
                mapStyle: document.getElementById('mapStyle').value,
                outdoorRatio: document.getElementById('outdoorRatio').value,
                outdoorSize: document.getElementById('outdoorSize').value,
                outdoorArea: document.getElementById('outdoorArea').value,
                generateLobby: document.getElementById('generateLobby').value,
                nadeSpots: document.getElementById('nadeSpots').value,
                // å¸¸è§åœ°å½¢/æ¨¡å—å‚æ•°
                longLane: document.getElementById('longLane').value,
                shortLane: document.getElementById('shortLane').value,
                midLane: document.getElementById('midLane').value,
                platform: document.getElementById('platform').value,
                underpass: document.getElementById('underpass').value,
                connector: document.getElementById('connector').value,
                ramp: document.getElementById('ramp').value,
                rotation: document.getElementById('rotation').value,
                bombSiteCount: document.getElementById('bombSiteCount').value,
                shadowPoint: document.getElementById('shadowPoint').value,
                roomFill: document.getElementById('roomFill').value
            };
            
            // åˆ›å»ºç§å­å­—ç¬¦ä¸²
            const seedString = JSON.stringify(params);
            return btoa(seedString).substring(0, 16); // å–å‰16ä½ä½œä¸ºç§å­
        }
        
        // ä¿å­˜å½“å‰ç§å­
        function saveCurrentSeed() {
            const seed = generateSeed();
            const seedName = prompt('è¯·è¾“å…¥ç§å­åç§°:', `ç§å­_${new Date().toLocaleDateString()}`);
            
            if (!seedName) return;
            
            const seedData = {
                id: Date.now(),
                name: seedName,
                seed: seed,
                date: new Date().toISOString(),
                params: {
                    mapSize: document.getElementById('mapSize').value,
                    floorCount: document.getElementById('floorCount').value,
                    roomCount: document.getElementById('roomCount').value,
                    roomSize: document.getElementById('roomSize').value,
                    roomPosition: document.getElementById('roomPosition').value,
                    corridorWidth: document.getElementById('corridorWidth').value,
                    pathComplexity: document.getElementById('pathComplexity').value,
                    corridorRandom: document.getElementById('corridorRandom').value,
                    coverDensity: document.getElementById('coverDensity').value,
                    waterAmount: document.getElementById('waterAmount').value,
                    stairsCount: document.getElementById('stairsCount').value,
                    windowDensity: document.getElementById('windowDensity').value,
                    elevation: document.getElementById('elevation').value,
                    longLanes: document.getElementById('longLanes').value,
                    midControl: document.getElementById('midControl').value,
                    rotateTime: document.getElementById('rotateTime').value,
                    verticality: document.getElementById('verticality').value,
                    breakables: document.getElementById('breakables').value,
                    fieldLayout: document.getElementById('fieldLayout').value,
                    gameMode: document.getElementById('gameMode').value,
                    mapStyle: document.getElementById('mapStyle').value,
                    outdoorRatio: document.getElementById('outdoorRatio').value,
                    outdoorSize: document.getElementById('outdoorSize').value,
                    outdoorArea: document.getElementById('outdoorArea').value,
                    generateLobby: document.getElementById('generateLobby').value,
                    nadeSpots: document.getElementById('nadeSpots').value,
                    longLane: document.getElementById('longLane').value,
                    shortLane: document.getElementById('shortLane').value,
                    midLane: document.getElementById('midLane').value,
                    platform: document.getElementById('platform').value,
                    underpass: document.getElementById('underpass').value,
                    connector: document.getElementById('connector').value,
                    ramp: document.getElementById('ramp').value,
                    rotation: document.getElementById('rotation').value,
                    bombSiteCount: document.getElementById('bombSiteCount').value,
                    shadowPoint: document.getElementById('shadowPoint').value,
                    roomFill: document.getElementById('roomFill').value
                }
            };
            
            savedSeeds.push(seedData);
            saveSeedsToStorage();
            renderSeedsList();
        }
        
        // åº”ç”¨ç§å­å‚æ•°
        function applySeed(seedData) {
            const params = seedData.params;
            
            // åº”ç”¨æ‰€æœ‰å‚æ•°
            Object.keys(params).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = params[key];
                    
                    // è§¦å‘oninputäº‹ä»¶ä»¥æ›´æ–°æ˜¾ç¤ºå€¼
                    if (element.oninput) {
                        element.oninput();
                    }
                }
            });
            
            // ç‰¹æ®Šå¤„ç†ä¸‹æ‹‰èœå•
            if (params.gameMode) {
                document.getElementById('gameMode').value = params.gameMode;
                applyGameMode(params.gameMode);
            }
            
            if (params.mapStyle) {
                document.getElementById('mapStyle').value = params.mapStyle;
                applyMapStyle(params.mapStyle);
            }
            
            // é‡æ–°ç”Ÿæˆåœ°å›¾
            generateMap();
        }
        
        // åˆ é™¤ç§å­
        function deleteSeed(seedId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç§å­å—ï¼Ÿ')) {
                savedSeeds = savedSeeds.filter(seed => seed.id !== seedId);
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // æ¸…ç©ºæ‰€æœ‰ç§å­
        function clearAllSeeds() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç§å­å—ï¼Ÿ')) {
                savedSeeds = [];
                saveSeedsToStorage();
                renderSeedsList();
            }
        }
        
        // æ¸²æŸ“ç§å­åˆ—è¡¨
        function renderSeedsList() {
            const seedsList = document.getElementById('seedsList');
            seedsList.innerHTML = '';
            
            if (savedSeeds.length === 0) {
                seedsList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">æš‚æ— æ”¶è—çš„ç§å­</div>';
                return;
            }
            
            savedSeeds.forEach(seed => {
                const seedItem = document.createElement('div');
                seedItem.className = 'seed-item';
                
                const date = new Date(seed.date);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString().substring(0, 5);
                
                // åˆ›å»ºå‚æ•°æ‘˜è¦
                const paramSummary = [
                    `å°ºå¯¸: ${seed.params.mapSize}`,
                    `å±‚æ•°: ${seed.params.floorCount}`,
                    `æˆ¿é—´: ${seed.params.roomCount}`,
                    `æ©ä½“: ${seed.params.coverDensity}%`,
                    `æ°´åŸŸ: ${seed.params.waterAmount}%`
                ].join(' | ');
                
                seedItem.innerHTML = `
                    <div class="seed-header">
                        <div class="seed-name">${seed.name}</div>
                        <div class="seed-date">${dateStr}</div>
                    </div>
                    <div class="seed-params">${paramSummary}</div>
                    <div class="seed-actions">
                        <button onclick="applySeed(${JSON.stringify(seed).replace(/"/g, '&quot;')})">åº”ç”¨</button>
                        <button class="delete" onclick="deleteSeed(${seed.id})">åˆ é™¤</button>
                    </div>
                `;
                
                seedsList.appendChild(seedItem);
            });
        }
        
        // ä¿å­˜ç§å­åˆ°æœ¬åœ°å­˜å‚¨
        function saveSeedsToStorage() {
            localStorage.setItem('mapGeneratorSeeds', JSON.stringify(savedSeeds));
        }
        
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½ç§å­
        function loadSeedsFromStorage() {
            const stored = localStorage.getItem('mapGeneratorSeeds');
            if (stored) {
                savedSeeds = JSON.parse(stored);
            }
        }
        
        // æ·»åŠ æˆ¿é—´å¡«å……ï¼ˆä½¿ç”¨è¿·å®«ç®—æ³•å¡«å……æˆ¿é—´ï¼‰
        function addRoomFilling(rooms, floor) {
            const roomFillDensity = parseInt(document.getElementById('roomFill').value);
            if (roomFillDensity === 0) return; // æ— å¡«å……
            
            const densityMultiplier = [0, 0.3, 0.6, 1.0, 1.5][roomFillDensity]; // å¯†åº¦å€æ•°
            console.log(`æ¥¼å±‚${floor}æˆ¿é—´å¡«å……å¯†åº¦: ${roomFillDensity}, å€æ•°: ${densityMultiplier}`);
            
            let totalFilledRooms = 0;
            
            for (let room of rooms) {
                // è·³è¿‡å¤ªå°çš„æˆ¿é—´
                if (room.width < 8 || room.height < 8) continue;
                
                // æ ¹æ®å¯†åº¦å†³å®šæ˜¯å¦å¡«å……è¿™ä¸ªæˆ¿é—´
                if (Math.random() < densityMultiplier) {
                    console.log(`æˆ¿é—´(${room.x},${room.y},${room.width}x${room.height}) ä½¿ç”¨è¿·å®«å¡«å……ï¼Œå¯†åº¦: ${roomFillDensity}`);
                    
                    if (createMazeInRoom(room, floor, roomFillDensity)) {
                        totalFilledRooms++;
                    }
                }
            }
            
            console.log(`æ¥¼å±‚${floor}æ€»å…±å¡«å……äº†${totalFilledRooms}ä¸ªè¿·å®«æˆ¿é—´`);
        }
        
        // åœ¨æˆ¿é—´å†…éƒ¨åˆ›å»ºè¿·å®«
        function createMazeInRoom(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2; // ç•™å‡ºè¾¹è·
            const roomHeight = parentRoom.height - 2;
            
            if (roomWidth < 4 || roomHeight < 4) return false;
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´è¿·å®«ç½‘æ ¼å¤§å°
            const densityFactors = [0, 1.5, 1.2, 1.0, 0.8]; // å¯†åº¦è¶Šé«˜ï¼Œç½‘æ ¼è¶Šå°ï¼ˆæ›´å¯†é›†ï¼‰
            const gridSizeFactor = densityFactors[density];
            
            // è®¡ç®—è¿·å®«ç½‘æ ¼å¤§å°ï¼ˆæ ¹æ®å¯†åº¦è°ƒæ•´ï¼‰
            const baseMazeWidth = Math.floor(roomWidth / 2);
            const baseMazeHeight = Math.floor(roomHeight / 2);
            const mazeWidth = Math.max(2, Math.floor(baseMazeWidth * gridSizeFactor));
            const mazeHeight = Math.max(2, Math.floor(baseMazeHeight * gridSizeFactor));
            
            console.log(`è¿·å®«ç½‘æ ¼: ${mazeWidth}x${mazeHeight}, å¯†åº¦: ${density}, ç½‘æ ¼å› å­: ${gridSizeFactor}`);
            
            // åˆ›å»ºè¿·å®«ç½‘æ ¼
            const maze = createMazeGrid(mazeWidth, mazeHeight, density);
            
            // å°†è¿·å®«åº”ç”¨åˆ°æˆ¿é—´ä¸­
            applyMazeToRoom(maze, parentRoom, floor, density);
            
            // åˆ›å»ºå…¥å£å’Œå‡ºå£
            createMazeEntrances(parentRoom, floor, density);
            
            return true;
        }
        
        // åˆ›å»ºè¿·å®«ç½‘æ ¼ï¼ˆä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼‰
        function createMazeGrid(width, height, density) {
            // åˆå§‹åŒ–è¿·å®«ç½‘æ ¼ï¼Œæ‰€æœ‰å¢™éƒ½æ˜¯å°é—­çš„
            const maze = [];
            for (let y = 0; y < height * 2 + 1; y++) {
                maze[y] = [];
                for (let x = 0; x < width * 2 + 1; x++) {
                    maze[y][x] = 1; // 1è¡¨ç¤ºå¢™ï¼Œ0è¡¨ç¤ºé€šé“
                }
            }
            
            // ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆè¿·å®«
            const stack = [];
            const visited = new Set();
            
            // ä»å·¦ä¸Šè§’å¼€å§‹
            const startX = 1;
            const startY = 1;
            stack.push([startX, startY]);
            visited.add(`${startX},${startY}`);
            maze[startY][startX] = 0;
            
            const directions = [
                [0, -2], // ä¸Š
                [2, 0],  // å³
                [0, 2],  // ä¸‹
                [-2, 0]  // å·¦
            ];
            
            while (stack.length > 0) {
                const [currentX, currentY] = stack[stack.length - 1];
                
                // éšæœºæ‰“ä¹±æ–¹å‘
                const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                
                let moved = false;
                for (const [dx, dy] of shuffledDirections) {
                    const newX = currentX + dx;
                    const newY = currentY + dy;
                    
                    if (newX >= 1 && newX < width * 2 && newY >= 1 && newY < height * 2) {
                        const key = `${newX},${newY}`;
                        if (!visited.has(key)) {
                            // æ‰“é€šå¢™å£
                            maze[currentY + dy/2][currentX + dx/2] = 0;
                            maze[newY][newX] = 0;
                            
                            visited.add(key);
                            stack.push([newX, newY]);
                            moved = true;
                            break;
                        }
                    }
                }
                
                if (!moved) {
                    stack.pop();
                }
            }
            
            // æ ¹æ®å¯†åº¦æ·»åŠ é¢å¤–çš„å¢™å£ï¼ˆå¢åŠ è¿·å®«å¤æ‚åº¦ï¼‰
            addDensityWalls(maze, width, height, density);
            
            return maze;
        }
        
        // æ ¹æ®å¯†åº¦æ·»åŠ é¢å¤–çš„å¢™å£
        function addDensityWalls(maze, width, height, density) {
            const densityFactors = [0, 0.1, 0.2, 0.3, 0.5]; // å¯†åº¦è¶Šé«˜ï¼Œé¢å¤–å¢™å£è¶Šå¤š
            const extraWallChance = densityFactors[density];
            
            if (extraWallChance === 0) return;
            
            const totalCells = width * height;
            const extraWalls = Math.floor(totalCells * extraWallChance);
            
            console.log(`æ·»åŠ ${extraWalls}ä¸ªé¢å¤–å¢™å£ï¼Œå¯†åº¦: ${density}, æ¦‚ç‡: ${extraWallChance}`);
            
            for (let i = 0; i < extraWalls; i++) {
                // éšæœºé€‰æ‹©ä½ç½®æ·»åŠ å¢™å£
                const x = 1 + Math.floor(Math.random() * (width - 1)) * 2;
                const y = 1 + Math.floor(Math.random() * (height - 1)) * 2;
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ·»åŠ å¢™å£ï¼ˆä¸ä¼šå®Œå…¨å°é—­åŒºåŸŸï¼‰
                if (canAddWall(maze, x, y)) {
                    maze[y][x] = 1;
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ·»åŠ å¢™å£
        function canAddWall(maze, x, y) {
            // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰è¶³å¤Ÿçš„é€šé“
            let channelCount = 0;
            const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length) {
                    if (maze[ny][nx] === 0) {
                        channelCount++;
                    }
                }
            }
            
            // ç¡®ä¿è‡³å°‘æœ‰ä¸¤ä¸ªé€šé“è¿æ¥
            return channelCount >= 2;
        }
        
        // å°†è¿·å®«åº”ç”¨åˆ°æˆ¿é—´ä¸­
        function applyMazeToRoom(maze, parentRoom, floor, density) {
            const startX = parentRoom.x + 1;
            const startY = parentRoom.y + 1;
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´å¢™å£åšåº¦
            const wallThickness = Math.max(1, Math.floor(density / 2)); // å¯†åº¦è¶Šé«˜ï¼Œå¢™å£è¶Šåš
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    const worldX = startX + x;
                    const worldY = startY + y;
                    
                    if (worldX >= 0 && worldX < mapFloors[floor][0].length && 
                        worldY >= 0 && worldY < mapFloors[floor].length) {
                        if (mapFloors[floor][worldY] && mapFloors[floor][worldY][worldX] !== undefined) {
                            if (maze[y][x] === 1) {
                                // å¢™å£ï¼ˆæ ¹æ®å¯†åº¦è°ƒæ•´åšåº¦ï¼‰
                                for (let wy = 0; wy < wallThickness; wy++) {
                                    for (let wx = 0; wx < wallThickness; wx++) {
                                        const thickX = worldX + wx;
                                        const thickY = worldY + wy;
                                        if (thickX >= 0 && thickX < mapFloors[floor][0].length && 
                                            thickY >= 0 && thickY < mapFloors[floor].length) {
                                            if (mapFloors[floor][thickY] && mapFloors[floor][thickY][thickX] !== undefined) {
                                                mapFloors[floor][thickY][thickX] = TileType.WALL;
                                            }
                                        }
                                    }
                                }
                            } else {
                                // é€šé“
                                mapFloors[floor][worldY][worldX] = TileType.FLOOR;
                            }
                        }
                    }
                }
            }
            
            console.log(`è¿·å®«å¢™å£åšåº¦: ${wallThickness}, å¯†åº¦: ${density}`);
        }
        
        // åˆ›å»ºè¿·å®«å…¥å£å’Œå‡ºå£
        function createMazeEntrances(parentRoom, floor, density) {
            const roomWidth = parentRoom.width;
            const roomHeight = parentRoom.height;
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´å…¥å£æ•°é‡
            const entranceCount = Math.min(4, Math.max(1, Math.floor(density / 2) + 1));
            
            // åˆ›å»ºå¤šä¸ªå…¥å£ï¼ˆæ ¹æ®å¯†åº¦ï¼‰
            for (let e = 0; e < entranceCount; e++) {
                // éšæœºé€‰æ‹©å…¥å£ä½ç½®ï¼ˆæˆ¿é—´è¾¹ç¼˜ï¼‰
                const entranceSide = Math.floor(Math.random() * 4);
                let entranceX, entranceY;
                
                switch (entranceSide) {
                    case 0: // ä¸Šè¾¹
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y;
                        break;
                    case 1: // å³è¾¹
                        entranceX = parentRoom.x + roomWidth - 1;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                    case 2: // ä¸‹è¾¹
                        entranceX = parentRoom.x + Math.floor(roomWidth / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        entranceY = parentRoom.y + roomHeight - 1;
                        break;
                    case 3: // å·¦è¾¹
                        entranceX = parentRoom.x;
                        entranceY = parentRoom.y + Math.floor(roomHeight / 2) + (e - Math.floor(entranceCount/2)) * 2;
                        break;
                }
                
                // åˆ›å»ºå…¥å£é—¨
                if (entranceX >= 0 && entranceX < mapFloors[floor][0].length && 
                    entranceY >= 0 && entranceY < mapFloors[floor].length) {
                    if (mapFloors[floor][entranceY] && mapFloors[floor][entranceY][entranceX] !== undefined) {
                        mapFloors[floor][entranceY][entranceX] = TileType.DOOR;
                    }
                }
            }
            
            // æ ¹æ®å¯†åº¦è°ƒæ•´å†…éƒ¨é—¨æ•°é‡
            const internalDoorCount = Math.min(5, Math.max(1, density + 1));
            for (let i = 0; i < internalDoorCount; i++) {
                createRandomInternalDoor(parentRoom, floor, density);
            }
            
            console.log(`è¿·å®«å…¥å£æ•°é‡: ${entranceCount}, å†…éƒ¨é—¨æ•°é‡: ${internalDoorCount}, å¯†åº¦: ${density}`);
        }
        
        // åˆ›å»ºéšæœºå†…éƒ¨é—¨
        function createRandomInternalDoor(parentRoom, floor, density) {
            const roomWidth = parentRoom.width - 2;
            const roomHeight = parentRoom.height - 2;
            
            let attempts = 0;
            const maxAttempts = 30; // å¢åŠ å°è¯•æ¬¡æ•°
            
            while (attempts < maxAttempts) {
                const x = parentRoom.x + 1 + Math.floor(Math.random() * roomWidth);
                const y = parentRoom.y + 1 + Math.floor(Math.random() * roomHeight);
                
                if (x >= 0 && x < mapFloors[floor][0].length && 
                    y >= 0 && y < mapFloors[floor].length) {
                    if (mapFloors[floor][y] && mapFloors[floor][y][x] !== undefined) {
                        if (mapFloors[floor][y][x] === TileType.WALL) {
                            // æ ¹æ®å¯†åº¦å†³å®šæ˜¯å¦åˆ›å»ºé—¨ï¼ˆå¯†åº¦è¶Šé«˜ï¼Œè¶Šå®¹æ˜“åˆ›å»ºé—¨ï¼‰
                            const doorChance = 0.3 + (density * 0.15); // 30% + å¯†åº¦*15%
                            if (Math.random() < doorChance) {
                                mapFloors[floor][y][x] = TileType.DOOR;
                                return;
                            }
                        }
                    }
                }
                attempts++;
            }
        }
        

        
        // æ·»åŠ é˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
        function addShadowPoints(density, floor = 0) {
            const mapSize = mapFloors[floor].length;
            const densityMultiplier = [0, 0.3, 0.8, 1.5, 2.5][density]; // è°ƒæ•´å¯†åº¦å€æ•°ï¼Œä½¿é»˜è®¤å€¼æ›´æ˜æ˜¾
            const shadowPointCount = Math.max(1, Math.floor(mapSize * mapSize * densityMultiplier / 150)); // å¢åŠ åŸºç¡€æ•°é‡
            
            console.log(`æ¥¼å±‚${floor}é˜´ç‚¹å¯†åº¦: ${density}, å€æ•°: ${densityMultiplier}, ç›®æ ‡æ•°é‡: ${shadowPointCount}`);
            
            let createdCount = 0;
            for (let i = 0; i < shadowPointCount * 2; i++) { // å¢åŠ å°è¯•æ¬¡æ•°
                // éšæœºé€‰æ‹©ä½ç½®
                let x, y;
                let attempts = 0;
                const maxAttempts = 30;
                
                do {
                    x = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    y = Math.floor(Math.random() * (mapSize - 4)) + 2;
                    attempts++;
                } while (
                    attempts < maxAttempts && 
                    !isValidShadowPointPosition(x, y, floor)
                );
                
                if (attempts >= maxAttempts) continue;
                
                // åˆ›å»ºé˜´ç‚¹ï¼ˆå‚ç›´å°å¢™ä½“ï¼‰
                createShadowPoint(x, y, floor);
                createdCount++;
                
                if (createdCount >= shadowPointCount) break;
            }
            
            console.log(`æ¥¼å±‚${floor}å®é™…åˆ›å»ºé˜´ç‚¹æ•°é‡: ${createdCount}`);
        }
        
        // æ£€æŸ¥é˜´ç‚¹ä½ç½®æ˜¯å¦æœ‰æ•ˆ
        function isValidShadowPointPosition(x, y, floor = 0) {
            // æ£€æŸ¥è¾¹ç•Œå’Œæ•°ç»„æœ‰æ•ˆæ€§
            if (x < 0 || x >= mapFloors[floor][0].length || 
                y < 0 || y >= mapFloors[floor].length ||
                !mapFloors[floor][y] || mapFloors[floor][y][x] === undefined) {
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦åœ¨åœ°æ¿æˆ–é“è·¯ä¸Š
            if (mapFloors[floor][y][x] !== TileType.FLOOR &&
                mapFloors[floor][y][x] !== TileType.MEDIUM_GROUND &&
                mapFloors[floor][y][x] !== TileType.HIGH_GROUND &&
                mapFloors[floor][y][x] !== TileType.LOW_GROUND) {
                return false;
            }
            
            // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆæ”¾å®½æ¡ä»¶ï¼‰
            let floorCount = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < mapFloors[floor][0].length && 
                        ny >= 0 && ny < mapFloors[floor].length) {
                        if (mapFloors[floor][ny] && mapFloors[floor][ny][nx] !== undefined &&
                            (mapFloors[floor][ny][nx] === TileType.FLOOR ||
                             mapFloors[floor][ny][nx] === TileType.MEDIUM_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.HIGH_GROUND ||
                             mapFloors[floor][ny][nx] === TileType.LOW_GROUND)) {
                            floorCount++;
                        }
                    }
                }
            }
            
            // ç¡®ä¿å‘¨å›´æœ‰è¶³å¤Ÿçš„åœ°æ¿ç©ºé—´ï¼ˆé™ä½è¦æ±‚ï¼‰
            return floorCount >= 5;
        }
        
        // åˆ›å»ºå•ä¸ªé˜´ç‚¹
        function createShadowPoint(x, y, floor = 0) {
            const mapSize = mapFloors[floor].length;
            
            // éšæœºå†³å®šé˜´ç‚¹çš„æ–¹å‘ï¼ˆå‚ç›´æˆ–æ°´å¹³ï¼‰
            const isVertical = Math.random() < 0.7; // 70%æ¦‚ç‡ä¸ºå‚ç›´
            const length = Math.floor(Math.random() * 3) + 2; // 2-4æ ¼é•¿åº¦
            
            if (isVertical) {
                // åˆ›å»ºå‚ç›´é˜´ç‚¹
                for (let i = 0; i < length; i++) {
                    const ny = y + i;
                    if (ny >= 0 && ny < mapSize && mapFloors[floor][ny] && mapFloors[floor][ny][x] !== undefined) {
                        if (mapFloors[floor][ny][x] === TileType.FLOOR ||
                            mapFloors[floor][ny][x] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][ny][x] === TileType.HIGH_GROUND ||
                            mapFloors[floor][ny][x] === TileType.LOW_GROUND) {
                            mapFloors[floor][ny][x] = TileType.SHADOW_POINT;
                        }
                    }
                }
            } else {
                // åˆ›å»ºæ°´å¹³é˜´ç‚¹
                for (let i = 0; i < length; i++) {
                    const nx = x + i;
                    if (nx >= 0 && nx < mapSize && mapFloors[floor][y] && mapFloors[floor][y][nx] !== undefined) {
                        if (mapFloors[floor][y][nx] === TileType.FLOOR ||
                            mapFloors[floor][y][nx] === TileType.MEDIUM_GROUND ||
                            mapFloors[floor][y][nx] === TileType.HIGH_GROUND ||
                            mapFloors[floor][y][nx] === TileType.LOW_GROUND) {
                            mapFloors[floor][y][nx] = TileType.SHADOW_POINT;
                        }
                    }
                }
            }
        }
        
        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', function() {
            document.getElementById('generateBtn').addEventListener('click', generateMap);
            document.getElementById('randomBtn').addEventListener('click', function() {
                randomizeParameters();
                generateMap();
            });
            document.getElementById('exportBtn').addEventListener('click', exportMap);
            
            // ç§å­ç³»ç»Ÿäº‹ä»¶ç›‘å¬å™¨
            document.getElementById('saveSeedBtn').addEventListener('click', saveCurrentSeed);
            document.getElementById('clearSeedsBtn').addEventListener('click', clearAllSeeds);
            
            // åŠ è½½ä¿å­˜çš„ç§å­
            loadSeedsFromStorage();
            renderSeedsList();
            
            // ç”Ÿæˆåˆå§‹åœ°å›¾
            generateMap();
        });
    </script>
</body>
</html>